<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ArchLinux + GNOME 安装教程</title>
    <link href="/2024/04/06/ArchLinux+GNOME%E5%AE%89%E8%A3%85/"/>
    <url>/2024/04/06/ArchLinux+GNOME%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本安装教程是根据 <a href="https://wiki.archlinuxcn.org/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97">ArchWiki—安装指南 </a> 、 <a href="https://www.cnblogs.com/vconlln/articles/17065410.html">Archlinux安装与美化全流程</a>  以及笔者多次试验总结而成。如有遗漏或者错误请多指正。</p><h1 id="一-准备工作"><a href="#一-准备工作" class="headerlink" title="一.准备工作"></a>一.准备工作</h1><h2 id="1-1-写入软件"><a href="#1-1-写入软件" class="headerlink" title="1.1 写入软件"></a>1.1 写入软件</h2><p>当前市面上有许多U盘烧录工具，如Rufus、USBWriter、Ventoy等。笔者在这里强烈建议使用 Ventoy ，它是由国人制作的一款完全免费的开源工具，可以非常简单地部署启动镜像。在此贴上链接：<a href="https://www.ventoy.net/cn/">Ventoy官网</a> 。   </p><h2 id="1-2-镜像文件"><a href="#1-2-镜像文件" class="headerlink" title="1.2 镜像文件"></a>1.2 镜像文件</h2><p>当今网络非常发达，想要获取资源也有多个途径。简单给出镜像获取的两种途径：</p><ol><li><p>Arch Linux 官方网站下载 ISO 文件：<a href="https://archlinux.org/download/">Arch Linux Downloads</a></p></li><li><p>国内镜像仓库下载系统 ISO 文件：<a href="https://mirrors.tuna.tsinghua.edu.cn/archlinux/iso/">清华源</a>、<a href="https://mirrors.aliyun.com/archlinux/iso/?spm=a2c6h.25603864.0.0.281a7b8755JtRB">阿里云源</a></p></li></ol><blockquote><p><strong>注</strong>：</p><p>由于 Arch Linux 系统采用的是滚动更新模式，因此在安装系统时更推荐选取最新的系统镜像。</p></blockquote><h2 id="1-3-镜像烧录"><a href="#1-3-镜像烧录" class="headerlink" title="1.3 镜像烧录"></a>1.3 镜像烧录</h2><p>笔者使用 Ventoy 软件进行烧录。具体步骤如下：</p><ol><li>在 Windows 系统环境下打开 Ventoy 软件，将分区类型选择为 GPT 格式</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Arch%20Linux%20Install/%E9%95%9C%E5%83%8F%E5%86%99%E5%85%A5%E8%BD%AF%E4%BB%B6Ventoy/1.%E5%90%AF%E5%8A%A8%E7%9B%98%E5%88%86%E5%8C%BA%E9%80%89%E6%8B%A9.png" alt="选择GPT分区格式"  /></div><ol start="2"><li>将 Ventoy 软件安装到 U 盘中</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Arch%20Linux%20Install/%E9%95%9C%E5%83%8F%E5%86%99%E5%85%A5%E8%BD%AF%E4%BB%B6Ventoy/2.%E5%B0%86Ventoy%E5%AE%89%E8%A3%85%E5%88%B0U%E7%9B%98%E9%87%8C.png" alt="安装Ventoy驱动到U盘"  /></div><ol start="3"><li>根据下图可以看到安装 Ventoy 到 U 盘中后界面显示设备内部 Ventoy 软件版本</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Arch%20Linux%20Install/%E9%95%9C%E5%83%8F%E5%86%99%E5%85%A5%E8%BD%AF%E4%BB%B6Ventoy/3.%E6%88%90%E5%8A%9F%E5%B0%86Ventoy%E5%AE%89%E8%A3%85%E5%88%B0U%E7%9B%98%E4%B8%AD.png" alt="Ventoy安装后"  /></div><ol start="4"><li>安装了 Ventoy ，以后想部署任何系统可直接将对应的 ISO 镜像拷贝到 U 盘中即可，然后开机选择对应镜像即可进入。</li></ol><h1 id="二-安装系统"><a href="#二-安装系统" class="headerlink" title="二.安装系统"></a>二.安装系统</h1><p>将写入系统镜像的U盘插到待安装系统的电脑上，开机选择U盘启动项即可开始安装。</p><blockquote><p><strong>注</strong>：</p><p>不少主板有类似于 Secure Boot 的安全选项，如果开启可能导致已经安装 Windows 为第一系统的情况下安装 Linux系统失败，因此这一项应当 Disable 掉。</p></blockquote><h2 id="2-1-检查-UEFI-启动"><a href="#2-1-检查-UEFI-启动" class="headerlink" title="2.1 检查 UEFI 启动"></a>2.1 检查 UEFI 启动</h2><p>首先应当明确一点就是，此主板是支持 BIOS 启动还是 UEFI 启动。因此可以通过如下命令查看详情：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls /sys/firmware/efi/efivars<br></code></pre></td></tr></table></figure><p>如果此命令显示一大堆文件夹，那么此主板的引导方式就是 UEFI ，否则便是 BIOS 。</p><h2 id="2-2-联网"><a href="#2-2-联网" class="headerlink" title="2.2 联网"></a>2.2 联网</h2><p>由于 Arch Linux 的安装是在线安装模式，网络状况将直接决定安装是否顺利。因此在正式安装前应当配置好网络。</p><h3 id="2-2-1-启用网卡"><a href="#2-2-1-启用网卡" class="headerlink" title="2.2.1 启用网卡"></a>2.2.1 启用网卡</h3><p>如果不确定网卡是否启用，可以通过 <code>rfkill</code> 命令查看网卡状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">获取网卡列表及各网卡的状态</span><br>rfkill list<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启用所有网卡</span><br>rfkill unblock all<br></code></pre></td></tr></table></figure><h3 id="2-2-2-有线网络"><a href="#2-2-2-有线网络" class="headerlink" title="2.2.2 有线网络"></a>2.2.2 有线网络</h3><p>针对有线网络。可以直接使用 <code>dhcpcd</code> 命令获取路由器分配的 IP 上网。</p><h3 id="2-2-3-无线网络"><a href="#2-2-3-无线网络" class="headerlink" title="2.2.3 无线网络"></a>2.2.3 无线网络</h3><p>无线网络的配置稍显麻烦一点，可通过 <code>iwctl</code> 命令配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入配置界面</span><br>iwctl<br><span class="hljs-meta prompt_"># </span><span class="language-bash">获取网络设备列表</span><br>device list<br><span class="hljs-meta prompt_"># </span><span class="language-bash">扫描网络设备</span><br>station &lt;device_name&gt; scan  # 如 wlan0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">获取局域网 WiFi 列表</span><br>station &lt;device_name&gt; get-networks<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将对应网络设备连接到指定 WiFi</span><br>station &lt;device_name&gt; connect &lt;WiFi Name&gt; <br></code></pre></td></tr></table></figure><h3 id="2-2-4-验证网络连通性"><a href="#2-2-4-验证网络连通性" class="headerlink" title="2.2.4 验证网络连通性"></a>2.2.4 验证网络连通性</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ping baidu.com<br></code></pre></td></tr></table></figure><p>如果收到网络 icmp 回包则网络配置正确。</p><h2 id="2-3-时间同步"><a href="#2-3-时间同步" class="headerlink" title="2.3 时间同步"></a>2.3 时间同步</h2><p>在正式安装之前也应当配置时间同步，否则可能由于时间验证失败而导致下载安装包失败。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看时间日期状态</span><br>timedatectl status<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启用网络时间同步（NTP ）</span><br>timedatectl set-ntp true<br></code></pre></td></tr></table></figure><h2 id="2-4-更换镜像源"><a href="#2-4-更换镜像源" class="headerlink" title="2.4 更换镜像源"></a>2.4 更换镜像源</h2><p>由于国内访问国外网站可能会很慢或者失败的情况，因此更换国内镜像源显得尤为重要。可通过更改 <code>/etc/pacman.d/mirrorlist</code> 配置文件换源。</p><ol><li>打开配置文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">打开镜像配置文件</span><br>nano /etc/pacman.d/mirrorlist<br></code></pre></td></tr></table></figure><ol start="2"><li>找到第一个 Server 关键字，并在前方添加需要的镜像站链接</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加开源镜像站链接</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">中国科学技术大学</span><br>Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch <br><span class="hljs-meta prompt_"># </span><span class="language-bash">重庆邮电大学</span><br>Server = https://mirrors.cqupt.edu.cn/archlinux/$repo/os/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重庆大学</span><br>Server = https://mirrors.cqu.edu.cn/archlinux/$repo/os/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">南方科技大学</span><br>Server = https://mirrors.sustech.edu.cn/archlinux/$repo/os/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">华中科技大学</span><br>Server = https://mirrors.hust.edu.cn/archlinux/$repo/os/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">北京外国语大学</span><br>Server = https://mirrors.bfsu.edu.cn/archlinux/$repo/os/$arch<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">华为开源镜像站</span><br>Server = https://mirrors.huaweicloud.com/archlinux/$repo/os/$arch<br><span class="hljs-meta prompt_">#</span><span class="language-bash">Server = https://repo.huaweicloud.com/archlinux/<span class="hljs-variable">$repo</span>/os/<span class="hljs-variable">$arch</span></span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">阿里云镜像站</span><br>Server = http://mirrors.aliyun.com/archlinux/$repo/os/$arch<br></code></pre></td></tr></table></figure><ol start="3"><li>执行如下命令更新同步数据库</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -Sy<br></code></pre></td></tr></table></figure><h2 id="2-5-硬盘分区"><a href="#2-5-硬盘分区" class="headerlink" title="2.5 硬盘分区"></a>2.5 硬盘分区</h2><p>对硬盘进行分区是安装 Linux 系统最重要的一步，如有不注意可能导致该盘数据丢失，因此这一步需要格外小心谨慎地操作。可通过 Windows 系统上的 DiskGenius 软件划出一块空闲的硬盘空间，然后进入 Arch Linux 的 LiveCD 之后使用 <code>cfdisk</code> 命令分区完成，举例得到如下几个分区表：</p><table><thead><tr><th align="center">大小</th><th align="center">分区</th><th align="center">分区类型</th><th align="center">挂载点</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">512M</td><td align="center">&#x2F;dev&#x2F;sdb1</td><td align="center">EFI System</td><td align="center">&#x2F;mnt&#x2F;boot</td><td align="center">引导分区</td></tr><tr><td align="center">8G</td><td align="center">&#x2F;dev&#x2F;sdb4</td><td align="center">Linux swap</td><td align="center">—</td><td align="center">交换分区</td></tr><tr><td align="center">100G</td><td align="center">&#x2F;dev&#x2F;sdb5</td><td align="center">Linux root (x86-64)</td><td align="center">&#x2F;mnt</td><td align="center">根分区</td></tr><tr><td align="center">100G</td><td align="center">&#x2F;dev&#x2F;sdb6</td><td align="center">Linux filesystem 或 Linux home</td><td align="center">&#x2F;mnt&#x2F;home</td><td align="center">主目录</td></tr></tbody></table><blockquote><p>注：</p><ol><li><p>交换分区无需分配挂载点，只需分区之后开启或者关闭即可</p></li><li><p>笔者有一个三星 SSD 硬盘以及一个西数的机械硬盘，因此会有两个编号：</p><ol><li>三星 SSD 硬盘编号：<code>/sda</code></li><li>西数 机械 硬盘编号：<code>/sdb</code></li></ol></li><li><p>有的 LiveCD 系统镜像没有 <code>Linux home</code>分区类型，则可以使用 <code>Linux filesystem</code>分区类型</p></li><li><p><code>Legacy</code> 引导方式无需创建 boot 分区，<code>UEFI</code> 引导方式则需要创建 boot 分区。</p></li></ol></blockquote><h3 id="2-5-1-格式化分区"><a href="#2-5-1-格式化分区" class="headerlink" title="2.5.1 格式化分区"></a>2.5.1 格式化分区</h3><p>在使用之前应当要格式化分区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看需要分区列表确定需要格式化的分区</span><br>lsblk -T<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">格式化引导分区</span><br>mkfs.fat -F 32 /dev/sdb1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">格式化交换分区</span><br>mkswap /dev/sdb4<br><span class="hljs-meta prompt_"># </span><span class="language-bash">格式化根分区</span><br>mkfs.ext4 /dev/sdb5<br><span class="hljs-meta prompt_"># </span><span class="language-bash">格式化主目录分区</span><br>mkfs.ext4 /dev/sdb6<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><h3 id="2-5-2-挂载分区"><a href="#2-5-2-挂载分区" class="headerlink" title="2.5.2 挂载分区"></a>2.5.2 挂载分区</h3><p>挂载分区的思路是先创建挂载点，然后将指定目录挂载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看需要分区列表确定需要挂载的分区</span><br>lsblk -T<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">挂载引导分区</span><br>mount --mkdir /dev/sdb1 /mnt/boot<br><span class="hljs-meta prompt_"># </span><span class="language-bash">开启交换分区</span><br>swapon /dev/sdb4<br><span class="hljs-meta prompt_"># </span><span class="language-bash">挂载根分区</span><br>mount /dev/sdb5 /mnt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">挂载主目录分区</span><br>mount --mkdir /dev/sdb6 /mnt/home<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><p>分区挂载完一定要查看是否挂载成功，否则后续装入系统可能会出现各种问题</p></blockquote><h2 id="2-6-安装基础系统"><a href="#2-6-安装基础系统" class="headerlink" title="2.6 安装基础系统"></a>2.6 安装基础系统</h2><p>使用 <code>pacstrap</code>命令可以安装 Arch Linux 的基本系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacstrap -K /mnt base base-devel linux linux-firmware linux-headers<br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><ul><li><p>base 包：基础包</p></li><li><p>base-devel 包：如使用 yay 需要安装此包</p></li><li><p>linux 包：linux 内核包，尽量安装阶段不动，也可替换为 <a href="https://wiki.archlinuxcn.org/wiki/%E5%86%85%E6%A0%B8">Wiki内核页面</a>介绍的如 linux-lts 的其他内核软件包</p></li><li><p>linux-firmware 包：linux 内核固件包</p></li><li><p>linux-headers 包：linux 内核头文件包</p></li></ul><p>PS: base base-devel linux linux-firmware 为最基础的四个包</p></blockquote><h2 id="2-7-安装系统常用软件"><a href="#2-7-安装系统常用软件" class="headerlink" title="2.7 安装系统常用软件"></a>2.7 安装系统常用软件</h2><p>使用 <code>pacstrap</code>命令安装 Arch Linux 系统的常用软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacstrap -K /mnt networkmanager dhcpcd openssh iwd  vim nano neofetch sudo ntfs-3g<br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><ul><li><p>networkmanager 包：网络管理软件</p></li><li><p>dhcpcd 包：DHCP 协议 IP 分发客户端</p></li><li><p>openssh 包：远程终端登陆软件</p></li><li><p>iwd 包：提供了客户端程序 <code>iwctl</code>、守护程序 <code>iwd</code> 和 WiFi 监控工具 <code>iwmon</code></p></li><li><p>vim、nano 包：编辑器</p></li><li><p>neofetch 包：查看系统信息软件</p></li><li><p>sudo 包：超级用户权限管理软件</p></li><li><p>ntfs-3g 包：提供 ntfs 文件系统的支持</p></li></ul></blockquote><h2 id="2-8-生成文件系统表"><a href="#2-8-生成文件系统表" class="headerlink" title="2.8 生成文件系统表"></a>2.8 生成文件系统表</h2><p>通常情况下，UEFI 引导搭配的是 GPT 分区格式，而早前的 BIOS 引导则是搭配的 MBR 分区格式。因此，在生成文件系统表时会根据不同搭配使用不同命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">生成文件系统表</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. UEFI + GPT</span><br>genfstab -U /mnt &gt;&gt; /mnt/etc/fstab<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. BIOS + MBR</span><br>genfstab -p /mnt &gt;&gt; /mnt/etc/fstab<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看文件系统表是否生成</span><br>cat /mnt/etc/fstab<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><p>在生成文件系统分区表后一定要查看是否生成，否则万一 boot 分区表没有写入 fstab 文件的话后续配置 Grub 可能会失败</p></blockquote><h1 id="三-配置系统"><a href="#三-配置系统" class="headerlink" title="三.配置系统"></a>三.配置系统</h1><p>第二章节的操作保证了 Arch Linux 基本系统的安装，我们还需要进入新安装的系统内部进行一些更细致的配置。通过 <code>arch-chroot</code> 进入新系统：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">arch-chroot /mnt<br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><p>chroot 的意思就是 change root 的含义，arch-chroot 这条指令的意思就是将操作权从 LiveCD 的启动系统转交给新安装的系统，方便在新系统内部进行更多的配置。</p></blockquote><h2 id="3-1-开机自启服务"><a href="#3-1-开机自启服务" class="headerlink" title="3.1 开机自启服务"></a>3.1 开机自启服务</h2><p>在 <code>第二章第七节</code> 安装了许多除系统基础软件包之外的额外软件包，而有的软件服务是需要开机自启的。下面的命令便是启动开机服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">systemctl 几个参数的含义</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. <span class="hljs-built_in">enable</span>：设置开机自启，反之为 <span class="hljs-built_in">disable</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. start：设置本次启动，反之为 stop</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3. status：查看服务状态</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">开启网络服务</span><br>systemctl enable NetworkManager.service<br>systemctl start NetworkManager.service<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">开启 dhcpcd 服务</span><br>systemctl enable dhcpcd.service<br>systemctl start dhcpcd.service<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br>开启 ssh 服务<br>systemctl enable sshd.service<br>systemctl start sshd.service<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><h2 id="3-2-设置时区"><a href="#3-2-设置时区" class="headerlink" title="3.2 设置时区"></a>3.2 设置时区</h2><p>使用如下指令设置时区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -sf /usr/share/zoneinfo/Region地区名/City城市名 /etc/localtime<br><span class="hljs-meta prompt_"># </span><span class="language-bash">举例如下所示</span><br>ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br></code></pre></td></tr></table></figure><p>然后使用 <code>hwclock</code> 命令生成 <code>/etc/adjtime</code> 同步时间配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hwclock --systohc<br></code></pre></td></tr></table></figure><h2 id="3-3-本地化"><a href="#3-3-本地化" class="headerlink" title="3.3 本地化"></a>3.3 本地化</h2><p>完成本地化需要对两个文件进行处理： <code>locale.gen</code> 文件以及 <code>locale.conf</code> 文件</p><ol><li>编辑 <code>/etc/locale.gen</code> 文件去掉两项内容注释：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">en_US.UTF-8 UTF-8</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">zh_CN.UTF-8 UTF-8</span><br></code></pre></td></tr></table></figure><p>然后使用 <code>locale-gen</code> 命令生成 Locale。</p><ol start="2"><li>编辑 <code>/etc/locale.conf</code> 文件，更改为如下内容</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">LANG=en_US.UTF-8</span><br>LANG=zh_CN.UTF-8<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br>LC_CTYPE=zh_CN.UTF-8            # 字符输入<br>LC_NUMERIC=zh_CN.UTF-8          # 数字<br>LC_TIME=zh_CN.UTF-8# 时间显示格式<br>LC_COLLATE=zh_CN.UTF-8          # 比较和排序习惯<br>LC_MONETARY=zh_CN.UTF-8         # 货币单位<br>LC_MESSAGES=zh_CN.UTF-8         # 信息<br>LC_PAPER=zh_CN.UTF-8        # 默认纸张尺寸方式<br>LC_NAME=zh_CN.UTF-8        # 姓名书写方式<br>LC_ADDRESS=zh_CN.UTF-8          # 地址书写方式<br>LC_TELEPHONE=zh_CN.UTF-8        # 电话号码书写方式<br>LC_MEASUREMENT=zh_CN.UTF-8      # 度量衡表达方式<br>LC_IDENTIFICATION=zh_CN.UTF-8   # 对 locale 自身包含信息概述<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">LC_ALL=zh_CN.UTF-8</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><p>LC_ALL、LC_* 和 LANG 优先级的关系：LC_ALL &gt; LC_* &gt; LANG</p></blockquote><h2 id="3-4-配置-hostname-和-hosts-文件"><a href="#3-4-配置-hostname-和-hosts-文件" class="headerlink" title="3.4 配置 hostname 和 hosts 文件"></a>3.4 配置 hostname 和 hosts 文件</h2><ol><li>配置 hostname 文件</li></ol><p>通过编辑 <code>/etc/hostname</code> 文件配置主机名，如果没有该文件则创建该文件。然后在该文件中按需写入主机名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">例如创建名为 ArchLinux 的主机</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过 vim 编辑器编辑 hostname 文件</span><br>vim /etc/hostname<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">写入主机名</span><br>ArchLinux<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><ol start="2"><li>配置 hosts 文件</li></ol><p>通过编辑 <code>/etc/hosts</code> 文件编辑 hosts，如果没有该文件则创建该文件。然后在该文件中写入如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span>  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过 vim 编辑器编辑 hosts 文件</span><br>vim /etc/hosts<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">写入如下内容</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Standard host addresses</span><br>127.0.0.1localhost<br>::1      localhost<br><span class="hljs-meta prompt_"># </span><span class="language-bash">This host address</span><br>127.0.1.1            ArchLinux.localdomainArchLinux<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><h2 id="3-5-新建用户"><a href="#3-5-新建用户" class="headerlink" title="3.5 新建用户"></a>3.5 新建用户</h2><p>使用系统前端时，开机会有一个用户登陆界面，默认只有一个 root 用户，在使用 root 用户登陆之后可以添加一个新用户。</p><blockquote><p><strong>注</strong>：</p><p>在新建用户并重启系统之前一定要更改 root 用户的密码，具体操作命令为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># 使用该命令修改密码</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">passwd root</span><br></code></pre></td></tr></table></figure><p>然后需要重复输入密码，修改成功会有提示。</p></blockquote><ol><li>添加新用户的具体操作如下：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加新用户</span><br>useradd -m -G wheel &lt;username&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">为新用户修改密码</span><br>passwd &lt;username&gt;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><p>上述命令中各个参数的含义：</p><ol><li><code>-m</code> ：创建新用户的同时创建其对应的家目录</li><li><code>-G</code> ：指定附加组（wheel 附加组可以进行 sudo 提权操作）</li><li><code>&lt;username&gt;</code> ：新建用户名，注意区分大小写</li></ol></blockquote><ol start="2"><li>修改 <code>/etc/sudoer</code> 配置文件</li></ol><p>访问 <code>/etc/sudoer</code> 并取消 <code># %wheel ALL=(ALL) ALL</code> 这一行注释。</p><blockquote><p><strong>注</strong>：</p><p><code>%wheel</code> 的百分号表示用户组前缀；第一个 <code>ALL</code> 表示任意主机名；第二个 <code>ALL</code> 表示任意用户名；第三个 <code>ALL</code> 表示可执行任意命令。</p></blockquote><h2 id="3-6-安装引导"><a href="#3-6-安装引导" class="headerlink" title="3.6 安装引导"></a>3.6 安装引导</h2><h3 id="3-6-1-平台驱动安装"><a href="#3-6-1-平台驱动安装" class="headerlink" title="3.6.1 平台驱动安装"></a>3.6.1 平台驱动安装</h3><p>针对 Intel 平台和 AMD 平台的 CPU 开机引导加载驱动程序会有所不同，因此要按需安装对应驱动程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看本机 CPU 型号</span><br>cat /proc/cpuinfo<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. Intel CPU 安装</span><br>pacman -S intel-ucode<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. AMD CPU 安装</span><br>pacman -S amd-ucode<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><h3 id="3-6-2-Grub-配置"><a href="#3-6-2-Grub-配置" class="headerlink" title="3.6.2 Grub 配置"></a>3.6.2 Grub 配置</h3><p>在配置 Grub 之前还应当安装对应的软件包，同样的 Grub 也是分不同的引导方式。</p><ol><li>安装 Grub 相关软件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. UEFI + GPT</span><br>pacman -S grub efibootmgr efivar os-prober<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. BIOS + MBR</span><br>pacman -S grub efivar os-prober<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><ol><li><code>os-prober</code> 的作用在于能发现 Windows 系统的引导</li><li>在最新版本的 Grub2 引导方式中，<code>os-prober</code> 默认被关闭，想要启用此功能需要在 <code>/etc/default/grub</code> 配置文件中将 <code># GRUB_DISABLE_OS_PROBER=false</code> 字段取消注释。</li></ol></blockquote><ol start="2"><li>配置 Grub 启动引导</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. UEFI + GPT</span><br>grub-install --target=x86_64-efi --efi-directory=&lt;EFI Dir&gt; --bootloader-id=Arch --removable<br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;EFI Dir&gt; 通常情况下为 /boot 分区</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. BIOS + MBR</span><br>grub-install --target=i386-pc &lt;Dir&gt; --removable --force<br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;Dir&gt; 为指定的一个分区</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li>生成 Grub 引导配置文件</li></ol><p>这一步是通过下面指令实现的，这一配置文件的修改都是通过 <code>/etc/default/grub</code> 修改并 <code>grub-mkconfig</code> 生成到此配置文件的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">grub-mkconfig -o /boot/grub/grub.cfg<br></code></pre></td></tr></table></figure><h2 id="3-7-重启系统"><a href="#3-7-重启系统" class="headerlink" title="3.7 重启系统"></a>3.7 重启系统</h2><p>至此 ArchLinux 的命令行安装方式到此结束。先退出 <code>arch-chroot</code> （exit 或者 quit 都可以），然后卸载挂载点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">卸载引导分区</span><br>umount /dev/sdb1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭交换分区</span><br>swapoff /dev/sdb4<br><span class="hljs-meta prompt_"># </span><span class="language-bash">卸载根分区</span><br>umount /dev/sdb5<br><span class="hljs-meta prompt_"># </span><span class="language-bash">挂载主目录分区</span><br>umount /dev/sdb6<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看需要分区列表确定需要挂载的分区</span><br>lsblk -T<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><p>在确认卸载挂载点完毕之后便可重新启动系统，注意重启屏幕点亮之前一定要拔掉 U 盘。</p><h1 id="四-GNOME-桌面环境安装"><a href="#四-GNOME-桌面环境安装" class="headerlink" title="四.GNOME 桌面环境安装"></a>四.GNOME 桌面环境安装</h1><h2 id="4-1-Xorg-服务安装"><a href="#4-1-Xorg-服务安装" class="headerlink" title="4.1 Xorg 服务安装"></a>4.1 Xorg 服务安装</h2><p>由于 GNOME 桌面环境默认使用了 Wayland 的显示服务器协议。Wayland 采用了 Xwayland 子协议以兼容 X 协议。由于 Wayland 现阶段的兼容性问题，笔者还是采用了更传统的基于 X 协议的 Xorg 服务。具体安装也非常简单，仅需如下命令安装 Xorg 服务器端程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S xorg-server<br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><p>Xorg 程序是对于 X11（也叫X Window 或 X）协议的实现</p></blockquote><p>想要正常使用 Xorg 服务，还需要对 <code>~/.xinitrc</code> 文件进行一些配置：</p><ol><li>如果是 GNOME on Xorg ，需要在上述文件中添加如下内容：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">export XDG_SESSION_TYPE=x11<br>export GDK_BACKEND=x11<br>exec gnome-session<br></code></pre></td></tr></table></figure><ol start="2"><li>如果是 GNOME Classic ，需要在上述文件中添加如下内容：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">export XDG_CURRENT_DESKTOP=GNOME-Classic:GNOME<br>export GNOME_SHELL_SESSION_MODE=classic<br>exec gnome-session<br></code></pre></td></tr></table></figure><h2 id="4-2-gnome-包安装"><a href="#4-2-gnome-包安装" class="headerlink" title="4.2 gnome 包安装"></a>4.2 gnome 包安装</h2><p>要想使用 GNOME 桌面环境，安装对应的软件包如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S gnome gnome-tweaks gnome-terminal dconf-editor<br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><ol><li><p>GDM 是包含在 gnome 基础包里面的</p></li><li><p>下面是在 gnome-extra 包中较常用到的包：</p><ul><li><a href="https://archlinux.org/packages/extra/any/gnome-tweaks/"> gnome-tweaks</a> gnome 主题相关配置</li><li><a href="https://archlinux.org/packages/extra/x86_64/gnome-terminal/"> gnome-terminal</a> gnome 自带终端</li><li><a href="https://archlinux.org/packages/extra/x86_64/dconf-editor/"> dconf-editor</a> dconf 系统配置的 GUI 界面</li></ul></li></ol></blockquote><p>为保证 GNOME 桌面环境正常使用，需要开机启动 GDM 服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">开机自启 GDM 服务</span><br>systemctl enable gdm.service<br><span class="hljs-meta prompt_"># </span><span class="language-bash">本次启动 GDM 服务</span><br>systemctl start gdm.service<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 GDM 服务状态</span><br>systemctl status gdm.service<br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><p><a href="https://aur.archlinux.org/pkgbase/gdm-settings">gdm-settings</a> gdm 的部分设置 GUI 界面</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Arch</tag>
      
      <tag>Linux</tag>
      
      <tag>GNOME</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Manjaro桌面快捷方式创建</title>
    <link href="/2024/02/23/Manjaro%E6%A1%8C%E9%9D%A2%E5%9B%BE%E6%A0%87%E5%88%9B%E5%BB%BA/"/>
    <url>/2024/02/23/Manjaro%E6%A1%8C%E9%9D%A2%E5%9B%BE%E6%A0%87%E5%88%9B%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在 Manjaro 系统日常使用中，有的软件点击率和使用率更高，因此这就需要使用更方便的访问方式，而桌面图标就能满足这一需求。在 Windows 系统中可直接将可执行程序（EXE程序）以创建快捷链接的方式实现桌面访问，而 Linux 系统需要自己创建 desktop 文件并修改相应键值对来达到桌面访问的目的。本文以下部分将阐述具体的实现方式。</p><h1 id="一-了解-desktop-文件"><a href="#一-了解-desktop-文件" class="headerlink" title="一.了解 desktop 文件"></a>一.了解 desktop 文件</h1><p>为了描述如何启动特定程序、如何在菜单中显示等功能，采用配置文件的方式写入相关信息可大大简化维护的时间成本。 <code>Desktop Entry</code> 配置文件就是在这样的背景下应运而生的，像诸如 <code>KDE</code> 、 <code>GNOME</code> 等桌面环境都采用了这一方式。</p><h2 id="1-1-编写说明"><a href="#1-1-编写说明" class="headerlink" title="1.1 编写说明"></a>1.1 编写说明</h2><p>desktop 文件有诸多语法规则和编写相关的配置操作。部分细节如下所示，更加完整的规则可参阅文档： <a href="https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html#recognized-keys">Desktop Entry Specification</a> </p><ol><li><p>Desktop Entry 文件采用 UTF-8 编码。</p></li><li><p>Desktop Entry 文件命名采用 <code>.desktop</code> 后缀</p></li><li><p>使用 <code>#</code> 号书写备注信息</p></li><li><p>此文件所有内容采用 <code>键值对</code> 格式书写</p></li><li><p>关键字可以选择进行本地化显示，具体的细则如下表：</p></li></ol><table><thead><tr><th align="center">LC_MESSAGES Value</th><th align="center">可选值</th></tr></thead><tbody><tr><td align="center">lang_COUNTRY@MODIFIER</td><td align="center">lang_COUNTRY@MODIFIER，lang_COUNTRY，lang@MODIFIER，lang，默认值</td></tr><tr><td align="center">lang_COUNTRY</td><td align="center">lang_COUNTRY，lang，默认值</td></tr><tr><td align="center">lang@MODIFIER</td><td align="center">lang@MODIFIER，lang，默认值</td></tr><tr><td align="center">lang</td><td align="center">lang，默认值</td></tr></tbody></table><p>具体书写方式为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">`[ ]` 内的内容为可选项，非必须</span><br>key[LC_MESSAGES Value]=value<br></code></pre></td></tr></table></figure><h2 id="1-2-编写规则"><a href="#1-2-编写规则" class="headerlink" title="1.2 编写规则"></a>1.2 编写规则</h2><p>要想创建桌面图标，首先需要了解桌面项的编写方式，具体可参考文档： <a href="https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html#recognized-keys">Desktop Entry Specification Version 1.5</a> 。</p><p>此文件的最重要内容是键值对，关键字的选取尤为关键，每个桌面项<strong>必须</strong>具有一个<code>Type</code>关键字和一个<code>Name</code>关键字，其他项定义应用程序菜单中的外观（<strong>非必须</strong>）。下面是此版本关键字的摘要表格。</p><table><thead><tr><th align="center">序号</th><th align="center">关键字</th><th align="center">值类型</th><th align="center">是否必须</th><th align="center">应用类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">Type</td><td align="center">string</td><td align="center">必须</td><td align="center">&#x2F;</td><td align="center">类型</td></tr><tr><td align="center">2</td><td align="center">Version</td><td align="center">string</td><td align="center">非必须</td><td align="center">Type 1-3</td><td align="center">版本</td></tr><tr><td align="center">3</td><td align="center">Name</td><td align="center">localestring</td><td align="center">必须</td><td align="center">Type 1-3</td><td align="center">名称</td></tr><tr><td align="center">4</td><td align="center">GenericName</td><td align="center">localestring</td><td align="center">非必须</td><td align="center">Type 1-3</td><td align="center">通用名</td></tr><tr><td align="center">5</td><td align="center">NoDisplay</td><td align="center">boolean</td><td align="center">非必须</td><td align="center">Type 1-3</td><td align="center">不显示</td></tr><tr><td align="center">6</td><td align="center">Comment</td><td align="center">localestring</td><td align="center">非必须</td><td align="center">Type 1-3</td><td align="center">备注信息</td></tr><tr><td align="center">7</td><td align="center">Icon</td><td align="center">iconstring</td><td align="center">非必须</td><td align="center">Type 1-3</td><td align="center">图标</td></tr><tr><td align="center">8</td><td align="center">Hidden</td><td align="center">boolean</td><td align="center">非必须</td><td align="center">Type 1-3</td><td align="center">隐藏项</td></tr><tr><td align="center">9</td><td align="center">OnlyShowIn，NotShowIn</td><td align="center">string(s)</td><td align="center">非必须</td><td align="center">Type 1-3</td><td align="center">显示项</td></tr><tr><td align="center">10</td><td align="center">DBusActivatable</td><td align="center">boolean</td><td align="center">非必须</td><td align="center">&#x2F;</td><td align="center">D-Bus 选项</td></tr><tr><td align="center">11</td><td align="center">TryExec</td><td align="center">string</td><td align="center">非必须</td><td align="center">Type 1</td><td align="center">尝试执行</td></tr><tr><td align="center">12</td><td align="center">Exec</td><td align="center">string</td><td align="center">非必须</td><td align="center">Type 1</td><td align="center">执行</td></tr><tr><td align="center">13</td><td align="center">Path</td><td align="center">string</td><td align="center">非必须</td><td align="center">Type 1</td><td align="center">路径</td></tr><tr><td align="center">14</td><td align="center">Terminal</td><td align="center">boolean</td><td align="center">非必须</td><td align="center">Type 1</td><td align="center">终端</td></tr><tr><td align="center">15</td><td align="center">Actions</td><td align="center">string(s)</td><td align="center">非必须</td><td align="center">Type 1</td><td align="center">行为</td></tr><tr><td align="center">16</td><td align="center">MimeType</td><td align="center">string(s)</td><td align="center">非必须</td><td align="center">Type 1</td><td align="center">MIME 类型</td></tr><tr><td align="center">17</td><td align="center">Categories</td><td align="center">string(s)</td><td align="center">非必须</td><td align="center">Type 1</td><td align="center">类型</td></tr><tr><td align="center">18</td><td align="center">Implements</td><td align="center">string(s)</td><td align="center">非必须</td><td align="center">&#x2F;</td><td align="center">执行</td></tr><tr><td align="center">19</td><td align="center">Keywords</td><td align="center">localestring(s)</td><td align="center">非必须</td><td align="center">Type 1</td><td align="center">关键词</td></tr><tr><td align="center">20</td><td align="center">StartupNotify</td><td align="center">boolean</td><td align="center">非必须</td><td align="center">Type 1</td><td align="center">-</td></tr><tr><td align="center">21</td><td align="center">StartupWMClass</td><td align="center">string</td><td align="center">非必须</td><td align="center">Type 1</td><td align="center">-</td></tr><tr><td align="center">22</td><td align="center">URL</td><td align="center">string</td><td align="center">必须</td><td align="center">Type 2</td><td align="center">链接</td></tr><tr><td align="center">23</td><td align="center">PrefersNonDefaultGPU</td><td align="center">boolean</td><td align="center">非必须</td><td align="center">Type 1</td><td align="center">默认显卡</td></tr><tr><td align="center">24</td><td align="center">SingleMainWindow</td><td align="center">boolean</td><td align="center">非必须</td><td align="center">Type 1</td><td align="center">单窗口</td></tr></tbody></table><blockquote><p><strong>注</strong>：</p><ol><li><code>string</code>  类型可以是包含 ASCII 码中除控制符外的所有字符。</li><li><code>localestring</code> 类型是用户可见的字符类型，通常采用 UTF-8 编码。</li><li><code>iconstring</code>  与 <code>localestring</code> 类型大体上一致，只是用户不可见。同样采用 UTF-8 编码。</li><li><code>boolean</code>为布尔类型</li></ol></blockquote><h3 id="1-2-1-关键字详细说明"><a href="#1-2-1-关键字详细说明" class="headerlink" title="1.2.1 关键字详细说明"></a>1.2.1 关键字详细说明</h3><p>对表格的详细说明如下：</p><ol><li><p>Type<code> 关键字</code> ：指定 <code>Desktop Entry</code> 的类型。在 Version 1.5 规范中定义了三种类型：&#96; </p><ol><li><p>Type1 ： <code>Application</code></p></li><li><p>Type2 ： <code>Link</code></p></li><li><p>Type3 ： <code>Directory</code></p></li></ol></li><li><p><code>Version</code> 关键字：指定<code>Desktop Entry</code> 的版本号。</p></li><li><p><code>Name</code> 关键字：指定应用程序的名称。</p></li><li><p><code>GenericName</code> 关键字：指定应用程序的通用名。</p></li><li><p><code>NoDisplay</code>  关键字：这个关键字的意思是：“此应用已存在，不在开始菜单显示”。</p></li><li><p><code>Comment</code>  关键字：对于 <code>Name</code> 和 <code>GenericName</code> 关键字的简短解释说明。</p></li><li><p><code>Icon</code>  关键字：指定此应用程序在应用程序浏览器或是在文件浏览器中所显示的图标。一般以绝对路径形式提供。</p></li><li><p><code>Hidden</code>  关键字：此项对已删除的应用或者已卸载仍存在的文件适用。</p></li><li><p><code>OnlyShowIn，NotShowIn</code>  关键字：指定（只显示&#x2F;不显示）在某个桌面环境上。这一字段可对应多个数值。</p></li><li><p><code>DBusActivatable</code>  关键字：D-Bus 消息管理机制的支持。默认值为 false 。此项为 true 值时会默认调用 D-Bus 而忽略掉 Exec 关键字去执行该应用程序。</p></li><li><p><code>TryExec</code>  关键字：用以确定一个可执行文件是否已实际安装的路径</p></li><li><p><code>Exec</code>  关键字：指定可执行程序（可带参数）  ，这一关键字在 <code>DBusActivatable</code> 字段为 false 时生效。这一字段必须存在，以实现兼容性。此关键字的具体介绍可看 <strong>1.2.2 节</strong> 。</p></li><li><p><code>Path</code>  关键字：指定程序运行的 <code>bin</code> 目录。</p></li><li><p><code>Terminal</code>  关键字：确定应用程序的运行是否依赖终端窗口。</p></li><li><p><code>Actions</code>  关键字：标识应用程序行为，这一字段能告诉应用程序执行更具体的操作（一种行为代表一种调用此程序的方式），通俗讲就是此应用程序的鼠标右键功能选项和程序附加应用程序功能。指定的每种行为需要在文件当中新开一个 Group Header。 此关键字的具体介绍可看 <strong>1.2.3 节</strong> 。</p></li><li><p><code>MimeType</code>  关键字：此字段用于指定此应用程序支持的 <code>MIME类型</code> （全称 Multipurpose Internet Mail Extensions，是一种用于定义文档、文件或字节流的性质和格式的标准）。</p></li><li><p><code>Categories</code>  关键字：此字段指定该 <code>Desktop Entry</code> 在开始菜单中显示的类别，可指定多个数值，但默认第一个数值。更加详细的菜单项可查看技术文档：<a href="https://specifications.freedesktop.org/menu-spec/latest/apa.html#main-category-registry">Desktop Menu Specification</a> 。此关键字的具体介绍可看 <strong>1.2.4 节</strong> 。</p></li><li><p><code>Implements</code>  关键字：此字段用于指定 <code>D-Bus</code> 一个或者更多接口名。这一关键字需要 <code>DBusActivatable</code> 字段为 true 时生效。</p></li><li><p><code>Keywords</code>  关键字：指定此字段可以在开始菜单更方便地搜索到此应用。可以指定多个字符串来描述此应用。当然，此字段不应当与 <code>Name</code> 字段和 <code>GenericName</code> 字段重复。</p></li><li><p><code>StartupNotify</code>  关键字：更加完整的协议内容可查看技术文档： <a href="http://www.freedesktop.org/Standards/startup-notification-spec">Startup Notification Protocol Specification</a> 。</p></li><li><p><code>StartupWMClass</code>  关键字：更加完整的协议内容可查看技术文档： <a href="http://www.freedesktop.org/Standards/startup-notification-spec">Startup Notification Protocol Specification</a> 。</p></li><li><p><code>URL</code>  关键字：当 <code>Type</code> 类型为 <code>Link</code> 时此关键字段是必须的，具体功能时指定具体的链接</p></li><li><p><code>PrefersNonDefaultGPU</code>  关键字：这是一个提示性关键字，不是强制性的。如果此字段为 true ，则该程序默认运行在独立显卡上；如果为 false ，则该程序运行在集成显卡上。</p></li><li><p><code>SingleMainWindow</code>  关键字：这是一个提示性关键字，不是强制性的。用于指定是否单窗口运行，如果为 true ，应用只单窗口运行；如果为 flase ，则可多开窗口。</p></li></ol><h3 id="1-2-2-Exec-关键字（第-12-项）"><a href="#1-2-2-Exec-关键字（第-12-项）" class="headerlink" title="1.2.2 Exec 关键字（第 12 项）"></a>1.2.2 Exec 关键字（第 12 项）</h3><p>此关键字用于指定一个或多个参数的可执行程序。指定该可执行程序的方式可以是：<strong>绝对路径</strong>或<strong>此可执行程序的名称</strong>。如果未提供此项，则会在 path 环境变量中去查找可执行文件。</p><p><code>Field Code</code> 码的作用：</p><ol><li><code>%f</code> ： 传递<strong>单本地文件</strong>给本 Desktop Entry 文件。</li><li><code>%F</code> ： 传递<strong>多本地文件</strong>给本 Desktop Entry 文件。</li><li><code>%u</code> ： 传递<strong>单个 URL 或者单个本地路径</strong>给本 Desktop Entry 文件。</li><li><code>%U</code> ： 传递<strong>多个 URL 或者多个本地路径</strong>给本 Desktop Entry 文件。</li><li><code>%i</code> ： 将 Icon 关键字扩展为两个参数。如果 Icon 关键字为空或无 Icon 关键字，则不应扩展为任何参数。</li><li><code>%c</code> ： 此文件中 Name 关键字所列出应用程序的翻译名称。</li><li><code>%k</code> ： 传入位置可以是 URI 或者本地文件名。如果不知道位置，则为空。</li></ol><blockquote><p><strong>注</strong>：</p><ol><li>此 Field Code 码只能从上述前四个中选取一个。这七个 Field Code 码不能在双引号中。</li><li>Field Code 是其他程序调用此 Desktop Entry 文件时传入的参数。</li></ol></blockquote><h3 id="1-2-3-Actions-关键字（第-15-项）"><a href="#1-2-3-Actions-关键字（第-15-项）" class="headerlink" title="1.2.3 Actions 关键字（第 15 项）"></a>1.2.3 Actions 关键字（第 15 项）</h3><p>一个 <code>Desktop Entry</code> 文件可以有一个或多个 <code>Actions</code> 。一个 Action 就对应一种调用此程序的方式。这一方式可以用来创建 Quicklists 或者 Jumplists 。</p><blockquote><p><strong>注</strong>：</p><p>一个 Desktop 文件的组成：</p><ol><li>一个 <code>[Desktop Entry]</code> 组成。必须。</li><li>若干个 <code>[Desktop Aciton &lt;Action Identifier&gt;]</code> 组成。非必须。</li></ol></blockquote><p>指定的每种 Action 都需要在文件当中新开一个 Group Header 。其关键字必须包含 <code>Name</code> ，而 <code>Icon</code> 和 <code>Exec</code> 关键字则非必须。</p><h3 id="1-2-4-Categories-关键字（第-17-项）"><a href="#1-2-4-Categories-关键字（第-17-项）" class="headerlink" title="1.2.4  Categories 关键字（第 17 项）"></a>1.2.4  Categories 关键字（第 17 项）</h3><p>在 Desktop Entry 文件中，可以有一个或者多个 Category ，但是默认选择 Main Category 生效。更多的 Category 项目可以参阅文档：<a href="https://specifications.freedesktop.org/menu-spec/latest/apas02.html">Additional Category</a> 。</p><table><thead><tr><th align="center">Main Category</th><th align="center">描述</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">Audio Video</td><td align="center">多媒体音视频</td><td align="center">-</td></tr><tr><td align="center">Audio</td><td align="center">音频程序</td><td align="center">选择此字段则也须包括 Audio Video 字段</td></tr><tr><td align="center">Video</td><td align="center">视频程序</td><td align="center">选择此字段则也须包括 Audio Video 字段</td></tr><tr><td align="center">Development</td><td align="center">开发者程序</td><td align="center">-</td></tr><tr><td align="center">Education</td><td align="center">教育软件</td><td align="center">-</td></tr><tr><td align="center">Game</td><td align="center">游戏程序</td><td align="center">-</td></tr><tr><td align="center">Graphics</td><td align="center">浏览，处理图片程序</td><td align="center">-</td></tr><tr><td align="center">Network</td><td align="center">网络程序</td><td align="center">-</td></tr><tr><td align="center">Office</td><td align="center">办公软件</td><td align="center">-</td></tr><tr><td align="center">Science</td><td align="center">科学软件</td><td align="center">-</td></tr><tr><td align="center">Settings</td><td align="center">设置</td><td align="center">可能出现在单独菜单中，或者在控制中心中</td></tr><tr><td align="center">System</td><td align="center">系统软件，如日志文件软件</td><td align="center">-</td></tr><tr><td align="center">Utility</td><td align="center">实用程序，如 Accessories</td><td align="center">-</td></tr></tbody></table><h2 id="1-3-存放位置"><a href="#1-3-存放位置" class="headerlink" title="1.3 存放位置"></a>1.3 存放位置</h2><p>通常，通过包管理器或者自动安装的软件要么在用户条目目录下自动创建了 desktop 文件，要么就在系统目录下自动创建了 desktop 文件。在这两个目录下创建了 desktop 文件，访问图标将出现在 Linux 的开始菜单中。如果本人想要在桌面创建图标则需要在主目录的桌面文件夹下创建一个 desktop 文件。</p><h3 id="1-3-1-用户条目的-desktop-文件"><a href="#1-3-1-用户条目的-desktop-文件" class="headerlink" title="1.3.1 用户条目的 desktop 文件"></a>1.3.1 用户条目的 desktop 文件</h3><p>此文件夹下desktop 文件通常是安装软件后自动生成。具体目录如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">~/.local/share/application<br><span class="hljs-meta prompt_"># </span><span class="language-bash">等效于如下路径，其中 dustwind 为笔者的用户目录</span><br>/home/dustwind/.local/share/applications<br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><p>主目录等效于根目录的 home 目录下的用户目录，即：</p><p>～ 等效于 &#x2F;home&#x2F;{UserName} 目录</p></blockquote><h3 id="1-3-2-系统条目的-desktop-文件"><a href="#1-3-2-系统条目的-desktop-文件" class="headerlink" title="1.3.2 系统条目的 desktop 文件"></a>1.3.2 系统条目的 desktop 文件</h3><p>此文件夹下 desktop 文件通常是安装软件后自动生成。具体目录如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">通常的 Linux 系统是如下目录</span><br>/usr/share/applications<br><span class="hljs-meta prompt_"># </span><span class="language-bash">有的 Linux 系统会是如下目录</span><br>/usr/local/share/applications/<br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><p>需要注意的是，<strong>用户条目</strong>下的文件优先级高于<strong>系统条目</strong>下的文件优先级</p></blockquote><h3 id="1-3-3-在桌面访问的-desktop-文件"><a href="#1-3-3-在桌面访问的-desktop-文件" class="headerlink" title="1.3.3 在桌面访问的 desktop 文件"></a>1.3.3 在桌面访问的 desktop 文件</h3><p>如果想要在桌面访问软件，则需要访问软件的 desktop 文件放到如下目录中并编辑对应的桌面项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">中文环境下为如下目录</span><br>~/桌面<br><span class="hljs-meta prompt_"># </span><span class="language-bash">英文环境下为如下目录</span><br>~/Desktop<br></code></pre></td></tr></table></figure><h1 id="二-实现-desktop-文件"><a href="#二-实现-desktop-文件" class="headerlink" title="二.实现 desktop 文件"></a>二.实现 desktop 文件</h1><p>这里以 google-chrome 软件为例编写 desktop 文件。具体可对照规格文档查看具体含义，这里就不再阐述。本章节的实现可以参考： <a href="https://wiki.archlinuxcn.org/wiki/%E6%A1%8C%E9%9D%A2%E9%A1%B9">ArchWiki—桌面项</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Desktop Entry]<br>Version=1.0<br>Name=Google Chrome<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Only KDE 4 seems to use GenericName, so we reuse the KDE strings.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">From Ubuntu<span class="hljs-string">&#x27;s language-pack-kde-XX-base packages, version 9.04-20090413.</span></span><br>GenericName=Web Browser<br>GenericName[en_GB]=Web Browser<br>GenericName[zh_CN]=网页浏览器<br>GenericName[zh_TW]=網頁瀏覽器<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">Gnome and KDE 3 uses Comment.</span></span><br>Comment=Access the Internet<br>Comment[en_GB]=Access the Internet<br>Comment[zh_CN]=访问互联网<br>Comment[zh_TW]=連線到網際網路<br>StartupWMClass=Google-chrome<br>Exec=/usr/bin/google-chrome-stable %U<br>StartupNotify=true<br>Terminal=false<br>Icon=google-chrome<br>Type=Application<br>Categories=Network;WebBrowser;<br>MimeType=application/pdf;application/rdf+xml;application/rss+xml;application/xhtml+xml;application/xhtml_xml;application/xml;image/gif;image/jpeg;image/png;image/webp;text/html;text/xml;x-scheme-handler/http;x-scheme-handler/https;<br>Actions=new-window;new-private-window;<br><br>[Desktop Action new-window]<br>Name=New Window<br>Name[en_GB]=New Window<br>Name[zh_CN]=新建窗口<br>Name[zh_TW]=開新視窗<br>StartupWMClass=Google-chrome<br>Exec=/usr/bin/google-chrome-stable<br><br>[Desktop Action new-private-window]<br>Name=New Incognito Window<br>Name[en_GB]=New Incognito window<br>Name[zh_CN]=新建隐身窗口<br>Name[zh_TW]=新增無痕式視窗<br>StartupWMClass=Google-chrome<br>Exec=/usr/bin/google-chrome-stable --incognito<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Manjaro</tag>
      
      <tag>Desktop Entry</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Manjaro/Linux使用常见问题</title>
    <link href="/2024/01/31/Manjaro%E4%BD%BF%E7%94%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2024/01/31/Manjaro%E4%BD%BF%E7%94%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="一-双系统时区问题"><a href="#一-双系统时区问题" class="headerlink" title="一.双系统时区问题"></a>一.双系统时区问题</h1><h2 id="1-1-问题描述"><a href="#1-1-问题描述" class="headerlink" title="1.1 问题描述"></a>1.1 问题描述</h2><p>当安装了 Windows 和 Manjaro 双系统后，发现出现了 Windows 系统时间比 Manjaro 系统时间慢 8 小时的情况。</p><h2 id="1-2-问题分析"><a href="#1-2-问题分析" class="headerlink" title="1.2 问题分析"></a>1.2 问题分析</h2><p>在电脑中会有两个时间，一个是硬件时间，一个是系统时间。</p><ol><li>硬件时间：这个时间信息存储在电脑主板中，因此没有夏令时以及时区等概念。</li><li>系统时间：这个时间信息由系统管理，通常是通过网络时间同步（Network Time Synchronization，NTS），有夏令时以及时区等概念。</li></ol><blockquote><p><strong>注</strong>：</p><p>系统时间提供了两种管理思路：</p><ul><li>localtime：本地时间，Windows 系统采用此种方法。</li><li>UTC：世界标准时间，在众多 Linux 系统中广泛使用。这种方法只需将 UTC 时间加减时区便得到本地时间。</li></ul></blockquote><p>Linux 认为硬件时间是 UTC 标准时间，Linux 时间同步后会把“正确”的时间做减 8 操作作为标准 UTC 标准时间写入主板。</p><p>Windows 系统会认为硬件时间就是本地时间，所以直接把主板中的时间信息拿来当做当前的时间。设置或同步时间后也会把“正确”时间写入主板。</p><p>这样操作就会出现双系统时间不同步的情况。</p><h2 id="1-3-解决方法"><a href="#1-3-解决方法" class="headerlink" title="1.3 解决方法"></a>1.3 解决方法</h2><p>解决的思路就是让 Manjaro 系统使用 localtime 或者让 Windows 系统使用 UTC 时间。具体操作是：</p><ol><li>在 Manjaro 系统中设置本地时间</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">使用timedatectl可以查询时间信息，通过如下方式设置 Manjaro 本地时间</span><br>sudo timedatectl set-local-rtc true<br></code></pre></td></tr></table></figure><ol start="2"><li>在 Windows 系统中使用 UTC 时间</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">以管理员身份使用运行</span><br>reg add &quot;HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\TimeZoneInformation&quot; /v RealTimeIsUniversal /d 1 /t REG_DWORD /f<br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用以上方法无效或系统为64位：</span><br>reg add &quot;HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\TimeZoneInformation&quot; /v RealTimeIsUniversal /d 1 /t REG_QWORD /f<br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><p>本问题参照 ArchLinux Wiki 关于时间问题的处理：<a href="https://wiki.archlinux.org/title/System_time">ArchLinux Wiki —- Time</a></p></blockquote><h1 id="二-GitHub-443错误"><a href="#二-GitHub-443错误" class="headerlink" title="二.GitHub 443错误"></a>二.GitHub 443错误</h1><h2 id="2-1问题描述"><a href="#2-1问题描述" class="headerlink" title="2.1问题描述"></a>2.1问题描述</h2><p>当从Git远程仓库 pull、push 或者 clone 时会出现如下错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Failed to connect to github.com port 443: Connection refused<br></code></pre></td></tr></table></figure><h2 id="2-2-解决方法"><a href="#2-2-解决方法" class="headerlink" title="2.2 解决方法"></a>2.2 解决方法</h2><h3 id="2-2-1-由代理引起"><a href="#2-2-1-由代理引起" class="headerlink" title="2.2.1 由代理引起"></a>2.2.1 由代理引起</h3><ol><li>若是由于<strong>代理</strong>引起的，则使用如下命令关闭代理：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global --unset http.proxy<br>git config --global --unset https.proxy<br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><p>重新开启 git 全局代理的方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">添加全局代理：<br>git config --global http.proxy<br>git config --global https.proxy<br></code></pre></td></tr></table></figure></blockquote><h3 id="2-2-2-由-DNS-解析异常导致"><a href="#2-2-2-由-DNS-解析异常导致" class="headerlink" title="2.2.2 由 DNS 解析异常导致"></a>2.2.2 由 DNS 解析异常导致</h3><p>若是由于 <strong>DNS 解析</strong>异常导致的，则使用如下方式解决：</p><ul><li>首先在 <a href="https://www.ipaddress.com/">ipaddress.com</a> 网站搜索获取 GitHub 域名对应的 IP 地址。</li></ul><blockquote><p><strong>注</strong>：</p><ol><li>修改hosts文件,就修改了IP 地址和域名之间的映射关系。修改 hosts 文件域名解析就会访问 hosts 文件中的 IP和域名的映射关系以访问指定网站。</li><li>如果想要更加完整的 GitHub DNS 解析列表可在 Gitee 上查询相关仓库并将其更新到本地的 Hosts 文件当中。</li></ol></blockquote><ul><li>然后将 IP 地址和域名的映射关系写入系统的 hosts 文件中。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在 Windows 系统中修改如下路径的 hosts 文件</span><br>C:\Windows\System32\drivers\etc\hosts<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在 Linux 系统中修改 hosts 文件</span><br>sudo vim /etc/hosts<br></code></pre></td></tr></table></figure><h1 id="三-签名更新出错"><a href="#三-签名更新出错" class="headerlink" title="三.签名更新出错"></a>三.签名更新出错</h1><h2 id="3-1-问题描述"><a href="#3-1-问题描述" class="headerlink" title="3.1 问题描述"></a>3.1 问题描述</h2><p> 当 Manjaro 更新系统时，会出现如下签名失败的情况并导致软件更新失败</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">错误：archlinux-keyring: 来自 &quot;Christian Hesse &lt;eworm@archlinux.org&gt;&quot; 的签名是未知信任的<br>:: 文件 /var/cache/pacman/pkg/archlinux-keyring-20221220-1-any.pkg.tar.zst 已损坏 (无效或已损坏的软件包 (PGP 签名)).<br>打算删除吗？ [Y/n]<br></code></pre></td></tr></table></figure><h2 id="3-2-解决方法"><a href="#3-2-解决方法" class="headerlink" title="3.2 解决方法"></a>3.2 解决方法</h2><p>这儿可能会有两种情况出现</p><ol><li>第一种原因呢，是 <code>archlinux-keyring</code> 滚不动了。根本原因呢就是升级到了 <code>gnupg-2.1</code>，pacman 上游更新了密钥环的格式，这使得本地的主密钥无法签署其它密钥。。解决的思路是初始化 keyring 亦或者是将其更换为 <code>archlinuxcn-keyring</code>。本节参考的如下链接：<a href="https://www.archlinuxcn.org/gnupg-2-1-and-the-pacman-keyring/">GnuPG-2.1 与 pacman 密钥环</a></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1,移除旧的 keys</span><br>sudo rm -rf /etc/pacman.d/gnupg<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2,初始化 pacman 的keys</span><br>sudo pacman-key --init<br><span class="hljs-meta prompt_"># </span><span class="language-bash">3,加载签名的keys</span><br>sudo pacman-key --populate<br><span class="hljs-meta prompt_"># </span><span class="language-bash">4,刷新升级已经签名的keys,这一步可以选择跳过</span><br>sudo pacman-key --refresh-keys<br><span class="hljs-meta prompt_"># </span><span class="language-bash">5,清空并且下载新数据</span><br>sudo pacman -Sc<br><span class="hljs-meta prompt_"># </span><span class="language-bash">6,安装archlinuxcn-keyring</span><br>sudo pacman -S archlinuxcn-keyring<br></code></pre></td></tr></table></figure><p>然后再更新系统和软件，发现问题解决。</p><ol start="2"><li>第二种情况呢，是 archlinuxcn 社区源的 keyring 包 archlinuxcn-keyring 由 <code>farseerfc</code> 的 key 签署验证，而 Arch Linux 官方 keyring 中包含了 <code>farseerfc</code> 的 key 。解决思路呢就是使用如下命令在本地信任 <code>farseerfc</code> 的 key。本节参照的如下链接：<a href="https://www.archlinuxcn.org/archlinuxcn-keyring-manually-trust-farseerfc-key/">手动信任 farseerfc 的 key</a></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">此 key 已随 archlinux-keyring 安装在系统中，只是缺乏信任</span><br>sudo pacman-key --lsign-key &quot;farseerfc@archlinux.org&quot;<br></code></pre></td></tr></table></figure><p>然后再更新系统和软件，发现问题解决。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Manjaro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Manjaro的软件安装方式</title>
    <link href="/2024/01/31/Manjaro%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F/"/>
    <url>/2024/01/31/Manjaro%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Linux 系统有着众多特点，而灵活性便是其中之一。而这一灵活性的具体体现就是软件的安装是可以通过多种方法途径来实现的。因此，掌握多种 Linux 系统上软件安装方法便是一个开发者以及爱好者的必备技能。本文以下部分将阐述笔者所了解掌握的几种 Linux 系统安装软件的方法。当然，这几种方法主要是 Arch 系发行版的 Linux 系统。</p><h1 id="一-通过-pacman-命令安装"><a href="#一-通过-pacman-命令安装" class="headerlink" title="一.通过 pacman 命令安装"></a>一.通过 pacman 命令安装</h1><p><code>pacman</code> 软件包管理器是 Arch Linux 的一大亮点。它将一个简单的 <code>二进制包格式</code>和易用的 <code>构建系统</code> 结合了起来。<code>pacman</code> 的目标是简化对软件包的管理，无论软件包是来自 <code>官方软件仓库</code> 还是 <code>用户自己创建</code>的软件包。</p><p>关于 <code>pacman</code> 命令的部分用法将在下面几节详细介绍。如果想查看更加完整的技术文档，可参考：<a href="https://man.archlinux.org/man/pacman.8">ArchWiki—Pacman（英文完整版）</a>  ， <a href="https://wiki.archlinuxcn.org/wiki/Pacman#%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%8C%85">ArchWiki—Pacman（中文）</a>。</p><blockquote><p><strong>注</strong>：</p><p>pacman 软件包管理器拥有很强的管理能力。使用软件包而不是自己编译和安装程序有很多好处：</p><ul><li>轻松升级：pacman 会在更新可用时立即更新已安装的软件包</li><li>依赖检查：pacman 会为你处理依赖问题，只需要指明程序（名），<em>pacman</em> 就会将它和它所需的所有其他程序都一起安装。</li><li>干净卸载：pacman 持有软件包包含的所有文件的列表。这样一来，当你决定移除软件包时，不会无意留下任何文件。</li></ul></blockquote><h2 id="1-1-安装软件包"><a href="#1-1-安装软件包" class="headerlink" title="1.1 安装软件包"></a>1.1 安装软件包</h2><p>一个软件包就是一个归档包，其中包含：</p><ul><li>该软件所有（编译好的）文件，并按照每个文件的安装位置储存在一个与根目录结构相同的目录中；</li><li>该软件的元数据，如软件名称、版本和依赖等；</li><li>供 pacman 使用的其它描述性文件；</li><li>（可选）在安装、升级、卸载时执行的安装脚本。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载软件包但不安装</span><br>pacman -Sw &lt;包名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装「单个」或者「一系列」软件包（含依赖）</span><br>pacman -S &lt;包名&gt;# 安装单个软件包<br>pacman -S &lt;包名1 包名2 ...&gt; # 安装一系列软件包<br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过正则表达式安装「一系列」软件包</span><br>pacman -S $(pacman -Ssq 包正则表达式)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">存放在不同仓库的多版本软件需要在软件包前指定仓库名</span><br>pacman -S &lt;仓库名/包名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装多个相似名称的软件包，用花括号扩展，举例：</span><br>pacman -S plasma-&#123;desktop,mediacenter,nm&#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">多个相似名称的软件包可以多层扩展，举例：</span><br>pacman -S plasma-&#123;workspace&#123;,-wallpapers&#125;,pa&#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装包组，会提示选择安装包组中需要安装的包</span><br>pacman -S &lt;包组名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询安包组内的包含的具体软件名</span><br>pacman -Sg &lt;包组名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从本地安装软件包（不从源中获取）</span><br>pacman -U /path/to/package/package_name-version.pkg.tar.zst<br><span class="hljs-meta prompt_"># </span><span class="language-bash">从远程安装软件包（从源或者指定链接中获取）</span><br>pacman -U http://www.example.com/repo/example.pkg.tar.zst<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将本地包保存至缓存</span><br>pacman -U file:///path/to/package/package_name-version.pkg.tar.zst<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><h2 id="1-2-删除软件包"><a href="#1-2-删除软件包" class="headerlink" title="1.2 删除软件包"></a>1.2 删除软件包</h2><p><code>pacman</code> 命令的删除指令如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除单个软件包</span><br>pacman -R &lt;包名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除指定软件包，并删除未被其他已安装软件包使用的依赖</span><br>pacman -Rs &lt;包名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-Rs命令在移除包含其他所需包的组时有时候会拒绝运行，可采用如下指令</span><br>pacman -Rsu &lt;包名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除软件包和依赖这个软件包的所有程序，「递归操作，谨慎使用」</span><br>pacman -Rsc &lt;包名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除被其他软件包依赖的软件包，但是不删除依赖这个软件包的其他软件包：</span><br>pacman -Rdd &lt;包名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><h2 id="1-3-查询包数据库"><a href="#1-3-查询包数据库" class="headerlink" title="1.3 查询包数据库"></a>1.3 查询包数据库</h2><p>在 <code>pacman</code> 中，可使用 <code>-Q</code> 参数查询本地软件包数据库， <code>-S</code> 查询同步数据库，以及 <code>-F</code>查询文件数据库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示软件包的依赖树，「这一命令依赖于 pacman-contrib 包」</span><br>pactree &lt;package_name&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br>pacman -Q --help#本地软件包数据库的帮助文档<br>pacman -S --help#同步数据库的帮助文档<br>pacman -F --help#文件数据库的帮助文档<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1.本地软件包数据库</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在本地软件包数据库中查询匹配「单个」或者「多个」字符串的软件包</span><br>pacman -Qs &lt;string&gt; # 匹配单个字符串<br>pacman -Qs &lt;string1 string2 ...&gt;# 匹配多个字符串<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在本地软件包数据库中查询指定软件包的详细信息</span><br>pacman -Qi &lt;package_name&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在本地软件包数据库中查询指定软件包所包含文件的列表</span><br>pacman -Ql &lt;package_name&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.同步数据库</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在同步数据库中查询匹配「单个」或者「多个」字符串的软件包</span><br>pacman -Ss &lt;string&gt; # 匹配单个字符串<br>pacman -Ss &lt;string1 string2 ...&gt;# 匹配多个字符串<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在同步数据库中获取指定软件的详细信息</span><br>pacman -Si &lt;package_name&gt;       <br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3.文件数据库</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在文件数据库中按文件名查找「单个」或者「一系列」文件</span><br>pacman -F &lt;string&gt; # 单个文件<br>pacman -F &lt;string1 string2 ...&gt;# 一系列文件<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询远程库中软件包包含的文件</span><br>pacman -Fl &lt;package_name&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><h2 id="1-4-清除包缓存"><a href="#1-4-清除包缓存" class="headerlink" title="1.4 清除包缓存"></a>1.4 清除包缓存</h2><p><code>pacman</code> 命令下载的软件包保存在 <code>/var/cache/pacman/pkg/</code> 路径中，并且它不会自动移除旧的和未安装版本的软件包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启用 和 启动 paccache.timer 每周删除不使用的包</span><br>paccache -r<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置保留最近几个版本的软件数量</span><br>paccache -rk1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除目前没有安装的所有缓存的包，和没有被使用的同步数据库</span><br>pacman -Sc<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除缓存中的全部文件（两个c强制删除）</span><br>pacman -Scc<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><h2 id="1-5-其他命令"><a href="#1-5-其他命令" class="headerlink" title="1.5 其他命令"></a>1.5 其他命令</h2><p>除了上面几节介绍的命令之外，还有一些 <code>pacman</code> 相关的零碎指令如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">升级整个系统，y 是更新数据库，yy 是强制更新数据库，u 是升级软件</span><br>pacman -Syyu<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">升级系统时安装「单个」或者「一系列」软件包</span><br>pacman -Syu &lt;包名&gt;#「单个」软件包<br>pacman -Syu &lt;包名1 包名2 ...&gt; #「一系列」软件包<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><h1 id="二-通过-yay-命令安装"><a href="#二-通过-yay-命令安装" class="headerlink" title="二.通过 yay 命令安装"></a>二.通过 yay 命令安装</h1><p>yay 命令是一个 Arch Linux 系统的命令行软件。在使用此命令安装软件时需要确保在 <code>/etc/pacman.conf</code> 文件中正确配置了 Arch 源。yay 是 AUR 助手的其中一种，与其他的 AUR 助手的对比可以参考：<a href="https://wiki.archlinuxcn.org/wiki/AUR_%E5%8A%A9%E6%89%8B">ArchWiki—AUR 助手</a></p><p>使用 yay 这类 AUR 助手的好处是：</p><ol><li>自动解决软件<strong>包间依赖关系</strong>；</li><li>动态地<strong>搜索</strong>、<strong>编译</strong>和<strong>构建</strong>包；</li><li>安装与管理 AUR 中的包。</li></ol><blockquote><p><strong>注</strong>：</p><ol><li>要想使用 yay 命令行软件，需要确保安装了 <code>base-devel</code> 包和 <code>git</code> 包，然后再安装 yay 命令。如果没有安装，可参考如下命令安装：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">加入 `--needed` 参数不会重新安装已经安装的软件包</span><br>sudo pacman -S --needed base-devel git<br></code></pre></td></tr></table></figure><ol start="2"><li>值得注意的是， <code>yay</code> 命令可以从 AUR 上获取软件并安装，也可以从官方源获取软件包再安装。</li></ol></blockquote><p><code>yay</code> 使用与 <code>pacman</code> 相类似的命令结构。因此本节下面部分将展示 yay 的部分指令用法，更加详细的可参阅：<a href="https://wiki.archlinuxcn.org/wiki/Yay">ArchWiki—Yay</a>。</p><h2 id="2-1-安装软件包"><a href="#2-1-安装软件包" class="headerlink" title="2.1 安装软件包"></a>2.1 安装软件包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在 AUR 上搜索包名</span><br>yay &lt;AUR包名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载软件包但不安装</span><br>yay -G &lt;AUR包名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装「单个」或者「一系列」软件包（含依赖）</span><br>yay -S &lt;AUR包名&gt;       # 安装单个软件包<br>yay -S &lt;AUR包名1 AUR包名2 ...&gt;# 安装一系列软件包<br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过正则表达式安装「一系列」软件包</span><br>yay -S $(pacman -Ssq AUR包正则表达式)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">存放在不同仓库的多版本软件需要在软件包前指定仓库名</span><br>yay -S &lt;仓库名/AUR包名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装包组，会提示选择安装包组中需要安装的包</span><br>yay -S &lt;包组名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询安装包组内包含的具体软件名</span><br>yay -Sg &lt;包组名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><h2 id="2-2-删除软件包"><a href="#2-2-删除软件包" class="headerlink" title="2.2 删除软件包"></a>2.2 删除软件包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除软件包</span><br>yay -R &lt;AUR包名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除指定软件包，并删除未被其他已安装软件包使用的依赖</span><br>yay -Rs &lt;AUR包名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-Rs命令在移除包含其他所需包的组时有时候会拒绝运行，可采用如下指令</span><br>yay -Rsu &lt;AUR包名&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除包及其依赖项</span><br>yay -Rns &lt;AUR包名&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除软件包和依赖这个软件包的所有程序，「递归操作，谨慎使用」</span><br>yay -Rsc &lt;AUR包名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除被其他软件包依赖的软件包，但是不删除依赖这个软件包的其他软件包：</span><br>yay -Rdd &lt;AUR包名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><h2 id="2-3-查询包数据库"><a href="#2-3-查询包数据库" class="headerlink" title="2.3 查询包数据库"></a>2.3 查询包数据库</h2><p>在 <code>yay</code> 中，可使用 <code>-Q</code> 参数查询本地软件包数据库， <code>-S</code> 查询同步数据库，以及 <code>-F</code>查询文件数据库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1.本地软件包数据库</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在本地软件包数据库中查询匹配「单个」或者「多个」字符串的软件包</span><br>yay -Qs &lt;string&gt;        # 匹配单个字符串<br>yay -Qs &lt;string1 string2 ...&gt;# 匹配多个字符串<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在本地软件包数据库中查询指定软件包的详细信息</span><br>yay -Qi &lt;package_name&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在本地软件包数据库中查询指定软件包所包含文件的列表</span><br>yay -Ql &lt;package_name&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.同步数据库</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在同步数据库中查询匹配「单个」或者「多个」字符串的软件包</span><br>yay -Ss &lt;string&gt; # 匹配单个字符串<br>yay -Ss &lt;string1 string2 ...&gt;# 匹配多个字符串<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在同步数据库中获取指定软件的详细信息</span><br>yay -Si &lt;package_name&gt;       <br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3.文件数据库</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在文件数据库中按文件名查找「单个」或者「一系列」文件</span><br>yay -F &lt;string&gt; # 单个文件<br>yay -F &lt;string1 string2 ...&gt;# 一系列文件<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询远程库中软件包包含的文件</span><br>yay -Fl &lt;package_name&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><h2 id="2-4-清除包缓存"><a href="#2-4-清除包缓存" class="headerlink" title="2.4 清除包缓存"></a>2.4 清除包缓存</h2><p><code>yay</code> 常用的清除缓存指令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除目前没有安装的所有缓存的包，和没有被使用的同步数据库</span><br>yay -Sc<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除缓存中的全部文件（两个c强制删除）</span><br>yay -Scc<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><h2 id="2-5-其他命令"><a href="#2-5-其他命令" class="headerlink" title="2.5 其他命令"></a>2.5 其他命令</h2><p>除了上面几节介绍的命令之外，还有一些 <code>yay</code> 相关的零碎指令如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">其他命令</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">升级整个系统，y 是更新数据库，yy 是强制更新数据库，u 是升级软件</span><br>yay -Syyu# 仅输入 yay 则等效于 yay -Syu<br><span class="hljs-meta prompt_"># </span><span class="language-bash">仅升级 AUR 包</span><br>yay -Sua<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><h2 id="2-6-常用指令汇总"><a href="#2-6-常用指令汇总" class="headerlink" title="2.6 常用指令汇总"></a>2.6 常用指令汇总</h2><p>更加详细的指令信息如下图所示：</p><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">yay</td><td align="center">升级系统，相当于 yay -Syu</td></tr><tr><td align="center">yay <Search Term></td><td align="center">显示包安装选择菜单</td></tr><tr><td align="center">yay -Bi <folder></td><td align="center">安装依赖并构建本地 PKGBUILD</td></tr><tr><td align="center">yay -G <AUR Package></td><td align="center">从 ABS 或 AUR 下载 PKGBUILD (yay v12.0以上版本)</td></tr><tr><td align="center">yay -Gp <AUR Package></td><td align="center">打印 ABS 或 AUR 的 PKGBUILD 到 stdout</td></tr><tr><td align="center">yay -Ps</td><td align="center">打印系统统计信息</td></tr><tr><td align="center">yay -Syu –devel</td><td align="center">执行系统升级，但同时检查开发包的更新</td></tr><tr><td align="center">yay -Syu –timeupdate</td><td align="center">执行系统升级并使用PKGBUILD修改时间（不是版本号）来确定更新</td></tr><tr><td align="center">yay -Wu <AUR Package Name></td><td align="center">取消对包的投票 (需要设置 AUR_USERNAME 和 AUR_PASSWORD 环境变量) (yay v11.3以上版本)</td></tr><tr><td align="center">yay -Wv <AUR Package Name></td><td align="center">投票支持包 (需要设置 AUR_USERNAME 和 AUR_PASSWORD 环境变量) (yay v11.3以上版本)</td></tr><tr><td align="center">yay -Y –combinedupgrade –save</td><td align="center">使组合升级成为默认模式</td></tr><tr><td align="center">yay -Y –gendb</td><td align="center">生成用于开发更新的开发包数据库</td></tr><tr><td align="center">yay -Yc</td><td align="center">清理不需要的依赖</td></tr></tbody></table><blockquote><p><strong>注</strong>：</p><p>如果方便，也可在命令行中键入 <code>yay --help</code> 或者是 <code>yay -h</code> 指令查看 yay 命令的用法。</p></blockquote><h1 id="三-通过-AUR-安装"><a href="#三-通过-AUR-安装" class="headerlink" title="三.通过 AUR 安装"></a>三.通过 AUR 安装</h1><p>AUR 全称 Archlinux User-community Repository，即 Archlinux 用户社区的软件库。具体的介绍可以参考：<a href="https://wiki.archlinuxcn.org/wiki/Arch_%E7%94%A8%E6%88%B7%E8%BD%AF%E4%BB%B6%E4%BB%93%E5%BA%93_(AUR)">ArchWiki—AUR</a> 。AUR 是为用户而建，并由用户主导的 Arch 软件仓库。AUR 中的软件包以软件包生成脚本（PKGBUILD）的形式提供，用户自己通过 makepkg 生成软件包，再由 pacman 安装软件包。</p><p>Archlinux 的灵魂是 PKGBUILD、 <a href="https://wiki.archlinuxcn.org/wiki/Arch_%E7%94%A8%E6%88%B7%E8%BD%AF%E4%BB%B6%E4%BB%93%E5%BA%93_(AUR)">AUR</a>  和 <a href="https://wiki.archlinuxcn.org/wiki/Arch_%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F">ABS</a>  ，在 AUR 仓库能查到的软件包，都可以使用上述的方法进行安装。为了演示这一方法的可行性，这里以 <code>WingIDE</code> 软件的安装为例演示安装流程：</p><ol><li>首先，去到 <a href="https://aur.archlinux.org/">AUR</a> 官方网站并在 <code>Package Search</code> 栏目搜索软件包（WingIDE）</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/3.1AUR%E5%AE%98%E7%BD%91.png" alt="AUR官方网站"  /></div><ol start="2"><li>搜索软件包会跳转到搜索结果页，在这一页面可能会有许多相关的软件，选择自己需要的软件点击查看详情即可</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/3.2.%E5%9C%A8AUR%E4%B8%AD%E6%90%9C%E7%B4%A2%E8%BD%AF%E4%BB%B6%E5%8C%85.png" alt="在AUR中搜索软件包"  /></div><ol start="3"><li>进入软件详情页会有许多具体信息，通过 AUR 社区安装软件需要复制对应软件的 <code>Git Clone URL</code></li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/3.3.AUR%E6%A3%80%E7%B4%A2%E8%BD%AF%E4%BB%B6%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF.png" alt="检索软件包详细信息"  /></div><ol start="4"><li>获取到软件的 <code>Git Clone URL</code> 后在终端中输入 <code>git clone &lt;Git Clone URL&gt;</code> 将软件包克隆至本地</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/3.4.%E5%88%A9%E7%94%A8git%E5%85%8B%E9%9A%86%E8%87%B3%E6%9C%AC%E5%9C%B0.png" alt="git克隆软件包"  /></div><ol start="5"><li>紧接着，进入到克隆下来的软件包文件夹，使用 <code>makepkg -s</code> 指令构建软件包</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/3.5.%E6%9E%84%E5%BB%BA%E8%BD%AF%E4%BB%B6%E5%8C%85.png" alt="构建软件包"  /></div><ol start="6"><li>最后通过 <code>pacman</code> 命令的本地安装功能进行文件夹中的 <code>.pkg.tar.zst</code> 软件包安装</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/3.6.%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85.png" alt="本地安装"  /></div><p>至此，通过 AUR 安装软件的介绍到此结束。</p><blockquote><p><strong>注</strong>：</p><ol><li>如果仅使用 <code>makepkg</code> 指令，可能会因为依赖包问题而报错，因此最好是使用 <code>makepkg -s</code>。</li><li>使用 <code>makepkg -s</code>命令会构建好软件包，但是安装还需要调用 <code>pacman -U &lt;Packge Name&gt;</code> 指令进行本地安装，因此可以换做 <code>makepkg -si</code> 指令在构建完后自动安装软件包。</li></ol></blockquote><h1 id="四-通过转换-deb-包安装"><a href="#四-通过转换-deb-包安装" class="headerlink" title="四.通过转换 deb 包安装"></a>四.通过转换 deb 包安装</h1><p>AUR 上储备了相当数量的软件，在上面能获取到日常使用的大部分软件。它虽然很好用了，但是一些无法编译的包（闭源代码软件包），或是在 AUR 上生成报错的软件包则还是需要另外的途径编译构建新的包。此时便可以通过本文所述的这一粗糙的方法将 deb 包转换成 archlinux 包。</p><h2 id="4-1-debtap-软件部署"><a href="#4-1-debtap-软件部署" class="headerlink" title="4.1 debtap 软件部署"></a>4.1 debtap 软件部署</h2><h3 id="4-1-1-安装-debtap"><a href="#4-1-1-安装-debtap" class="headerlink" title="4.1.1 安装 debtap"></a>4.1.1 安装 debtap</h3><ol><li>想要在 Manjaro 系统上转换 deb 格式的包，需要的就是先安装 debtap 软件。可使用如下命令安装 debtap 软件：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S debtap<br></code></pre></td></tr></table></figure><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/4.1.%E5%AE%89%E8%A3%85debtap%E8%BD%AF%E4%BB%B6%EF%BC%88%E5%BC%80%E5%A7%8B%EF%BC%89.png" alt="安装debtap"  /></div><ol start="2"><li>在安装完 debtap 软件之后，这里相当建议更新一次 debtap 的源以创建或者更新 pkgfile 和 debtap 数据库。这里可以通过如下命令更新 debtap 的源：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo debtap -u<br></code></pre></td></tr></table></figure><p>示例结果如下图所示：</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/4.2.%E6%9B%B4%E6%96%B0debtap%E6%BA%90.png" alt="更新debtap源"  /></div><blockquote><p><strong>注</strong>：</p><p>这条指令在安装完 debtap 软件之后至少需要运行一次，否则调用 debtap 软件时可能会报错。</p></blockquote><h3 id="4-1-2-debtap-换源"><a href="#4-1-2-debtap-换源" class="headerlink" title="4.1.2 debtap 换源"></a>4.1.2 debtap 换源</h3><p>值得注意的是 debtap 默认的官方源在大陆地区访问很卡，因此需要给 debtap 更换本地的镜像源。换源的方式也很简单，那就是修改 <code> /usr/bin/debtap</code> 配置文件。修改配置文件可以通过如下两种方式进行：</p><ol><li>一种是利用 vim 命令访问该配置文件，然后更改文件中的这两项内容：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim /usr/bin/debtap<br><span class="hljs-meta prompt_"># </span><span class="language-bash">替换 http://ftp.debian.org/debian/dists 为 https://mirrors.ustc.edu.cn/debian/dists</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">替换 http://archive.ubuntu.com/ubuntu/dists 为 https://mirrors.ustc.edu.cn/ubuntu/dists/</span><br></code></pre></td></tr></table></figure><ol start="2"><li>另外一种便更加简单粗暴，就是在命令行中直接将指定信息写入该配置文件。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo sed -i &quot;s|http://ftp.debian.org/debian/dists|https://mirrors.ustc.edu.cn/debian/dists|g&quot; /usr/bin/debtap<br>sudo sed -i &quot;s|http://archive.ubuntu.com/ubuntu/dists|https://mirrors.ustc.edu.cn/ubuntu/dists|g&quot; /usr/bin/debtap<br></code></pre></td></tr></table></figure><h2 id="4-2-安装-deb-包格式的软件"><a href="#4-2-安装-deb-包格式的软件" class="headerlink" title="4.2 安装 deb 包格式的软件"></a>4.2 安装 deb 包格式的软件</h2><p>在如下的示例中笔者都以 Typora 软件安装参考。debtap 命令的使用很简单</p><h3 id="4-2-1-转换格式"><a href="#4-2-1-转换格式" class="headerlink" title="4.2.1 转换格式"></a>4.2.1 转换格式</h3><p>直接对下载的 deb 软件包使用 debtap 命令即可转换包格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">debtap &lt;Deb Package Name&gt;<br></code></pre></td></tr></table></figure><p>转换包格式的参考示例执行结果如下图所示：</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/4.3.%E8%BD%AC%E6%8D%A2Typora%E8%BD%AF%E4%BB%B6%E7%9A%84deb%E5%8C%85%E6%A0%BC%E5%BC%8F.png" alt="deb包格式转换"  /></div><p>在图中可以看到笔者有多个版本的 Typora 软件，这里转换格式的是 <code>1.8.9</code> 版本的 Typora 软件。同时上图也展示出出了转换后软件包格式类型为： <code>.pkg.tar.zst</code>。</p><blockquote><p><strong>注</strong>：</p><ol><li>在包转化的过程中，你不想回答任何问题，使用 <code>-q</code> 略过除了编辑元数据之外的所有问题。当然，也可使用 <code>-Q</code> 略过所有问题。命令的格式如下所示：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">略过除了编辑元数据之外的所有问题</span><br>debtap -q &lt;Deb Package Name&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">略过所有问题</span><br>debtap -Q &lt;Deb Package Name&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li>如果想要查看 debtap 的帮助文档，可执行如下命令获取：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">debtap -h<br></code></pre></td></tr></table></figure><p>运行的参考示例如下图所示：</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/4.4.%E6%9F%A5%E7%9C%8Bdebtap%E5%91%BD%E4%BB%A4%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3.png" alt="查看debtap的帮助文档"  /></div></blockquote><h3 id="4-2-2-本地安装"><a href="#4-2-2-本地安装" class="headerlink" title="4.2.2 本地安装"></a>4.2.2 本地安装</h3><p>将 deb 包转换成 ArchLinux 系统格式的软件包后便可以本地安装了。可以通过如下命令安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -U &lt;Packge Name&gt;<br></code></pre></td></tr></table></figure><p>安装软件的参考示例执行结果如下图所示：</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/4.5.%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8C%85.png" alt="本地安装软件包"  /></div><p>笔者之前已经安装过 Typora 软件，因此看到上面提示重新安装。至此，已成功本地安装转换后的软件包。</p><h1 id="五-通过-AppImage-包安装"><a href="#五-通过-AppImage-包安装" class="headerlink" title="五.通过 AppImage 包安装"></a>五.通过 AppImage 包安装</h1><p>这种方式是在打包程序时就将所需的库以及依赖通过打包到 AppImage 文件中再发布，此种方式的好处是这种安装包可以在任意发行版 Linux 系统中运行而无需另外安装应用。更具体内容可参照 <a href="https://appimage.org/">AppImage官网</a> 描述。</p><h2 id="5-1-技术特点"><a href="#5-1-技术特点" class="headerlink" title="5.1 技术特点"></a>5.1 技术特点</h2><ol><li><strong>简单</strong>：AppImage 核心思想即：<code>一个文件就是一个应用程序</code>，就是说每个 AppImage 文件都包含应用程序以及应用程序运行所需的所有文件。换言之，除了操作系统本身的基础组件，Appimage不需要依赖包即可运行</li><li><strong>可靠</strong>：AppImage 格式是<code>上游应用打包</code>的理想选择，这意味着可以直接从开发者那里获取软件，而不需要任何中间步骤。</li><li><strong>快速</strong>：AppImage应用可以直接下载并且运行，无需安装，并且不需要root权限。</li></ol><h2 id="5-2-命令行实现"><a href="#5-2-命令行实现" class="headerlink" title="5.2 命令行实现"></a>5.2 命令行实现</h2><p>运行 AppImage 文件非常简单，下载后，通过以下步骤即可运行程序：</p><ol><li>下载需要的 AppImage 软件到运行文件夹，例如：<code>/path/to/AppImage</code></li><li>打开当前发行版 Linux 系统终端（Terminal）</li><li>进入 AppImage 文件所在目录，例如：<code>cd /path/to/AppImage</code></li><li>给需要运行的 AppImage 文件赋予相应的权限，例如：<code>sudo chmod a+x my.AppImage</code></li><li>这样便可以运行 AppImage 软件了，例如：<code>./my.AppImage</code></li></ol><p>这里在代码行中做个汇总：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入文件目录</span><br>cd /path/to/AppImage<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看目录中文件</span><br>ls -l     <br><span class="hljs-meta prompt_"># </span><span class="language-bash">更改文件权限</span><br>sudo chmod a+x my.AppImage<br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行程序</span><br>./my.AppImage<br></code></pre></td></tr></table></figure><p>笔者在本人系统中运行如下图所示：</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/5.1.%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8CAppImage%E7%A8%8B%E5%BA%8F.png" alt="命令行安装AppImage软件"  /></div><h2 id="5-2-沙盒实现"><a href="#5-2-沙盒实现" class="headerlink" title="5.2 沙盒实现"></a>5.2 沙盒实现</h2><p>通过命令行操作可能很繁琐，那么可以通过诸如 AppImageLauncher 的沙盒程序来整合 AppImage 程序。下面将阐述利用沙盒程序整合 AppImage 文件的步骤：</p><ol><li>首先在当前发行版 Linux 系统中安装沙盒程序，笔者使用的是 AppImageLauncher 程序。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S AppImageLauncher<br></code></pre></td></tr></table></figure><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/5.2.%E5%AE%89%E8%A3%85AppImageLauncher%E8%BD%AF%E4%BB%B6.png" alt="沙盒软件安装AppImage软件"  /></div><ol start="2"><li>然后下载需要运行的 AppImage 文件。</li><li>通过文件资源管理器进入 AppImage 所在目录，然后点击运行该 AppImage 文件。</li></ol><div style="text-align: center; margin: 35px;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/5.3.%E5%8F%8C%E5%87%BB%E6%89%A7%E8%A1%8CAppImage%E8%BD%AF%E4%BB%B6.png" alt="双击安装AppImage软件"  /></div><p>至此，AppImageLauncher 就将 AppImage 文件整合到对应的目录统一管理。并且在整合的过程中在开始菜单自动生成了访问图标。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Manjaro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Manjaro及其常用软件安装配置</title>
    <link href="/2024/01/29/Manjaro%E5%8F%8A%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <url>/2024/01/29/Manjaro%E5%8F%8A%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Manjaro 是一个 Arch Linux 的发行版本</p><p>来自 Manjaro 社区的官方介绍：</p><p>Manjaro is a versatile, free, and open-source Linux operating system designed with a strong focus on safeguarding user privacy and offering extensive control over hardware. This user-friendly OS is an excellent choice for those who seek a fresh computing experience, as it can be seamlessly installed on a diverse array of devices. With support for both x86-64 and ARM architectures, Manjaro stands as an ideal option for any device or computing environment. Furthermore, Manjaro provides an array of customization options and a rich selection of applications, all while prioritizing security and privacy features. To cater to a wide audience.</p><h1 id="一-Manjaro安装"><a href="#一-Manjaro安装" class="headerlink" title="一.Manjaro安装"></a>一.Manjaro安装</h1><h2 id="1-1-安装包及工具获取"><a href="#1-1-安装包及工具获取" class="headerlink" title="1.1 安装包及工具获取"></a>1.1 安装包及工具获取</h2><h3 id="1-1-1-安装包获取"><a href="#1-1-1-安装包获取" class="headerlink" title="1.1.1 安装包获取"></a>1.1.1 安装包获取</h3><p>访问<a href="https://manjaro.org/">Manjaro官网</a>的下载页可以看到，Manjaro 官方提供了三种桌面版本的 Manjaro 系统：Plasma、Xfce以及 GNOME。</p><ol><li>Plasma：是一种 KDE 桌面环境，其功能完善，自定义程度较高。对于硬件资源消耗较大</li><li>Xfce：是一种轻量级的桌面环境，其界面美观、对用户友好，它是由 C 语言编写而成，依赖于 GTK+。对资源消耗较小</li><li>GNOME：是一款GNU的桌面环境，Ubuntu 系统的默认桌面环境。对于资源消耗适中。</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5/Manjaro%E4%B8%8B%E8%BD%BD%E9%A1%B5.png" alt="Manjaro下载页"  /></div><p>笔者曾使用 Ubuntu 系统，比较喜欢GNOME的桌面环境，因此笔者选择 GNOME Desktop 版本。</p><h3 id="1-1-2-写入工具选择"><a href="#1-1-2-写入工具选择" class="headerlink" title="1.1.2 写入工具选择"></a>1.1.2 写入工具选择</h3><p>当前市面上有许多U盘烧录工具，如Rufus、USBWriter、Ventoy等。</p><h2 id="1-2-写入盘制作"><a href="#1-2-写入盘制作" class="headerlink" title="1.2 写入盘制作"></a>1.2 写入盘制作</h2><p>笔者采用 Rufus 软件写入文件到U盘。打开 Rufus 软件之后默认会选择U盘，然后在引导类型选择栏选择需要安装的 Manjaro 镜像文件。然后点击开始按钮进行烧录。</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5/Rusfus%E5%86%99%E5%85%A5%E8%BD%AF%E4%BB%B6.png" alt="Rufus写入软件"  /></div><h2 id="1-3-安装步骤"><a href="#1-3-安装步骤" class="headerlink" title="1.3 安装步骤"></a>1.3 安装步骤</h2><p>将写入系统镜像的U盘插到待安装系统的电脑上。开机选择U盘启动项开始安装</p><h3 id="1-3-1-语言及驱动选择"><a href="#1-3-1-语言及驱动选择" class="headerlink" title="1.3.1 语言及驱动选择"></a>1.3.1 语言及驱动选择</h3><p>进入驱动选择界面，将地区（tz 项）选择为中国上海，语言（lang 项）设置为中文，然后驱动选择<Boot with proprietary drivers> 项并回车。</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/1.%E9%80%89%E6%8B%A9%E9%A9%B1%E5%8A%A8%E7%B1%BB%E5%9E%8B.png" alt="选择驱动类型"  /></div><blockquote><p><strong>注</strong>：</p><p>图中第一项 <Boot with open source drivers> 为开源驱动。</p><p>图中第二项 <Boot with proprietary drivers> 为闭源驱动。</p><p>由于笔者是英伟达显卡，故选择第二项进行安装。</p></blockquote><h3 id="1-3-2-载入内核与系统界面"><a href="#1-3-2-载入内核与系统界面" class="headerlink" title="1.3.2 载入内核与系统界面"></a>1.3.2 载入内核与系统界面</h3><ul><li>回车安装之后会载入内核界面</li></ul><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/2.%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8%E7%95%8C%E9%9D%A2.png" alt="载入内核界面"  /></div><ul><li>成功之后便会显示系统 Logo 界面</li></ul><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/3.%E7%B3%BB%E7%BB%9FLogo%E7%95%8C%E9%9D%A2.png" alt="系统Logo界面"  /></div><h3 id="1-3-3-系统欢迎页"><a href="#1-3-3-系统欢迎页" class="headerlink" title="1.3.3 系统欢迎页"></a>1.3.3 系统欢迎页</h3><p>进入系统欢迎页。将语言选择为 <code>简体中文</code>，然后点击启动安装程序按钮开始安装。</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/4.%E7%B3%BB%E7%BB%9F%E6%AC%A2%E8%BF%8E%E9%A1%B5.png" alt="系统欢迎页"  /></div><h3 id="1-3-4-进入系统安装页"><a href="#1-3-4-进入系统安装页" class="headerlink" title="1.3.4 进入系统安装页"></a>1.3.4 进入系统安装页</h3><p>进入系统安装页，点击下一步正式开始安装</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/5.%E8%BF%9B%E5%85%A5%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F.png" alt="进入系统安装页"  /></div><h3 id="1-3-5-地区及键盘布局"><a href="#1-3-5-地区及键盘布局" class="headerlink" title="1.3.5 地区及键盘布局"></a>1.3.5 地区及键盘布局</h3><ul><li>在系统安装页将地区设置为 <code>亚洲/上海</code>，然后点击下一步。</li></ul><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/6.%E9%80%89%E6%8B%A9%E5%9C%B0%E5%8C%BA.png" alt="地区选择"  /></div><ul><li>键盘布局选择默认布局，然后点击下一步。</li></ul><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/7.%E9%80%89%E6%8B%A9%E9%94%AE%E7%9B%98%E5%B8%83%E5%B1%80.png" alt="键盘方式选择"  /></div><h3 id="1-3-6-系统分区"><a href="#1-3-6-系统分区" class="headerlink" title="1.3.6 系统分区"></a>1.3.6 系统分区</h3><p>这一步非常关键，分区不正确将影响系统安装。此时出现两个选项，我们选择手动分区，然后点击下一步。</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/8.0.%E9%80%89%E6%8B%A9%E5%88%86%E5%8C%BA%E6%96%B9%E5%BC%8F.png" alt="分区方式选择"  /></div><p>进入到分区具体流程，笔者的分区如下表所述进行：</p><table><thead><tr><th align="center">大小</th><th align="center">文件系统</th><th align="center">挂载点</th><th align="center">标记</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">20GiB</td><td align="center">ext4</td><td align="center">&#x2F;</td><td align="center">root</td><td align="center">根目录，用于存放系统文件</td></tr><tr><td align="center">512MiB</td><td align="center">ext4</td><td align="center">&#x2F;boot</td><td align="center">boot或者bios-grub</td><td align="center">引导分区，系统启动相关</td></tr><tr><td align="center">4096MiB</td><td align="center">linuxswap</td><td align="center">无挂载点</td><td align="center">swap</td><td align="center">交换分区，一般与内存大小相同</td></tr><tr><td align="center">10Gib</td><td align="center">ext4</td><td align="center">&#x2F;var</td><td align="center">无标记</td><td align="center">存储变量</td></tr><tr><td align="center">The Rest</td><td align="center">ext4</td><td align="center">&#x2F;home</td><td align="center">无标记</td><td align="center">家目录，用于存放用户数据</td></tr></tbody></table><blockquote><p><strong>注</strong>：几个分区的具体介绍</p><ol><li>&#x2F; 分区，大小通常为15-20GiB。根分区是最重要而且必需的，需要最先挂载,因为包括 &#x2F;usr 目录，根据安装的软件数量，会产生非常明显的增长。</li><li>&#x2F;boot 分区，大小通常为512MiB。引导分区包含内核、ramdisk 镜像以及 bootloader 配置文件和bootloader stage。它也可以存放内核在执行用户态程序之前所使用的其他数据。&#x2F;boot 在日常系统运行中并不需要，只在启动和内核升级（包括重建initial ramdisk）的时候用到。如果使用软RAID0（条带化）系统的话，必须有一个独立的 &#x2F;boot 分区。不使用 UEFI 时，引导分区大小建议为 200 MiB，使用 UEFI 时，需要至少 512 MiB 空间。</li><li>linuxswap 分区，大小通常为内存的大小。</li><li>&#x2F;home 分区，将&#x2F;home目录独立使得&#x2F;分区可以单独重新划分，但是请注意你可以在 &#x2F;home 没有独立分区的情况下你仍然可以在不修改 &#x2F;home 目录内容的情况下重装 Arch —— 删除其他顶级目录，然后执行pacstrap。不能与使用其他发行版的用户共享同一个 home 目录，因为不同的发行版可能使用不兼容的软件版本和补丁。可以共享媒体目录，或至少使用 &#x2F;home 分区下的不同 home 目录。分区大小跟着存储的内容而定。</li><li>&#x2F;var 分区，存储变量数据例如 spool 目录和文件，管理和登录数据,它通常被用作缓存或者日志记录，因此读写频繁。将它独立出来可以避免由于大量日志写入造成的磁盘空间耗尽等问题。</li><li>除了其他数据以外，还包括 ABS 树和 pacman 缓存。保留缓存的包提供了包降级的能力，因此非常有用。也正因为这样，&#x2F;var 的大小会随着时间推移而增长。尤其是 pacman 缓存将会随着新软件的安装、系统的升级而增长。在磁盘空间不足的时候，可以安全的清理这个目录。&#x2F;var 分配 8-12 GB 对于桌面系统来说是比较合适的取值，具体取值取决于安装的软件数量。</li></ol></blockquote><ol><li>根目录（&#x2F;）</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/8.1.%E6%A0%B9%E5%88%86%E5%8C%BA%E9%85%8D%E7%BD%AE.png" alt="根分区配置"  /></div><ol start="2"><li>引导分区（&#x2F;boot或者&#x2F;boot&#x2F;efi）</li></ol><ul><li>当进行单系统（Manjaro）安装时，直接挂载 &#x2F;boot 引导分区</li></ul><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/8.2.boot%E5%88%86%E5%8C%BA%E9%85%8D%E7%BD%AE.png" alt="单系统安装Boot分区配置"  /></div><ul><li>当进行双系统（Windows+Manjaro）安装时，则需要将 &#x2F;boot&#x2F;efi 挂载到 Windows 的 ESP 引导分区上。注意配置 ESP 分区的时候选择保留分区而别格式化分区。</li></ul><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/%E5%88%86%E5%8C%BA%E7%9A%84%E7%89%B9%E4%BE%8B/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E6%8C%82%E8%BD%BD%E6%96%B9%E6%A1%881.png" alt="双系统安装Boot分区配置"  /></div><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/%E5%88%86%E5%8C%BA%E7%9A%84%E7%89%B9%E4%BE%8B/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E6%8C%82%E8%BD%BD%E6%96%B9%E6%A1%882.png" alt="双系统安装Boot分区配置"  /></div><blockquote><p><strong>注</strong>：</p><p>手动挂载&#x2F;boot&#x2F;efi分区的方法可以参考如下文章：<a href="https://blog.csdn.net/qq_44639125/article/details/125707257?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170654013516800213030099%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170654013516800213030099&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-125707257-null-null.142%5Ev99%5Epc_search_result_base4&utm_term=Manjaro%E5%AE%89%E8%A3%85%E5%88%86%E5%8C%BA&spm=1018.2226.3001.4187">manjaro 手动挂载&#x2F;boot&#x2F;efi分区</a></p></blockquote><ol start="3"><li>交换分区（linuxswap）</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/8.3.swap%E5%88%86%E5%8C%BA%E9%85%8D%E7%BD%AE.png" alt="交换分区配置"  /></div><ol start="4"><li>家目录（&#x2F;home）</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/8.4.home%E5%88%86%E5%8C%BA%E9%85%8D%E7%BD%AE%EF%BC%88%E5%89%A9%E4%B8%8B%E5%85%A8%E9%83%A8%EF%BC%89.png" alt="home分区配置"  /></div><ol start="5"><li>最终生成的分区方案</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/8.5.%E6%9C%80%E7%BB%88%E5%88%86%E5%8C%BA%E6%96%B9%E6%A1%88.png" alt="最终分区方案"  /></div><h3 id="1-3-7-用户名及密码设置"><a href="#1-3-7-用户名及密码设置" class="headerlink" title="1.3.7 用户名及密码设置"></a>1.3.7 用户名及密码设置</h3><p>在系统安装页的用户名界面输入自己的登录用户名并设置它对应的用户密码。如果嫌用户密码和管理员密码分别设置很麻烦就勾选 <code>&lt;为管理员账号使用同样的密码&gt;</code>。然后点击下一步。</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/9.%E8%AE%BE%E7%BD%AE%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%8D%E5%AD%97%E5%8F%8A%E5%AF%86%E7%A0%81.png" alt="用户名及密码"  /></div><h3 id="1-3-8-Office套件"><a href="#1-3-8-Office套件" class="headerlink" title="1.3.8 Office套件"></a>1.3.8 Office套件</h3><p>在系统安装页，Manjaro 提供了多种 Office 套件以供选择，笔者选择的是 LibreOffice。如果这几种都不喜欢可以跳过自行安装 WPS 。</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/10.%E9%80%89%E6%8B%A9office%E5%8A%9E%E5%85%AC%E5%A5%97%E4%BB%B6.png" alt="Office套件选择"  /></div><h3 id="1-3-9-开始系统安装"><a href="#1-3-9-开始系统安装" class="headerlink" title="1.3.9 开始系统安装"></a>1.3.9 开始系统安装</h3><ul><li>Office 套件选择完毕后点击下一步便开始系统安装，此时会生成一个系统安装的摘要，显示之后点击安装。</li></ul><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/11.%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E6%91%98%E8%A6%81.png" alt="系统安装摘要"  /></div><ul><li>此时会弹出一个消息框，选择现在安装继续进行</li></ul><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/12.%E5%AE%89%E8%A3%85%E6%8F%90%E7%A4%BA.png" alt="安装提示"  /></div><ul><li>系统开始安装，点击进度条右边的小红点可以查看系统安装详细信息</li></ul><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/13.%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E7%95%8C%E9%9D%A2.png" alt="开始系统安装"  /></div><ul><li>系统安装完毕，勾选现在重启然后重启系统便可以正常使用了。</li></ul><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/14.%E5%AE%89%E8%A3%85%E7%BB%93%E6%9D%9F.png" alt="系统安装完毕"  /></div><h1 id="二-系统换源"><a href="#二-系统换源" class="headerlink" title="二.系统换源"></a>二.系统换源</h1><p>为了保证 Manjaro 系统下载软件的流畅性，通常需要将软件源更改为国内高校或者阿里腾讯等互联网大厂的软件镜像源。以下部分将介绍镜像源配置流程。</p><h2 id="2-1-获取源列表并更换官方源"><a href="#2-1-获取源列表并更换官方源" class="headerlink" title="2.1 获取源列表并更换官方源"></a>2.1 获取源列表并更换官方源</h2><p>获取方式可以通过命令行方式选取镜像源或者直接更改配置文件</p><h3 id="2-1-1-方式一：通过命令行"><a href="#2-1-1-方式一：通过命令行" class="headerlink" title="2.1.1 方式一：通过命令行"></a>2.1.1 方式一：通过命令行</h3><ol><li>执行如下命令出现镜像源复选框：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman-mirrors -c China -i -m rank<br></code></pre></td></tr></table></figure><ol start="2"><li>在弹出的复选框中选择自己所需的镜像源并点击确认生效。</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E6%9B%B4%E6%96%B0%E6%BA%90/1.%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4.png" alt="选择镜像源"  /></div><ol start="3"><li>镜像源生效之后会将配置写入到 &#96;&#96;&#x2F;etc&#x2F;pacman.d&#x2F;mirrorlist&#96; 文件当中。</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E6%9B%B4%E6%96%B0%E6%BA%90/2.%E9%80%89%E6%8B%A9%E5%B9%B6%E7%A1%AE%E5%AE%9A%E9%95%9C%E5%83%8F%E6%BA%90.png" alt="镜像源生效"  /></div>4. 最后执行如下命令更新软件与系统<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -Syy<br></code></pre></td></tr></table></figure><h3 id="2-1-2-方式二：通过配置文件"><a href="#2-1-2-方式二：通过配置文件" class="headerlink" title="2.1.2 方式二：通过配置文件"></a>2.1.2 方式二：通过配置文件</h3><ol><li>首先打开配置文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">打开镜像配置文件</span><br>nano /etc/pacman.d/mirrorlist<br></code></pre></td></tr></table></figure><ol start="2"><li>找到 Server 关键字，并在这一区域附近添加需要的镜像站链接</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加开源镜像站链接</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">中国科学技术大学</span><br>Server = https://mirrors.ustc.edu.cn/manjaro/stable/$repo/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重庆邮电大学</span><br>Server = https://mirrors.cqupt.edu.cn/manjaro/stable/$repo/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重庆大学</span><br>Server = https://mirrors.cqu.edu.cn/manjaro/stable/$repo/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">南方科技大学</span><br>Server = https://mirrors.sustech.edu.cn/manjaro/stable/$repo/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">北京外国语大学</span><br>Server = https://mirrors.bfsu.edu.cn/manjaro/stable/$repo/$arch<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">华为镜像站</span><br>Server = https://mirrors.huaweicloud.com/manjaro/stable/$repo/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">阿里云镜像站</span><br>Server = https://mirrors.aliyun.com/manjaro/stable/$repo/$arch<br></code></pre></td></tr></table></figure><ol start="3"><li>最后执行如下命令更新软件与系统</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -Syy<br></code></pre></td></tr></table></figure><h2 id="2-2-Arch-Linux-CN-源更换"><a href="#2-2-Arch-Linux-CN-源更换" class="headerlink" title="2.2 Arch Linux CN 源更换"></a>2.2 Arch Linux CN 源更换</h2><p>在更换 <code>archlinuxcn</code> 源时将 <code>arch4edu</code> 的源也更换一下。</p><ol><li>使用 gedit 程序命令访问配置文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo gedit /etc/pacman.conf<br></code></pre></td></tr></table></figure><ol start="2"><li>然后在文件末尾添加如下内容并保存</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">[archlinuxcn]<br>SigLevel = TrustedOnly<br><span class="hljs-meta prompt_"># </span><span class="language-bash">中国科学技术大学</span><br>Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重庆邮电大学</span><br>Server = https://mirrors.cqupt.edu.cn/archlinuxcn/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重庆大学</span><br>Server = https://mirrors.cqu.edu.cn/archlinuxcn/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">南方科技大学</span><br>Server = https://mirrors.sustech.edu.cn/archlinuxcn/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">华中科技大学</span><br>Server = https://mirrors.hust.edu.cn/archlinuxcn/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">北京外国语大学</span><br>Server = https://mirrors.bfsu.edu.cn/archlinuxcn/$arch<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">阿里源</span><br>Server = https://mirrors.aliyun.com/archlinuxcn/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">163源</span><br>Server = http://mirrors.163.com/archlinux-cn/$arch<br><br><br>[arch4edu]<br>SigLevel = Optional TrustAll<br><span class="hljs-meta prompt_"># </span><span class="language-bash">阿里edu源</span><br>Server = https://mirrors.aliyun.com/arch4edu/$arch<br></code></pre></td></tr></table></figure><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E6%9B%B4%E6%96%B0%E6%BA%90/4.%E5%8A%A0%E5%85%A5archlinuxcn%E5%92%8Carch4edu%E6%BA%90.png" alt="更换archlinuxcn和arch4edu源"  /></div>3. 最后执行如下命令更新软件与系统<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -Syyu<br></code></pre></td></tr></table></figure><h1 id="三-常用软件安装"><a href="#三-常用软件安装" class="headerlink" title="三.常用软件安装"></a>三.常用软件安装</h1><h2 id="3-1-输入法安装"><a href="#3-1-输入法安装" class="headerlink" title="3.1 输入法安装"></a>3.1 输入法安装</h2><p>笔者在 Windows 系统上多年都是使用的搜狗输入法。但是由于 Qt 版本的更新，搜狗官方并未在 Linux 下推出新架构的搜狗拼音输入法，因此笔者选择安装 fcitx5 输入法并配置相应的环境。当然，本节也会提供 Fcitx 框架下搜狗输入法的安装。</p><blockquote><p><strong>注</strong>：</p><ul><li><p>两种输入法安装的步骤都是：框架+具体输入法的形式进行</p></li><li><p>Fcitx 和 Fcitx5 两种框架都提供基本的输入法</p></li></ul></blockquote><h3 id="3-1-1-Fcitx5-输入法安装"><a href="#3-1-1-Fcitx5-输入法安装" class="headerlink" title="3.1.1 Fcitx5 输入法安装"></a>3.1.1 Fcitx5 输入法安装</h3><p>Fcitx5 是一个输入法框架，它具有轻量级内核，并通过 addon 提供额外的语言支持。Fcitx5 接替 Fcitx 。</p><ol><li>Fcitx5 依赖安装</li></ol><p>安装 Fcitx5 输入法首先需要下载 fcitx5 的依赖包。通过如下命令安装这些依赖包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span>  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">由于之前装过 Fcitx ，所以需先卸载</span><br>sudo pacman -Rs $(pacman -Qsq fcitx)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">Fcitx5 本体</span><br>sudo pacman -S fcitx5 <br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">集成了[fctxi5]、[fctxi5-configtool]、[fctxi5-gtk]、[fctxi5-qt]</span><br>sudo pacman -S fcitx5-im<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">Fcitx5 配置工具</span><br>sudo pacman -S fcitx5-configtool  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">对 Qt 程序软件的支持</span><br>sudo pacman -S fcitx5-qt# 集成 Qt5 和 Qt6 依赖库<br>sudo pacman -S fcitx5-qt4# 单独集成 Qt4 依赖库<br>sudo pacman -S fcitx5-qt5-git# 单独集成 Qt5 依赖库<br>sudo pacman -S fcitx5-qt6-git# 单独集成 Qt6 依赖库<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">Fcitx5 对于 GTK 程序的支持</span><br>sudo pacman -S fcitx5-gtk<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">Fcitx5 对于中文相关的 addon，例如拼音、双拼和五笔</span><br>sudo pacman -S fcitx5-chinese-addons<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">Fcitx5 的第三方主题库</span><br>sudo pacman -S fcitx5-material-color<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">Fcitx5 对 KDE 桌面环境的支持</span><br>sudo pacman -S kcm-fcitx5<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">Fcitx5 对日期时间的支持</span><br>sudo pacman -S fcitx5-lua<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span> <br></code></pre></td></tr></table></figure><p>通常想要运行 Fcitx5 的输入法环境只需要安装 fcitx5-im 即可，如果有更多定制化操作可视情况而定。</p><ol start="2"><li>Fcitx5 环境配置</li></ol><p>访问 <code>/etc/environment</code> 文件并将如下内容追加到文件末尾：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">GTK_IM_MODULE=fcitx5<br>QT_IM_MODULE=fcitx5<br>XMODIFIERS=@im=fcitx5<br>SDL_IM_MODULE=fcitx5<br>INPUT_METHOD=fcitx5<br>GLFW_IM_MODULE=fcitx<br></code></pre></td></tr></table></figure><p>然后注销登陆重启输入法或者重启系统即可，如果想要添加词库，可运行 <code>Fcitx5</code> 配置软件对拼音输入法进行配置。</p><h3 id="3-1-2-Fcitx-输入法安装"><a href="#3-1-2-Fcitx-输入法安装" class="headerlink" title="3.1.2 Fcitx 输入法安装"></a>3.1.2 Fcitx 输入法安装</h3><ul><li>安装搜狗输入法首先需要下载 <code>Fcitx</code> 的依赖包。通过如下命令安装这些依赖包：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S fcitx fcitx-configtool fcitx-gtk2 fcitx-gtk3 fcitx-qt5 fcitx-qt6<br></code></pre></td></tr></table></figure><ul><li>然后访问 ~&#x2F;.xprofile 文件并在末尾追加如下内容：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">export GTK_IM_MODULE=fcitx<br>export QT_IM_MODULE=fcitx<br>export XMODIFIERS=&quot;@im=fcitx&quot;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><p>本文是对 ~&#x2F;.xprofile 文件进行的操作，也可以对 &#x2F;etc&#x2F;environment 文件进行上述相同的操作。如果不进行环境的配置，那么重启之后不能正常切换输入法，也就不能输入中文。</p><p>下面对几个环境变量配置文件进行简单介绍：</p><ul><li><p>profile: 每次终端登录时读取</p></li><li><p>bashrc: 每次终端登录时读取。</p></li><li><p>xinitrc: 每次startx启动Xwindows服务时读取</p></li><li><p>xprofile: 每次使用gdm、lightdm等图形登录管理器时读取。</p></li><li><p>environment：在所有用户登陆时都有效。</p></li></ul></blockquote><h3 id="3-1-3-搜狗输入法安装"><a href="#3-1-3-搜狗输入法安装" class="headerlink" title="3.1.3 搜狗输入法安装"></a>3.1.3 搜狗输入法安装</h3><p>AUR 提供了 fcitx-sogoupinyin 和 fcitx5-sogoupinyin 两个版本的输入法，笔者采用的是 fcitx-sogoupinyin 这一版本。下面正式开始搜狗输入法安装：</p><ul><li>然后通过从 <a href="https://aur.archlinux.org/packages?O=0&SeB=nd&K=sogou&outdated=&SB=p&SO=d&PP=50&submit=Go">AUR</a> 上给拉取软件包 git 链接到本地</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone &lt;Target Source Address&gt;<br></code></pre></td></tr></table></figure><ul><li>然后进入项目文件夹直接开始构建安装软件包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd fcitx-sogoupinyin<br>makepkg -si<br></code></pre></td></tr></table></figure><p>此时会出现如下图所示的错误：</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/%E6%90%9C%E7%8B%97%E6%8B%BC%E9%9F%B3%E5%AE%89%E8%A3%85.png" alt="搜狗拼音安装"  /></div><p>这一错误会导致需要安装的 deb 包下载失败，从而导致整个安装过程的失败。为了避免此错误，笔者采用的方式是从 <a href="https://shurufa.sogou.com/">搜狗拼音输入法官网</a> 下载 deb 包放到此项目文件夹中，然后使用 PKGBUILD 文件构建安装软件包。不出意外的话，搜狗拼音输入法就安装完毕了。</p><ul><li>最后重启 Manjaro 系统，然后在 Fcitx 配置软件中将搜狗拼音输入法添加为第二输入法。这样就可以正常使用了。</li></ul><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Fcitx%E9%85%8D%E7%BD%AE%E6%90%9C%E7%8B%97%E6%8B%BC%E9%9F%B3%E8%BE%93%E5%85%A5%E6%B3%95.png" alt="Fcitx配置搜狗输入法"  /></div><h3 id="3-1-4-搜狗输入法安装导致问题"><a href="#3-1-4-搜狗输入法安装导致问题" class="headerlink" title="3.1.4 搜狗输入法安装导致问题"></a>3.1.4 搜狗输入法安装导致问题</h3><p>笔者安装了搜狗输入法进而导致了系统关机以及系统重启时会 <code>user@1000.service</code> 服务关闭异常。而将搜狗输入法卸载之后一切恢复到正常。</p><p>解决此问题的思路：</p><ol><li>启用 <code>debug-shell.sevice</code> 服务</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl enable debug-shell.service<br></code></pre></td></tr></table></figure><ol start="2"><li>关机出现问题时使用 <code>Alt+F9</code> 进入 shell 调试命令行</li><li>使用 systemctl status 命令查看正在运行的服务</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl list-unit-files --type=service | grep enabled<br></code></pre></td></tr></table></figure><p>此时发现了 <code>user@1000.service</code> 仍在运行</p><ol start="4"><li>使用 systemctl status 命令继续查看 <a href="mailto:&#x75;&#x73;&#x65;&#114;&#64;&#49;&#x30;&#x30;&#48;&#x2e;&#115;&#101;&#114;&#118;&#x69;&#x63;&#101;">&#x75;&#x73;&#x65;&#114;&#64;&#49;&#x30;&#x30;&#48;&#x2e;&#115;&#101;&#114;&#118;&#x69;&#x63;&#101;</a> 服务</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl status user@1000.service<br></code></pre></td></tr></table></figure><p>此时便定位到了 <code>user@1000.service</code> 服务下的 sogoupinyin -service 子服务仍然在运行。</p><h2 id="3-2-回滚工具安装"><a href="#3-2-回滚工具安装" class="headerlink" title="3.2 回滚工具安装"></a>3.2 回滚工具安装</h2><p>使用如下命令可以安装回滚工具（TimeShift）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S timeshift<br></code></pre></td></tr></table></figure><h2 id="3-3-Chrome-浏览器安装"><a href="#3-3-Chrome-浏览器安装" class="headerlink" title="3.3 Chrome 浏览器安装"></a>3.3 Chrome 浏览器安装</h2><p>使用如下命令可以安装谷歌浏览器（google-chrome）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S google-chrome<br></code></pre></td></tr></table></figure><h2 id="3-4-Clash-软件安装"><a href="#3-4-Clash-软件安装" class="headerlink" title="3.4 Clash 软件安装"></a>3.4 Clash 软件安装</h2><h3 id="3-4-1-Clash-for-Windows"><a href="#3-4-1-Clash-for-Windows" class="headerlink" title="3.4.1 Clash for Windows"></a>3.4.1 Clash for Windows</h3><p><strong>来自官网的介绍</strong>：Clash for Windows 是代理工具 Clash 在 Windows 系统的唯一图形客户端，同时还支持Windows、Linux、macOS 三大系统，功能强大且支持多种代理协议，如 Shadowsocks(SS)、ShadowsocksR(SSR)、Socks、Snell、V2Ray、Trojan 等代理协议。由于不知名原因，Clash for Windows 的作者已在 Github 上删库跑路，最终版本停在了 0.20.39 版本。</p><ol><li><p>首先下载 Clash for Windows 软件的 deb 软件包。在 Github 上有许多备份包可供下载，这里不再赘述。</p></li><li><p>然后通过 <code>debtap</code> 命令将 Clash for Windows 软件的 deb 包转换包格式。详细如下截图所示：</p></li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Clash%E8%BD%AF%E4%BB%B6%E8%BD%AC%E5%8C%85.png" alt="Clash转包"  /></div><ol start="3"><li>打包完成后会生成一个 <code>.pkg.tar.zst</code> 的软件包，然后通过 <code>pacman</code> 命令进行本地安装</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -U &lt;Packge Name&gt;<br></code></pre></td></tr></table></figure><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Clash%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85.png" alt="Clash本地安装"  /></div><ol start="4"><li>想要正常使用，还需要设置系统网络代理，下图展示的是笔者的代理参数：</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Clash%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86.png" alt="设置系统网络代理"  /></div><blockquote><p><strong>注</strong>：</p><ol><li><p>这里的端口对应的是软件 UI 界面上 Port 栏目的端口号。</p></li><li><p>想正常科学上网还需要相应的订阅节点，网上有很多免费节点可用， 这里便不再展开。</p></li><li><p>如果设置了开机自动启动 <code>Clash for Windows</code> 而不想在桌面显示，可以在软件设置中开启 <code>静默启动（Silent Start）</code> 选项。</p></li></ol></blockquote><p>至此，Clash for Windows 的 Manjaro 版本便安装完毕。</p><h3 id="3-4-2-Clash-Verge"><a href="#3-4-2-Clash-Verge" class="headerlink" title="3.4.2 Clash Verge"></a>3.4.2 Clash Verge</h3><p>除了使用 Clash for Windows 之外，你还可以选择使用基于 <code>Tauri</code> 的 Clash Verge 软件。具体的安装可采用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S clash-verge-rev-bin<br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><p>装完打不开前端面板，疑似N卡最新闭源驱动不支持 webkit 硬件渲染。解决的办法是在 <code>/etc/environment</code> 配置文件中添加环境变量: <code>WEBKIT_DISABLE_COMPOSITING_MODE=1</code>。</p></blockquote><h2 id="3-5-QQ-安装"><a href="#3-5-QQ-安装" class="headerlink" title="3.5 QQ 安装"></a>3.5 QQ 安装</h2><p>近年来，随着国产 Linux 发行版的兴起。QQ 也顺应时代通过 QQNT（Electron）技术对原先的腾讯QQ进行改造并至今发布多个版本。可以通过以下命令进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S linuxqq<br></code></pre></td></tr></table></figure><h2 id="3-6-微信安装"><a href="#3-6-微信安装" class="headerlink" title="3.6 微信安装"></a>3.6 微信安装</h2><p>近期，腾讯公司推出了运行在国产 Linux 发行版系统上的 Universal 版微信。此版本一经推出，受到广大 Linux 用户及开发者的关注，AUR 上的大佬通过打包将这一安装包发布在 AUR 仓库。笔者也第一时间去安装体验了这一版本。具体安装如下指令所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S wechat-universal-bwrap<br></code></pre></td></tr></table></figure><h2 id="3-7-腾讯会议安装"><a href="#3-7-腾讯会议安装" class="headerlink" title="3.7 腾讯会议安装"></a>3.7 腾讯会议安装</h2><p>腾讯会议可在官网下载各种架构的 Linux 版本，下载 deb 包自行打包也可以，当然也可以在 AUR 上获取相应的软件安装包。笔者习惯在 AUR 上获取软件，具体命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S wemeet-bin<br></code></pre></td></tr></table></figure><h2 id="3-8-QQ音乐安装"><a href="#3-8-QQ音乐安装" class="headerlink" title="3.8 QQ音乐安装"></a>3.8 QQ音乐安装</h2><p>在 AUR 社区可以看到 @<a href="https://aur.archlinux.org/account/Hill-98">Hill-98</a> 大佬有两个版本的 QQ音乐软件包。</p><ul><li><p>1.1.5-8 版本对应的名称为：<a href="https://aur.archlinux.org/packages/qqmusic-electron">qqmusic-electron</a></p></li><li><p>1.1.5-1 版本对应的名称为：<a href="https://aur.archlinux.org/packages/qqmusic-bin">qqmusic-bin</a></p></li></ul><p>在这里，笔者使用了更高版本的 qqmusic-electron ，具体安装参照如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S qqmusic-electron <br></code></pre></td></tr></table></figure><h2 id="3-9-顶部栏隐藏"><a href="#3-9-顶部栏隐藏" class="headerlink" title="3.9 顶部栏隐藏"></a>3.9 顶部栏隐藏</h2><p>此插件的功能是当应用最大化时能自动隐藏顶部栏，此软件通过 yay 安装即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S gnome-shell-extension-hidetopbar-git<br></code></pre></td></tr></table></figure><h2 id="3-10-WPS-Office-套件安装"><a href="#3-10-WPS-Office-套件安装" class="headerlink" title="3.10 WPS Office 套件安装"></a>3.10 WPS Office 套件安装</h2><p>使用如下命令即可安装 WPS 套件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">WPS软件本体（国际版）</span><br>yay -S wps-office<br><span class="hljs-meta prompt_"># </span><span class="language-bash">WPS的中文语言包</span><br>yay -S wps-office-mui-zh-cn<br><span class="hljs-meta prompt_"># </span><span class="language-bash">WPS的符号依赖包</span><br>yay -S ttf-wps-fonts<br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><ol><li><p>开始安装会报错，需要先安装文件 base-devel 库文件</p></li><li><p>安装完毕后依然无法使用wps pdf软件。需安装 libtiff5 库文件</p></li><li><p>更多问题可参考 <a href="https://wiki.archlinuxcn.org/wiki/WPS_Office">WPS Office Wiki</a></p></li></ol></blockquote><h2 id="3-11-GitHub-Desktop-安装"><a href="#3-11-GitHub-Desktop-安装" class="headerlink" title="3.11 GitHub Desktop 安装"></a>3.11 GitHub Desktop 安装</h2><p>Github Desktop 在 AUR 上有相应的包，这里可以通过如下命令安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">AUR上有许多版本，这里选用的是中文版</span><br>yay -S github-desktop-zh-bin<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果使用原生的英文版，可用如下指令安装</span><br>yay -S github-desktop-bin<br></code></pre></td></tr></table></figure><h2 id="3-12-笔记软件"><a href="#3-12-笔记软件" class="headerlink" title="3.12 笔记软件"></a>3.12 笔记软件</h2><p>由于 <code>Notepad++</code> 并不支持众多 Linux 系统，所以可以使用 <code>Notepadqq</code> 、 <code>NotepadNext</code>  或者是 <code>Notepad--</code> 软件平替。当然，如果需要书写 Markdown 格式笔记更加流畅的体验，可以安装 <code>Typora</code> 软件。</p><ol><li><code>Notepadqq</code> 软件安装：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S notepadqq<br></code></pre></td></tr></table></figure><ol start="2"><li><code>NotepadNext</code> 软件安装：</li></ol><p>本软件在 AUR 中暂时没有收录，且无 deb 包提供，仅提供了 AppImage 格式的软件包，因此笔者的此软件就是通过 AppImage 包安装的。这里附上此软件的 AppImage 软件包链接：<a href="https://github.com/dail8859/NotepadNext">NotepadNext</a></p><ol start="3"><li><code>Notepad--</code> 软件安装：</li></ol><p>此软件是对于 <code>Notepad++</code> 的国产软件替代，笔者也相当推荐使用此软件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">此处有三个 `-`</span><br>yay -S notepad---bin<br></code></pre></td></tr></table></figure><ol start="3"><li><code>Typora</code> 软件安装：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S typora<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Manjaro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySql学习</title>
    <link href="/2022/08/31/MySQL%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/08/31/MySQL%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="一-通用语法及分类"><a href="#一-通用语法及分类" class="headerlink" title="一.通用语法及分类"></a>一.通用语法及分类</h2><ul><li>DDL（Data Definition Language）: 数据<strong>定义</strong>语言，用来定义数据库对象（数据库、表、字段）。常用的语句关键字主要包括 create、drop、alter等。</li><li>DML（Data Manipulation Language）: 数据<strong>操作</strong>语言，用来对数据库表中的数据进行增删改。常用的语句关键字主要包括 insert、delete、udpate等。</li><li>DQL（Data Query Language）: 数据<strong>查询</strong>语言，用来查询数据库中表的记录。常用的语句关键字主要包括 select、from、where等。</li><li>DCL（Data Control Language）: 数据<strong>控制</strong>语言，用来创建数据库用户、控制数据库的控制权限。主要的语句关键字包括 grant、revoke 等。</li></ul><h3 id="MySQL-的数据类型"><a href="#MySQL-的数据类型" class="headerlink" title="MySQL 的数据类型"></a>MySQL 的数据类型</h3><ol><li>数值类型</li></ol><table><thead><tr><th align="center">类型</th><th align="center">大小</th><th align="center">有符号范围（Signed）</th><th align="center">无符号范围（Unsigned）</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">TINYINT</td><td align="center">1 Byte</td><td align="center">(-128，127)</td><td align="center">(0 ，255)</td><td align="center">小整数值</td></tr><tr><td align="center">SMALLINT</td><td align="center">2 Bytes</td><td align="center">(-32768，32767)</td><td align="center">(0 ，65535)</td><td align="center">大整数值</td></tr><tr><td align="center">MEDIUMINT</td><td align="center">3 Bytes</td><td align="center">(-8388608，8388607)</td><td align="center">(0 ，16777215)</td><td align="center">大整数值</td></tr><tr><td align="center">INT或者INTEGER</td><td align="center">4 Bytes</td><td align="center">(-2147483648，2147483647)</td><td align="center">(0 ，4294967295)</td><td align="center">大整数值</td></tr><tr><td align="center">BIGINT</td><td align="center">8 Bytes</td><td align="center">(-2^63 ，2^63 -1)</td><td align="center">(0，2^64-1)</td><td align="center">极大整数值</td></tr><tr><td align="center">FLOAT</td><td align="center">4 Bytes</td><td align="center">(-3.402823466 E+38，3.402823466351 E+38)</td><td align="center">0 和 (1.175494351 E-38，3.402823466351 E+38)</td><td align="center">单精度浮点数值</td></tr><tr><td align="center">DOUBLE</td><td align="center">8 Bytes</td><td align="center">(-1.7976931348623157 E+308 ，1.7976931348623157 E+308)</td><td align="center">0 和 (2.2250738585072014 E-308 ，1.7976931348623157 E+308)</td><td align="center">双精度浮点数值</td></tr><tr><td align="center">DECIMAL</td><td align="center">——</td><td align="center">依赖于精度（M）和标度（D）的数值</td><td align="center">依赖于精度（M）和标度（D）的数值</td><td align="center">小数值（精确定点数）</td></tr></tbody></table><ol start="2"><li>字符串类型</li></ol><table><thead><tr><th align="center">类型</th><th align="center">大小</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">CHAR</td><td align="center">0 - 255 Bytes</td><td align="center">变长字符串</td></tr><tr><td align="center">VARCHAR</td><td align="center">0 - 65535 Bytes</td><td align="center">定长字符串</td></tr><tr><td align="center">TINYBLOB</td><td align="center">0 - 255 Bytes</td><td align="center">不超过255个字符的二进制数据</td></tr><tr><td align="center">TINYTEXT</td><td align="center">0 - 255 Bytes</td><td align="center">短文本字符串</td></tr><tr><td align="center">BLOB</td><td align="center">0 - 65535 Bytes</td><td align="center">二进制形式的长文本数据</td></tr><tr><td align="center">TEXT</td><td align="center">0 - 65535 Bytes</td><td align="center">长文本数据</td></tr><tr><td align="center">MEDIUMBLOB</td><td align="center">0 - 16777215 Bytes</td><td align="center">二进制形式的中等长度文本数据</td></tr><tr><td align="center">MEDIUMTEXT</td><td align="center">0 - 16777215 Bytes</td><td align="center">中等长度文本数据</td></tr><tr><td align="center">LONGBLOB</td><td align="center">0 - 4294967295 Bytes</td><td align="center">二进制形式的极大文本数据</td></tr><tr><td align="center">LONGTEXT</td><td align="center">0 - 4294967295 Bytes</td><td align="center">极大文本数据</td></tr></tbody></table><ol start="3"><li>日期类型</li></ol><table><thead><tr><th align="center">类型</th><th align="center">大小</th><th align="center">范围</th><th align="center">格式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">DATE</td><td align="center">3 Bytes</td><td align="center">1000-01-01 到 9999-12-31</td><td align="center">YYYY-MM-DD</td><td align="center">日期值</td></tr><tr><td align="center">TIME</td><td align="center">3 Bytes</td><td align="center">-838:59:59 到 838:59:59</td><td align="center">HH:MM:SS</td><td align="center">时间值或者持续时间</td></tr><tr><td align="center">YEAR</td><td align="center">1 Bytes</td><td align="center">1901 到 2155</td><td align="center">YYYY</td><td align="center">年份值</td></tr><tr><td align="center">DATETIME</td><td align="center">8 Bytes</td><td align="center">1000-01-01 00:00:00 到 9999-12-31 23:59:59</td><td align="center">YYYY-MM-DD HH:MM:SS</td><td align="center">混合日期和时间值</td></tr><tr><td align="center">TIMESTAMP</td><td align="center">4 Bytes</td><td align="center">1970-01-01 00:00:00 到 2038-01-19 03:14:07</td><td align="center">YYYY-MM-DD HH:MM:SS</td><td align="center">混合日期和时间值。时间戳</td></tr></tbody></table><h3 id="1-1-DDL（数据定义语言）"><a href="#1-1-DDL（数据定义语言）" class="headerlink" title="1.1 DDL（数据定义语言）"></a>1.1 DDL（数据定义语言）</h3><p>数据定义语言</p><h4 id="1-1-1-数据库操作"><a href="#1-1-1-数据库操作" class="headerlink" title="1.1.1 数据库操作"></a>1.1.1 数据库操作</h4><ul><li><p>查询所有数据库：<br><code>SHOW DATABASES;</code></p></li><li><p>查询当前数据库：<br><code>SELECT DATABASE();</code></p></li><li><p>创建数据库：<br><code>CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];</code></p></li><li><p>删除数据库：<br><code>DROP DATABASE [ IF EXISTS ] 数据库名;</code></p></li><li><p>使用数据库：<br><code>USE 数据库名;</code></p></li></ul><blockquote><p>注：UTF8字符集长度为3字节，有些符号占4字节，所以一般推荐用utf8mb4字符集</p></blockquote><h4 id="1-1-2-表操作"><a href="#1-1-2-表操作" class="headerlink" title="1.1.2 表操作"></a>1.1.2 表操作</h4><ul><li><p>查询当前数据库所有表：</p><p><code>SHOW TABLES;</code></p></li><li><p>查询表结构：<br><code>DESC 表名;</code></p></li><li><p>查询指定表的建表语句：<br><code>SHOW CREATE TABLE 表名;</code></p></li><li><p>创建表：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名(<br>字段1 字段1类型 [COMMENT 字段1注释],<br>字段2 字段2类型 [COMMENT 字段2注释],<br>字段3 字段3类型 [COMMENT 字段3注释],<br>...<br>字段n 字段n类型 [COMMENT 字段n注释]<br>)[ COMMENT 表注释 ];<br></code></pre></td></tr></table></figure><blockquote><p>注： <strong>最后一个字段后面没有逗号</strong></p></blockquote><ul><li><p>添加字段：<br><code>ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];</code><br>例：<code>ALTER TABLE emp ADD nickname varchar(20) COMMENT &#39;昵称&#39;;</code></p></li><li><p>修改数据类型：<br><code>ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);</code></p></li><li><p>修改字段名和字段类型：<br><code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</code><br>例：将emp表的nickname字段修改为username，类型为varchar(30)<br><code>ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT &#39;昵称&#39;;</code></p></li><li><p>删除字段：<br><code>ALTER TABLE 表名 DROP 字段名;</code></p></li><li><p>修改表名：<br><code>ALTER TABLE 表名 RENAME TO 新表名</code></p></li><li><p>删除表：<br><code>DROP TABLE [IF EXISTS] 表名;</code></p></li><li><p>删除表，并重新创建该表：<br><code>TRUNCATE TABLE 表名;</code></p></li></ul><h3 id="1-2-DML（数据操作语言）"><a href="#1-2-DML（数据操作语言）" class="headerlink" title="1.2 DML（数据操作语言）"></a>1.2 DML（数据操作语言）</h3><h4 id="1-2-1-添加数据"><a href="#1-2-1-添加数据" class="headerlink" title="1.2.1 添加数据"></a>1.2.1 添加数据</h4><ul><li><p>指定字段：<br><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);</code></p></li><li><p>全部字段：<br><code>INSERT INTO 表名 VALUES (值1, 值2, ...);</code></p></li><li><p>批量添加数据：<br><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</code><br><code>INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</code></p></li></ul><blockquote><p><strong>注意事项</strong>：</p><ul><li>插入数据时，指定字段顺序需要与值的顺序一一对应</li><li>字符串和日期类型数据应该包含在引号中</li><li>插入的数据大小应该在字段的规定范围内</li></ul></blockquote><h4 id="1-2-2-更新和删除数据"><a href="#1-2-2-更新和删除数据" class="headerlink" title="1.2.2 更新和删除数据"></a>1.2.2 更新和删除数据</h4><ul><li><p>修改数据：<br><code>UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];</code><br>例：<br><code>UPDATE emp SET name = &#39;Jack&#39; WHERE id = 1;</code></p></li><li><p>删除数据：<br><code>DELETE FROM 表名 [ WHERE 条件 ];</code></p></li></ul><h3 id="1-3-DQL（数据查询语言）"><a href="#1-3-DQL（数据查询语言）" class="headerlink" title="1.3 DQL（数据查询语言）"></a>1.3 DQL（数据查询语言）</h3><ul><li>语法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT<br>字段列表<br>FROM<br>表名字段<br>WHERE<br>条件列表<br>GROUP BY<br>分组字段列表<br>HAVING<br>分组后的条件列表<br>ORDER BY<br>排序字段列表<br>LIMIT<br>分页参数<br></code></pre></td></tr></table></figure><h4 id="1-3-1-基础查询"><a href="#1-3-1-基础查询" class="headerlink" title="1.3.1 基础查询"></a>1.3.1 基础查询</h4><ul><li><p>查询多个字段：<br><code>SELECT 字段1, 字段2, 字段3, ... FROM 表名;</code><br><code>SELECT * FROM 表名;</code></p></li><li><p>设置别名：<br><code>SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名;</code><br><code>SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名;</code></p></li><li><p>去除重复记录：<br><code>SELECT DISTINCT 字段列表 FROM 表名;</code></p></li><li><p>转义：<br><code>SELECT * FROM 表名 WHERE name LIKE &#39;/_张三&#39; ESCAPE &#39;/&#39;</code><br>&#x2F; 之后的_不作为通配符</p></li></ul><h4 id="1-3-2-条件查询"><a href="#1-3-2-条件查询" class="headerlink" title="1.3.2 条件查询"></a>1.3.2 条件查询</h4><ul><li>语法：<br><code>SELECT 字段列表 FROM 表名 WHERE 条件列表;</code></li></ul><p>条件：</p><table><thead><tr><th align="center">比较运算符</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&gt;&#x3D;</td><td align="center">大于等于</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&lt;&#x3D;</td><td align="center">小于等于</td></tr><tr><td align="center">&#x3D;</td><td align="center">等于</td></tr><tr><td align="center">&lt;&gt; 或 !&#x3D;</td><td align="center">不等于</td></tr><tr><td align="center">BETWEEN … AND …</td><td align="center">在某个范围内（含最小、最大值）</td></tr><tr><td align="center">IN(…)</td><td align="center">在in之后的列表中的值，多选一</td></tr><tr><td align="center">LIKE 占位符</td><td align="center">模糊匹配（_匹配单个字符，%匹配任意个字符）</td></tr><tr><td align="center">IS NULL</td><td align="center">是NULL</td></tr></tbody></table><table><thead><tr><th align="center">逻辑运算符</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">AND 或 &amp;&amp;</td><td align="center">并且（多个条件同时成立）</td></tr><tr><td align="center">OR 或 &#124;&#124;</td><td align="center">或者（多个条件任意一个成立）</td></tr><tr><td align="center">NOT 或 !</td><td align="center">非，不是</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 年龄等于30<br>select * from employee where age = 30;<br>-- 年龄小于30<br>select * from employee where age &lt; 30;<br>-- 小于等于<br>select * from employee where age &lt;= 30;<br>-- 没有身份证<br>select * from employee where idcard is null or idcard = &#x27;&#x27;;<br>-- 有身份证<br>select * from employee where idcard;<br>select * from employee where idcard is not null;<br>-- 不等于<br>select * from employee where age != 30;<br>-- 年龄在20到30之间<br>select * from employee where age between 20 and 30;<br>select * from employee where age &gt;= 20 and age &lt;= 30;<br>-- 下面语句不报错，但查不到任何信息<br>select * from employee where age between 30 and 20;<br>-- 性别为女且年龄小于30<br>select * from employee where age &lt; 30 and gender = &#x27;女&#x27;;<br>-- 年龄等于25或30或35<br>select * from employee where age = 25 or age = 30 or age = 35;<br>select * from employee where age in (25, 30, 35);<br>-- 姓名为两个字<br>select * from employee where name like &#x27;__&#x27;;<br>-- 身份证最后为X<br>select * from employee where idcard like &#x27;%X&#x27;;<br></code></pre></td></tr></table></figure><h4 id="1-3-3-聚合查询（聚合函数）"><a href="#1-3-3-聚合查询（聚合函数）" class="headerlink" title="1.3.3 聚合查询（聚合函数）"></a>1.3.3 聚合查询（聚合函数）</h4><p>常见聚合函数：</p><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">count</td><td align="center">统计数量</td></tr><tr><td align="center">max</td><td align="center">最大值</td></tr><tr><td align="center">min</td><td align="center">最小值</td></tr><tr><td align="center">avg</td><td align="center">平均值</td></tr><tr><td align="center">sum</td><td align="center">求和</td></tr></tbody></table><ul><li>语法：<br><code>SELECT 聚合函数(字段列表) FROM 表名;</code><br>例：<br><code>SELECT count(id) from employee where workaddress = &quot;广东省&quot;;</code></li></ul><h4 id="1-3-4-分组查询"><a href="#1-3-4-分组查询" class="headerlink" title="1.3.4 分组查询"></a>1.3.4 分组查询</h4><ul><li>语法：<br><code>SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ];</code></li></ul><p>where 和 having 的区别：</p><ul><li>执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以。</li></ul><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）<br>select count(*) from employee group by gender;<br>-- 根据性别分组，统计男性和女性数量<br>select gender, count(*) from employee group by gender;<br>-- 根据性别分组，统计男性和女性的平均年龄<br>select gender, avg(age) from employee group by gender;<br>-- 年龄小于45，并根据工作地址分组<br>select workaddress, count(*) from employee where age &lt; 45 group by workaddress;<br>-- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址<br>select workaddress, count(*) address_count from employee where age &lt; 45 group by workaddress having address_count &gt;= 3;<br></code></pre></td></tr></table></figure><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>执行顺序：where &gt; 聚合函数 &gt; having</li><li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</li></ul><h4 id="1-3-5-排序查询"><a href="#1-3-5-排序查询" class="headerlink" title="1.3.5 排序查询"></a>1.3.5 排序查询</h4><ul><li>语法：<br><code>SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;</code></li></ul><p>排序方式：</p><ul><li>ASC: 升序（默认）</li><li>DESC: 降序</li></ul><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 根据年龄升序排序<br>SELECT * FROM employee ORDER BY age ASC;<br>SELECT * FROM employee ORDER BY age;<br>-- 两字段排序，根据年龄升序排序，入职时间降序排序<br>SELECT * FROM employee ORDER BY age ASC, entrydate DESC;<br></code></pre></td></tr></table></figure><blockquote><p>注意：如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序</p></blockquote><h4 id="1-3-6-分页查询"><a href="#1-3-6-分页查询" class="headerlink" title="1.3.6 分页查询"></a>1.3.6 分页查询</h4><ul><li>语法：<br><code>SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;</code></li></ul><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询第一页数据，展示10条<br>SELECT * FROM employee LIMIT 0, 10;<br>-- 查询第二页<br>SELECT * FROM employee LIMIT 10, 10;<br></code></pre></td></tr></table></figure><blockquote><p>注意事项：</p><ul><li>起始索引从0开始，起始索引 &#x3D; （查询页码 - 1） * 每页显示记录数</li><li>分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT</li><li>如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10</li></ul></blockquote><h4 id="1-3-7-DQL执行顺序"><a href="#1-3-7-DQL执行顺序" class="headerlink" title="1.3.7 DQL执行顺序"></a>1.3.7 DQL执行顺序</h4><p>FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT</p><h3 id="1-4-DCL（数据控制语言）"><a href="#1-4-DCL（数据控制语言）" class="headerlink" title="1.4 DCL（数据控制语言）"></a>1.4 DCL（数据控制语言）</h3><h4 id="1-4-1-管理用户"><a href="#1-4-1-管理用户" class="headerlink" title="1.4.1 管理用户"></a>1.4.1 管理用户</h4><ul><li>查询用户：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">USE mysql;<br>SELECT * FROM user;<br></code></pre></td></tr></table></figure><ul><li><p>创建用户:<br><code>CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;</code></p></li><li><p>修改用户密码：<br><code>ALTER USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;;</code></p></li><li><p>删除用户：<br><code>DROP USER &#39;用户名&#39;@&#39;主机名&#39;;</code></p></li></ul><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 创建用户test，只能在当前主机localhost访问<br>create user &#x27;test&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;<br>-- 创建用户test，能在任意主机访问<br>create user &#x27;test&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;<br>create user &#x27;test&#x27; identified by &#x27;123456&#x27;;<br>-- 修改密码<br>alter user &#x27;test&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;1234&#x27;;<br>-- 删除用户<br>drop user &#x27;test&#x27;@&#x27;localhost&#x27;;<br></code></pre></td></tr></table></figure><blockquote><p>注意事项：主机名可以使用 % 通配</p></blockquote><h4 id="1-4-2-权限控制"><a href="#1-4-2-权限控制" class="headerlink" title="1.4.2 权限控制"></a>1.4.2 权限控制</h4><ul><li>常用权限：</li></ul><table><thead><tr><th align="center">权限</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ALL, ALL PRIVILEGES</td><td align="center">所有权限</td></tr><tr><td align="center">SELECT</td><td align="center">查询数据</td></tr><tr><td align="center">INSERT</td><td align="center">插入数据</td></tr><tr><td align="center">UPDATE</td><td align="center">修改数据</td></tr><tr><td align="center">DELETE</td><td align="center">删除数据</td></tr><tr><td align="center">ALTER</td><td align="center">修改表</td></tr><tr><td align="center">DROP</td><td align="center">删除数据库&#x2F;表&#x2F;视图</td></tr><tr><td align="center">CREATE</td><td align="center">创建数据库&#x2F;表</td></tr></tbody></table><p>更多权限请看<a href="#%E6%9D%83%E9%99%90%E4%B8%80%E8%A7%88%E8%A1%A8" title="权限一览表">权限一览表</a></p><ul><li><p>查询权限：<br><code>SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;</code></p></li><li><p>授予权限：<br><code>GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;</code></p></li><li><p>撤销权限：<br><code>REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;</code></p></li></ul><h5 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>多个权限用逗号分隔</li><li>授权时，数据库名和表名可以用 * 进行通配，代表所有</li></ul><h2 id="二-函数"><a href="#二-函数" class="headerlink" title="二.函数"></a>二.函数</h2><ul><li>字符串函数</li><li>数值函数</li><li>日期函数</li><li>流程函数</li></ul><h3 id="2-1-字符串函数"><a href="#2-1-字符串函数" class="headerlink" title="2.1 字符串函数"></a>2.1 字符串函数</h3><ul><li>常用函数：</li></ul><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">CONCAT(s1, s2, …, sn)</td><td align="center">字符串拼接，将s1, s2, …, sn拼接成一个字符串</td></tr><tr><td align="center">LOWER(str)</td><td align="center">将字符串全部转为小写</td></tr><tr><td align="center">UPPER(str)</td><td align="center">将字符串全部转为大写</td></tr><tr><td align="center">LPAD(str, n, pad)</td><td align="center">左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td></tr><tr><td align="center">RPAD(str, n, pad)</td><td align="center">右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td></tr><tr><td align="center">TRIM(str)</td><td align="center">去掉字符串头部和尾部的空格</td></tr><tr><td align="center">SUBSTRING(str, start, len)</td><td align="center">返回从字符串str从start位置起的len个长度的字符串</td></tr></tbody></table><p>使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 拼接<br>SELECT CONCAT(&#x27;Hello&#x27;, &#x27;World&#x27;);<br>-- 小写<br>SELECT LOWER(&#x27;Hello&#x27;);<br>-- 大写<br>SELECT UPPER(&#x27;Hello&#x27;);<br>-- 左填充<br>SELECT LPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);<br>-- 右填充<br>SELECT RPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);<br>-- 去除空格<br>SELECT TRIM(&#x27; Hello World &#x27;);<br>-- 切片（起始索引为1）<br>SELECT SUBSTRING(&#x27;Hello World&#x27;, 1, 5);<br></code></pre></td></tr></table></figure><h3 id="2-2-数值函数"><a href="#2-2-数值函数" class="headerlink" title="2.2 数值函数"></a>2.2 数值函数</h3><ul><li>常见函数：</li></ul><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">CEIL(x)</td><td align="center">向上取整</td></tr><tr><td align="center">FLOOR(x)</td><td align="center">向下取整</td></tr><tr><td align="center">MOD(x, y)</td><td align="center">返回x&#x2F;y的模</td></tr><tr><td align="center">RAND()</td><td align="center">返回0~1内的随机数</td></tr><tr><td align="center">ROUND(x, y)</td><td align="center">求参数x的四舍五入值，保留y位小数</td></tr></tbody></table><h3 id="2-3-日期函数"><a href="#2-3-日期函数" class="headerlink" title="2.3 日期函数"></a>2.3 日期函数</h3><ul><li>常用函数：</li></ul><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">CURDATE()</td><td align="center">返回当前日期</td></tr><tr><td align="center">CURTIME()</td><td align="center">返回当前时间</td></tr><tr><td align="center">NOW()</td><td align="center">返回当前日期和时间</td></tr><tr><td align="center">YEAR(date)</td><td align="center">获取指定date的年份</td></tr><tr><td align="center">MONTH(date)</td><td align="center">获取指定date的月份</td></tr><tr><td align="center">DAY(date)</td><td align="center">获取指定date的日期</td></tr><tr><td align="center">DATE_ADD(date, INTERVAL expr type)</td><td align="center">返回一个日期&#x2F;时间值加上一个时间间隔expr后的时间值</td></tr><tr><td align="center">DATEDIFF(date1, date2)</td><td align="center">返回起始时间date1和结束时间date2之间的天数</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- DATE_ADD<br>SELECT DATE_ADD(NOW(), INTERVAL 70 YEAR);<br></code></pre></td></tr></table></figure><h3 id="2-4-流程函数"><a href="#2-4-流程函数" class="headerlink" title="2.4 流程函数"></a>2.4 流程函数</h3><ul><li>常用函数：</li></ul><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">IF(value, t, f)</td><td align="center">如果value为true，则返回t，否则返回f</td></tr><tr><td align="center">IFNULL(value1, value2)</td><td align="center">如果value1不为空，返回value1，否则返回value2</td></tr><tr><td align="center">CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td align="center">如果val1为true，返回res1，… 否则返回default默认值</td></tr><tr><td align="center">CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td align="center">如果expr的值等于val1，返回res1，… 否则返回default默认值</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select<br>name,<br>(case when age &gt; 30 then &#x27;中年&#x27; else &#x27;青年&#x27; end)<br>from employee;<br>select<br>name,<br>(case workaddress when &#x27;北京市&#x27; then &#x27;一线城市&#x27; when &#x27;上海市&#x27; then &#x27;一线城市&#x27; else &#x27;二线城市&#x27; end) as &#x27;工作地址&#x27;<br>from employee;<br></code></pre></td></tr></table></figure><h2 id="三-约束"><a href="#三-约束" class="headerlink" title="三.约束"></a>三.约束</h2><ul><li>分类：</li></ul><table><thead><tr><th align="center">约束</th><th align="center">描述</th><th align="center">关键字</th></tr></thead><tbody><tr><td align="center">非空约束</td><td align="center">限制该字段的数据不能为null</td><td align="center">NOT NULL</td></tr><tr><td align="center">唯一约束</td><td align="center">保证该字段的所有数据都是唯一、不重复的</td><td align="center">UNIQUE</td></tr><tr><td align="center">主键约束</td><td align="center">主键是一行数据的唯一标识，要求非空且唯一</td><td align="center">PRIMARY KEY</td></tr><tr><td align="center">默认约束</td><td align="center">保存数据时，如果未指定该字段的值，则采用默认值</td><td align="center">DEFAULT</td></tr><tr><td align="center">检查约束（8.0.1版本后）</td><td align="center">保证字段值满足某一个条件</td><td align="center">CHECK</td></tr><tr><td align="center">外键约束</td><td align="center">用来让两张图的数据之间建立连接，保证数据的一致性和完整性</td><td align="center">FOREIGN KEY</td></tr></tbody></table><p>约束是作用于表中字段上的，可以再创建表&#x2F;修改表的时候添加约束。</p><h3 id="3-1-常用约束"><a href="#3-1-常用约束" class="headerlink" title="3.1 常用约束"></a>3.1 常用约束</h3><table><thead><tr><th align="center">约束条件</th><th align="center">关键字</th></tr></thead><tbody><tr><td align="center">主键</td><td align="center">PRIMARY KEY</td></tr><tr><td align="center">自动增长</td><td align="center">AUTO_INCREMENT</td></tr><tr><td align="center">不为空</td><td align="center">NOT NULL</td></tr><tr><td align="center">唯一</td><td align="center">UNIQUE</td></tr><tr><td align="center">逻辑条件</td><td align="center">CHECK</td></tr><tr><td align="center">默认值</td><td align="center">DEFAULT</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table user(<br>id int primary key auto_increment,<br>name varchar(10) not null unique,<br>age int check(age &gt; 0 and age &lt; 120),<br>status char(1) default &#x27;1&#x27;,<br>gender char(1)<br>);<br></code></pre></td></tr></table></figure><h3 id="3-2-外键约束"><a href="#3-2-外键约束" class="headerlink" title="3.2 外键约束"></a>3.2 外键约束</h3><ul><li>添加外键：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名(<br>字段名 字段类型,<br>...<br>[CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名)<br>);<br>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);<br><br>-- 例子<br>alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id);<br></code></pre></td></tr></table></figure><ul><li>删除外键：<br><code>ALTER TABLE 表名 DROP FOREIGN KEY 外键名;</code></li></ul><h4 id="删除-更新行为"><a href="#删除-更新行为" class="headerlink" title="删除&#x2F;更新行为"></a>删除&#x2F;更新行为</h4><table><thead><tr><th align="center">行为</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">NO ACTION</td><td align="center">当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新（与RESTRICT一致）</td></tr><tr><td align="center">RESTRICT</td><td align="center">当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新（与NO ACTION一致）</td></tr><tr><td align="center">CASCADE</td><td align="center">当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除&#x2F;更新外键在子表中的记录</td></tr><tr><td align="center">SET NULL</td><td align="center">当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null）</td></tr><tr><td align="center">SET DEFAULT</td><td align="center">父表有变更时，子表将外键设为一个默认值（Innodb不支持）</td></tr></tbody></table><ul><li>更改删除&#x2F;更新行为：<br><code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;</code></li></ul><h2 id="四-多表查询"><a href="#四-多表查询" class="headerlink" title="四.多表查询"></a>四.多表查询</h2><h3 id="4-1-多表关系"><a href="#4-1-多表关系" class="headerlink" title="4.1 多表关系"></a>4.1 多表关系</h3><ul><li>一对多（多对一）</li><li>多对多</li><li>一对一</li></ul><h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>案例：部门与员工<br>关系：一个部门对应多个员工，一个员工对应一个部门<br>实现：在多的一方建立外键，指向一的一方的主键</p><h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>案例：学生与课程<br>关系：一个学生可以选多门课程，一门课程也可以供多个学生选修<br>实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>案例：用户与用户详情<br>关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率<br>实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）</p><h3 id="4-2-查询"><a href="#4-2-查询" class="headerlink" title="4.2 查询"></a>4.2 查询</h3><p>合并查询（笛卡尔积，会展示所有组合结果）：<br><code>select * from employee, dept;</code></p><blockquote><p>笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积）</p></blockquote><p>消除无效笛卡尔积：<br><code>select * from employee, dept where employee.dept = dept.id;</code></p><h3 id="4-3-内连接查询"><a href="#4-3-内连接查询" class="headerlink" title="4.3 内连接查询"></a>4.3 内连接查询</h3><p>内连接查询的是两张表交集的部分</p><ul><li><p>隐式内连接：<br><code>SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...;</code></p></li><li><p>显式内连接：<br><code>SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...;</code></p></li></ul><p>显式性能比隐式高</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询员工姓名，及关联的部门的名称<br>-- 隐式<br>select e.name, d.name from employee as e, dept as d where e.dept = d.id;<br>-- 显式<br>select e.name, d.name from employee as e inner join dept as d on e.dept = d.id;<br></code></pre></td></tr></table></figure><h3 id="4-4-外连接查询"><a href="#4-4-外连接查询" class="headerlink" title="4.4 外连接查询"></a>4.4 外连接查询</h3><ul><li><p>左外连接：<br>查询左表所有数据，以及两张表交集部分数据<br><code>SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;</code><br>相当于查询表1的所有数据，包含表1和表2交集部分数据</p></li><li><p>右外连接：<br>查询右表所有数据，以及两张表交集部分数据<br><code>SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...;</code></p></li></ul><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 左<br>select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id;<br>select d.name, e.* from dept d left outer join emp e on e.dept = d.id;  -- 这条语句与下面的语句效果一样<br>-- 右<br>select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id;<br></code></pre></td></tr></table></figure><p>左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept</p><h3 id="4-5-自连接查询"><a href="#4-5-自连接查询" class="headerlink" title="4.5 自连接查询"></a>4.5 自连接查询</h3><p>当前表与自身的连接查询，自连接必须使用表别名</p><p>语法：<br><code>SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;</code></p><p>自连接查询，可以是内连接查询，也可以是外连接查询</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询员工及其所属领导的名字<br>select a.name, b.name from employee a, employee b where a.manager = b.id;<br>-- 没有领导的也查询出来<br>select a.name, b.name from employee a left join employee b on a.manager = b.id;<br></code></pre></td></tr></table></figure><h3 id="4-6-联合查询-union-union-all"><a href="#4-6-联合查询-union-union-all" class="headerlink" title="4.6 联合查询 union, union all"></a>4.6 联合查询 union, union all</h3><p>把多次查询的结果合并，形成一个新的查询集</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 字段列表 FROM 表A ...<br>UNION [ALL]<br>SELECT 字段列表 FROM 表B ...<br></code></pre></td></tr></table></figure><blockquote><p>注意事项：</p><ul><li>UNION ALL 会有重复结果，UNION 不会</li><li>联合查询比使用or效率高，不会使索引失效</li></ul></blockquote><h3 id="4-7-子查询"><a href="#4-7-子查询" class="headerlink" title="4.7 子查询"></a>4.7 子查询</h3><p>SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。<br><code>SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);</code><br><strong>子查询外部的语句可以是 INSERT &#x2F; UPDATE &#x2F; DELETE &#x2F; SELECT 的任何一个</strong></p><p>根据子查询结果可以分为：</p><ul><li>标量子查询（子查询结果为单个值）</li><li>列子查询（子查询结果为一列）</li><li>行子查询（子查询结果为一行）</li><li>表子查询（子查询结果为多行多列）</li></ul><p>根据子查询位置可分为：</p><ul><li>WHERE 之后</li><li>FROM 之后</li><li>SELECT 之后</li></ul><h4 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h4><p>子查询返回的结果是单个值（数字、字符串、日期等）。<br>常用操作符：- &lt; &gt; &gt; &gt;&#x3D; &lt; &lt;&#x3D;</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询销售部所有员工<br>select id from dept where name = &#x27;销售部&#x27;;<br>-- 根据销售部部门ID，查询员工信息<br>select * from employee where dept = 4;<br>-- 合并（子查询）<br>select * from employee where dept = (select id from dept where name = &#x27;销售部&#x27;);<br><br>-- 查询xxx入职之后的员工信息<br>select * from employee where entrydate &gt; (select entrydate from employee where name = &#x27;xxx&#x27;);<br></code></pre></td></tr></table></figure><h4 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h4><p>返回的结果是一列（可以是多行）。</p><p>常用操作符：</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">IN</td><td align="center">在指定的集合范围内，多选一</td></tr><tr><td align="center">NOT IN</td><td align="center">不在指定的集合范围内</td></tr><tr><td align="center">ANY</td><td align="center">子查询返回列表中，有任意一个满足即可</td></tr><tr><td align="center">SOME</td><td align="center">与ANY等同，使用SOME的地方都可以使用ANY</td></tr><tr><td align="center">ALL</td><td align="center">子查询返回列表的所有值都必须满足</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询销售部和市场部的所有员工信息<br>select * from employee where dept in (select id from dept where name = &#x27;销售部&#x27; or name = &#x27;市场部&#x27;);<br>-- 查询比财务部所有人工资都高的员工信息<br>select * from employee where salary &gt; all(select salary from employee where dept = (select id from dept where name = &#x27;财务部&#x27;));<br>-- 查询比研发部任意一人工资高的员工信息<br>select * from employee where salary &gt; any (select salary from employee where dept = (select id from dept where name = &#x27;研发部&#x27;));<br></code></pre></td></tr></table></figure><h4 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h4><p>返回的结果是一行（可以是多列）。<br>常用操作符：&#x3D;, &lt;, &gt;, IN, NOT IN</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询与xxx的薪资及直属领导相同的员工信息<br>select * from employee where (salary, manager) = (12500, 1);<br>select * from employee where (salary, manager) = (select salary, manager from employee where name = &#x27;xxx&#x27;);<br></code></pre></td></tr></table></figure><h4 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h4><p>返回的结果是多行多列<br>常用操作符：IN</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询与xxx1，xxx2的职位和薪资相同的员工<br>select * from employee where (job, salary) in (select job, salary from employee where name = &#x27;xxx1&#x27; or name = &#x27;xxx2&#x27;);<br>-- 查询入职日期是2006-01-01之后的员工，及其部门信息<br>select e.*, d.* from (select * from employee where entrydate &gt; &#x27;2006-01-01&#x27;) as e left join dept as d on e.dept = d.id;<br></code></pre></td></tr></table></figure><h2 id="五-事务"><a href="#五-事务" class="headerlink" title="五.事务"></a>五.事务</h2><p>事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>基本操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 1. 查询张三账户余额<br>select * from account where name = &#x27;张三&#x27;;<br>-- 2. 将张三账户余额-1000<br>update account set money = money - 1000 where name = &#x27;张三&#x27;;<br>-- 此语句出错后张三钱减少但是李四钱没有增加<br>模拟sql语句错误<br>-- 3. 将李四账户余额+1000<br>update account set money = money + 1000 where name = &#x27;李四&#x27;;<br><br>-- 查看事务提交方式<br>SELECT @@AUTOCOMMIT;<br>-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效<br>SET @@AUTOCOMMIT = 0;<br>-- 提交事务<br>COMMIT;<br>-- 回滚事务<br>ROLLBACK;<br><br>-- 设置手动提交后上面代码改为：<br>select * from account where name = &#x27;张三&#x27;;<br>update account set money = money - 1000 where name = &#x27;张三&#x27;;<br>update account set money = money + 1000 where name = &#x27;李四&#x27;;<br>commit;<br></code></pre></td></tr></table></figure><p>操作方式二：</p><p>开启事务：<br><code>START TRANSACTION 或 BEGIN TRANSACTION;</code><br>提交事务：<br><code>COMMIT;</code><br>回滚事务：<br><code>ROLLBACK;</code></p><p>操作实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">start transaction;<br>select * from account where name = &#x27;张三&#x27;;<br>update account set money = money - 1000 where name = &#x27;张三&#x27;;<br>update account set money = money + 1000 where name = &#x27;李四&#x27;;<br>commit;<br></code></pre></td></tr></table></figure><h3 id="5-1-四大特性ACID"><a href="#5-1-四大特性ACID" class="headerlink" title="5.1 四大特性ACID"></a>5.1 四大特性ACID</h3><ul><li>原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败</li><li>一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态</li><li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul><h3 id="5-2-并发事务"><a href="#5-2-并发事务" class="headerlink" title="5.2 并发事务"></a>5.2 并发事务</h3><table><thead><tr><th align="center">问题</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">脏读</td><td align="center">一个事务读到另一个事务还没提交的数据</td></tr><tr><td align="center">不可重复读</td><td align="center">一个事务先后读取同一条记录，但两次读取的数据不同</td></tr><tr><td align="center">幻读</td><td align="center">一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在</td></tr></tbody></table><blockquote><p>这三个问题的详细演示：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd</a> </p></blockquote><p>并发事务隔离级别：</p><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">Read uncommitted</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">Read committed</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">Repeatable Read(默认)</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">Serializable</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><ul><li>√表示在当前隔离级别下该问题会出现</li><li>Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差</li></ul><p>查看事务隔离级别：<br><code>SELECT @@TRANSACTION_ISOLATION;</code><br>设置事务隔离级别：<br><code>SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;;</code><br>SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效</p><h1 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h1><h2 id="一-存储引擎"><a href="#一-存储引擎" class="headerlink" title="一.存储引擎"></a>一.存储引擎</h2><p>MySQL体系结构：</p><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="结构图" title="结构图"><br><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/MySQL%E5%B1%82%E7%BA%A7%E6%8F%8F%E8%BF%B0.png" alt="层级描述" title="层级描述"></p><p>存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。<br>默认存储引擎是InnoDB。</p><p>相关操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询建表语句<br>show create table account;<br>-- 建表时指定存储引擎<br>CREATE TABLE 表名(<br>...<br>) ENGINE=INNODB;<br>-- 查看当前数据库支持的存储引擎<br>show engines;<br></code></pre></td></tr></table></figure><h3 id="1-1-InnoDB"><a href="#1-1-InnoDB" class="headerlink" title="1.1 InnoDB"></a>1.1 InnoDB</h3><p>InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。</p><p>特点：</p><ul><li>DML 操作遵循 ACID 模型，支持<strong>事务</strong></li><li><strong>行级锁</strong>，提高并发访问性能</li><li>支持<strong>外键</strong>约束，保证数据的完整性和正确性</li></ul><p>文件：</p><ul><li>xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。</li></ul><p>参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间</p><p>知识点：</p><p>查看 Mysql 变量：<br><code>show variables like &#39;innodb_file_per_table&#39;;</code></p><p>从idb文件提取表结构数据：<br>（在cmd运行）<br><code>ibd2sdi xxx.ibd</code></p><p>InnoDB 逻辑存储结构：<br><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/InnoDB%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="InnoDB逻辑存储结构" title="InnoDB逻辑存储结构"></p><h3 id="1-2-MyISAM"><a href="#1-2-MyISAM" class="headerlink" title="1.2 MyISAM"></a>1.2 MyISAM</h3><p>MyISAM 是 MySQL 早期的默认存储引擎。</p><p>特点：</p><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li></ul><p>文件：</p><ul><li>xxx.sdi: 存储表结构信息</li><li>xxx.MYD: 存储数据</li><li>xxx.MYI: 存储索引</li></ul><h3 id="1-3-Memory"><a href="#1-3-Memory" class="headerlink" title="1.3 Memory"></a>1.3 Memory</h3><p>Memory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。</p><p>特点：</p><ul><li>存放在内存中，速度快</li><li>hash索引（默认）</li></ul><p>文件：</p><ul><li>xxx.sdi: 存储表结构信息</li></ul><h3 id="1-4-存储引擎特点"><a href="#1-4-存储引擎特点" class="headerlink" title="1.4 存储引擎特点"></a>1.4 存储引擎特点</h3><table><thead><tr><th align="center">特点</th><th align="center">InnoDB</th><th align="center">MyISAM</th><th align="center">Memory</th></tr></thead><tbody><tr><td align="center">存储限制</td><td align="center">64TB</td><td align="center">有</td><td align="center">有</td></tr><tr><td align="center">事务安全</td><td align="center">支持</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">锁机制</td><td align="center">行锁</td><td align="center">表锁</td><td align="center">表锁</td></tr><tr><td align="center">B+tree索引</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">Hash索引</td><td align="center">-</td><td align="center">-</td><td align="center">支持</td></tr><tr><td align="center">全文索引</td><td align="center">支持（5.6版本之后）</td><td align="center">支持</td><td align="center">-</td></tr><tr><td align="center">空间使用</td><td align="center">高</td><td align="center">低</td><td align="center">N&#x2F;A</td></tr><tr><td align="center">内存使用</td><td align="center">高</td><td align="center">低</td><td align="center">中等</td></tr><tr><td align="center">批量插入速度</td><td align="center">低</td><td align="center">高</td><td align="center">高</td></tr><tr><td align="center">支持外键</td><td align="center">支持</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><h3 id="1-5-存储引擎的选择"><a href="#1-5-存储引擎的选择" class="headerlink" title="1.5 存储引擎的选择"></a>1.5 存储引擎的选择</h3><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p><ul><li>InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择</li><li>MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。</li><li>Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性</li></ul><p>电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。</p><h2 id="二-性能分析"><a href="#二-性能分析" class="headerlink" title="二.性能分析"></a>二.性能分析</h2><h3 id="2-1-查看执行频次"><a href="#2-1-查看执行频次" class="headerlink" title="2.1 查看执行频次"></a>2.1 查看执行频次</h3><p>查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：<br><code>SHOW GLOBAL STATUS LIKE &#39;Com_______&#39;;</code> 或者 <code>SHOW SESSION STATUS LIKE &#39;Com_______&#39;;</code><br>例：<code>show global status like &#39;Com_______&#39;</code></p><h3 id="2-2-慢查询日志"><a href="#2-2-慢查询日志" class="headerlink" title="2.2 慢查询日志"></a>2.2 慢查询日志</h3><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。<br>MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：<br>    # 开启慢查询日志开关<br>    slow_query_log&#x3D;1<br>    # 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志<br>    long_query_time&#x3D;2<br>更改后记得重启MySQL服务，日志文件位置：&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;localhost-slow.log</p><p>查看慢查询日志开关状态：<br><code>show variables like &#39;slow_query_log&#39;;</code></p><h3 id="2-3-profile"><a href="#2-3-profile" class="headerlink" title="2.3 profile"></a>2.3 profile</h3><p>show profile 能在做SQL优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：<br><code>SELECT @@have_profiling;</code><br>profiling 默认关闭，可以通过set语句在session&#x2F;global级别开启 profiling：<br><code>SET profiling = 1;</code><br>查看所有语句的耗时：<br><code>show profiles;</code><br>查看指定query_id的SQL语句各个阶段的耗时：<br><code>show profile for query query_id;</code><br>查看指定query_id的SQL语句CPU的使用情况<br><code>show profile cpu for query query_id;</code></p><h3 id="2-4-explain"><a href="#2-4-explain" class="headerlink" title="2.4 explain"></a>2.4 explain</h3><p>EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。<br>语法：<br>    # 直接在select语句之前加上关键字 explain &#x2F; desc<br>​EXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件;</p><p>EXPLAIN 各字段含义：</p><ul><li>id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行）</li><li>select_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT&#x2F;WHERE之后包含了子查询）等</li><li>type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all</li><li>possible_key：可能应用在这张表上的索引，一个或多个</li><li>Key：实际使用的索引，如果为 NULL，则没有使用索引</li><li>Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好</li><li>rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的</li><li>filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好</li></ul><h2 id="三-索引"><a href="#三-索引" class="headerlink" title="三.索引"></a>三.索引</h2><p>索引是帮助 MySQL <strong>高效获取数据</strong>的<strong>数据结构（有序）</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。</p><p>优缺点：</p><p>优点：</p><ul><li>提高数据检索效率，降低数据库的IO成本</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</li></ul><p>缺点：</p><ul><li>索引列也是要占用空间的</li><li>索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE</li></ul><h3 id="3-1-索引结构"><a href="#3-1-索引结构" class="headerlink" title="3.1 索引结构"></a>3.1 索引结构</h3><table><thead><tr><th align="center">索引结构</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">B+Tree</td><td align="center">最常见的索引类型，大部分引擎都支持B+树索引</td></tr><tr><td align="center">Hash</td><td align="center">底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询</td></tr><tr><td align="center">R-Tree(空间索引)</td><td align="center">空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td></tr><tr><td align="center">Full-Text(全文索引)</td><td align="center">是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES</td></tr></tbody></table><table><thead><tr><th align="center">索引</th><th align="center">InnoDB</th><th align="center">MyISAM</th><th align="center">Memory</th></tr></thead><tbody><tr><td align="center">B+Tree索引</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">Hash索引</td><td align="center">不支持</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">R-Tree索引</td><td align="center">不支持</td><td align="center">支持</td><td align="center">不支持</td></tr><tr><td align="center">Full-text</td><td align="center">5.6版本后支持</td><td align="center">支持</td><td align="center">不支持</td></tr></tbody></table><h4 id="3-1-1-B-Tree"><a href="#3-1-1-B-Tree" class="headerlink" title="3.1.1 B-Tree"></a>3.1.1 B-Tree</h4><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="二叉树" title="二叉树"></p><p>二叉树的缺点可以用红黑树来解决：<br><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E7%BA%A2%E9%BB%91%E6%A0%91.png" alt="红黑树" title="红黑树"><br>红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。</p><p>为了解决上述问题，可以使用 B-Tree 结构。<br>B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针）</p><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/B-Tree%E7%BB%93%E6%9E%84.png" alt="B-Tree结构" title="B-Tree结构"></p><blockquote><p>B-Tree 的数据插入过程动画参照：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68</a><br>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p></blockquote><h4 id="3-1-2-B-Tree"><a href="#3-1-2-B-Tree" class="headerlink" title="3.1.2 B+Tree"></a>3.1.2 B+Tree</h4><p>结构图：</p><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/B%E5%8A%A0Tree%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="B+Tree结构图" title="B+Tree结构图"></p><blockquote><p>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p></blockquote><p>与 B-Tree 的区别：</p><ul><li>所有的数据都会出现在叶子节点</li><li>叶子节点形成一个单向链表</li></ul><p>MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。</p><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/MySQL%20B%E5%8A%A0Tree%20%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="MySQL B+Tree 结构图" title="MySQL B+Tree 结构图"></p><h4 id="3-1-3-Hash"><a href="#3-1-3-Hash" class="headerlink" title="3.1.3 Hash"></a>3.1.3 Hash</h4><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。<br>如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Hash%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="Hash索引原理图" title="Hash索引原理图"></p><p>特点：</p><ul><li>Hash索引只能用于对等比较（&#x3D;、in），不支持范围查询（betwwn、&gt;、&lt;、…）</li><li>无法利用索引完成排序操作</li><li>查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引</li></ul><p>存储引擎支持：</p><ul><li>Memory</li><li>InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的</li></ul><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><ol><li>为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？</li></ol><ul><li>相对于二叉树，层级更少，搜索效率高</li><li>对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低</li><li>相对于 Hash 索引，B+Tree 支持范围匹配及排序操作</li></ul><h3 id="3-2-索引分类"><a href="#3-2-索引分类" class="headerlink" title="3.2 索引分类"></a>3.2 索引分类</h3><table><thead><tr><th align="center">分类</th><th align="center">含义</th><th align="center">特点</th><th align="center">关键字</th></tr></thead><tbody><tr><td align="center">主键索引</td><td align="center">针对于表中主键创建的索引</td><td align="center">默认自动创建，只能有一个</td><td align="center">PRIMARY</td></tr><tr><td align="center">唯一索引</td><td align="center">避免同一个表中某数据列中的值重复</td><td align="center">可以有多个</td><td align="center">UNIQUE</td></tr><tr><td align="center">常规索引</td><td align="center">快速定位特定数据</td><td align="center">可以有多个</td><td align="center"></td></tr><tr><td align="center">全文索引</td><td align="center">全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td align="center">可以有多个</td><td align="center">FULLTEXT</td></tr></tbody></table><p>在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><table><thead><tr><th align="center">分类</th><th align="center">含义</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">聚集索引(Clustered Index)</td><td align="center">将数据存储与索引放一块，索引结构的叶子节点保存了行数据</td><td align="center">必须有，而且只有一个</td></tr><tr><td align="center">二级索引(Secondary Index)</td><td align="center">将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td align="center">可以存在多个</td></tr></tbody></table><p>演示图：</p><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E5%A4%A7%E8%87%B4%E5%8E%9F%E7%90%86.png" alt="大致原理" title="大致原理"><br><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E6%BC%94%E7%A4%BA%E5%9B%BE.png" alt="演示图" title="演示图"></p><p>聚集索引选取规则：</p><ul><li>如果存在主键，主键索引就是聚集索引</li><li>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引</li><li>如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引</li></ul><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>1. 以下 SQL 语句，哪个执行效率高？为什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from user where id = 10;<br>select * from user where name = &#x27;Arm&#x27;;<br>-- 备注：id为主键，name字段创建的有索引<br></code></pre></td></tr></table></figure><p>答：第一条语句，因为第二条需要回表查询，相当于两个步骤。</p><p>2. InnoDB 主键索引的 B+Tree 高度为多少？</p><p>答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.<br>可得公式：<code>n * 8 + (n + 1) * 6 = 16 * 1024</code>，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。</p><p>如果树的高度为2，那么他能存储的数据量大概为：<code>1171 * 16 = 18736</code>；<br>如果树的高度为3，那么他能存储的数据量大概为：<code>1171 * 1171 * 16 = 21939856</code>。</p><p>另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。</p><h3 id="3-3-语法"><a href="#3-3-语法" class="headerlink" title="3.3 语法"></a>3.3 语法</h3><p>创建索引：<br><code>CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);</code><br>如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引</p><p>查看索引：<br><code>SHOW INDEX FROM table_name;</code></p><p>删除索引：<br><code>DROP INDEX index_name ON table_name;</code></p><p>案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引<br>create index idx_user_name on tb_user(name);<br>-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引<br>create unique index idx_user_phone on tb_user (phone);<br>-- 为profession, age, status创建联合索引<br>create index idx_user_pro_age_stat on tb_user(profession, age, status);<br>-- 为email建立合适的索引来提升查询效率<br>create index idx_user_email on tb_user(email);<br><br>-- 删除索引<br>drop index idx_user_email on tb_user;<br></code></pre></td></tr></table></figure><h3 id="3-4-使用规则"><a href="#3-4-使用规则" class="headerlink" title="3.4 使用规则"></a>3.4 使用规则</h3><h4 id="3-4-1-最左前缀法则"><a href="#3-4-1-最左前缀法则" class="headerlink" title="3.4.1 最左前缀法则"></a>3.4.1 最左前缀法则</h4><p>如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。<br>如果跳跃某一列，索引将部分失效（后面的字段索引失效）。</p><p>联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。可以用&gt;&#x3D;或者&lt;&#x3D;来规避索引失效问题。</p><h4 id="3-4-2-索引失效情况"><a href="#3-4-2-索引失效情况" class="headerlink" title="3.4.2 索引失效情况"></a>3.4.2 索引失效情况</h4><ol><li>在索引列上进行运算操作，索引将失效。如：<code>explain select * from tb_user where substring(phone, 10, 2) = &#39;15&#39;;</code></li><li>字符串类型字段使用时，不加引号，索引将失效。如：<code>explain select * from tb_user where phone = 17799990015;</code>，此处phone的值没有加引号</li><li>模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：<code>explain select * from tb_user where profession like &#39;%工程&#39;;</code>，前后都有 % 也会失效。</li><li>用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。</li><li>如果 MySQL 评估使用索引比全表更慢，则不使用索引。</li></ol><h4 id="3-4-3-SQL-提示"><a href="#3-4-3-SQL-提示" class="headerlink" title="3.4.3 SQL 提示"></a>3.4.3 SQL 提示</h4><p>是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><p>例如，使用索引：<br><code>explain select * from tb_user use index(idx_user_pro) where profession=&quot;软件工程&quot;;</code><br>不使用哪个索引：<br><code>explain select * from tb_user ignore index(idx_user_pro) where profession=&quot;软件工程&quot;;</code><br>必须使用哪个索引：<br><code>explain select * from tb_user force index(idx_user_pro) where profession=&quot;软件工程&quot;;</code></p><p>use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。</p><h4 id="3-4-4-覆盖索引-回表查询"><a href="#3-4-4-覆盖索引-回表查询" class="headerlink" title="3.4.4 覆盖索引&amp;回表查询"></a>3.4.4 覆盖索引&amp;回表查询</h4><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。</p><p>explain 中 extra 字段含义：<br><code>using index condition</code>：查找使用了索引，但是需要回表查询数据<br><code>using where; using index;</code>：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询</p><p>如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如<code>select id, name from xxx where name=&#39;xxx&#39;;</code>，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如<code>select id, name, gender from xxx where name=&#39;xxx&#39;;</code></p><p>所以尽量不要用<code>select *</code>，容易出现回表查询，降低效率，除非有联合索引包含了所有字段</p><p>面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：<br><code>select id, username, password from tb_user where username=&#39;itcast&#39;;</code></p><p>解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引</p><h4 id="3-4-5-前缀索引"><a href="#3-4-5-前缀索引" class="headerlink" title="3.4.5 前缀索引"></a>3.4.5 前缀索引</h4><p>当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p>语法：<code>create index idx_xxxx on table_name(columnn(n));</code><br>前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。<br>求选择性公式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select count(distinct email) / count(*) from tb_user;<br>select count(distinct substring(email, 1, 5)) / count(*) from tb_user;<br></code></pre></td></tr></table></figure><p>show index 里面的sub_part可以看到接取的长度</p><h4 id="3-4-6-单列索引-联合索引"><a href="#3-4-6-单列索引-联合索引" class="headerlink" title="3.4.6 单列索引&amp;联合索引"></a>3.4.6 单列索引&amp;联合索引</h4><p>单列索引：即一个索引只包含单个列<br>联合索引：即一个索引包含了多个列<br>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p><p>单列索引情况：<br><code>explain select id, phone, name from tb_user where phone = &#39;17799990010&#39; and name = &#39;韩信&#39;;</code><br>这句只会用到phone索引字段</p><h5 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询</li></ul><h3 id="3-5-设计原则"><a href="#3-5-设计原则" class="headerlink" title="3.5 设计原则"></a>3.5 设计原则</h3><ol><li>针对于数据量较大，且查询比较频繁的表建立索引</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li><li>如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</li></ol><h2 id="四-SQL-优化"><a href="#四-SQL-优化" class="headerlink" title="四.SQL 优化"></a>四.SQL 优化</h2><h3 id="4-1-插入数据"><a href="#4-1-插入数据" class="headerlink" title="4.1 插入数据"></a>4.1 插入数据</h3><p>普通插入：</p><ol><li>采用批量插入（一次插入的数据不建议超过1000条）</li><li>手动提交事务</li><li>主键顺序插入</li></ol><p>大批量插入：<br>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 客户端连接服务端时，加上参数 --local-infile（这一行在bash/cmd界面输入）<br>mysql --local-infile -u root -p<br># 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关<br>set global local_infile = 1;<br>select @@local_infile;<br># 执行load指令将准备好的数据，加载到表结构中<br>load data local infile &#x27;/root/sql1.log&#x27; into table &#x27;tb_user&#x27; fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27;;<br></code></pre></td></tr></table></figure><h3 id="4-2-主键优化"><a href="#4-2-主键优化" class="headerlink" title="4.2 主键优化"></a>4.2 主键优化</h3><p>数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT）</p><p>页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。<br>页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。</p><p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定</p><blockquote><p>文字说明不够清晰明了，具体可以看视频里的PPT演示过程：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90</a></p></blockquote><p>主键设计原则：</p><ul><li>满足业务需求的情况下，尽量降低主键的长度</li><li>插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键</li><li>尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号</li><li>业务操作时，避免对主键的修改</li></ul><h3 id="4-3-order-by优化"><a href="#4-3-order-by优化" class="headerlink" title="4.3 order by优化"></a>4.3 order by优化</h3><ol><li>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序</li><li>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高</li></ol><p>如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是<code>Using index, Using filesort</code>，如果要优化掉Using filesort，则需要另外再创建一个索引，如：<code>create index idx_user_age_phone_ad on tb_user(age asc, phone desc);</code>，此时使用<code>select id, age, phone from tb_user order by age asc, phone desc;</code>会全部走索引</p><p>总结：</p><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li><li>尽量使用覆盖索引</li><li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）</li><li>如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）</li></ul><h3 id="4-5-group-by优化"><a href="#4-5-group-by优化" class="headerlink" title="4.5 group by优化"></a>4.5 group by优化</h3><ul><li>在分组操作时，可以通过索引来提高效率</li><li>分组操作时，索引的使用也是满足最左前缀法则的</li></ul><p>如索引为<code>idx_user_pro_age_stat</code>，则句式可以是<code>select ... where profession order by age</code>，这样也符合最左前缀法则</p><h3 id="4-6-limit优化"><a href="#4-6-limit优化" class="headerlink" title="4.6 limit优化"></a>4.6 limit优化</h3><p>常见的问题如<code>limit 2000000, 10</code>，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。<br>优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 此语句耗时很长<br>select * from tb_sku limit 9000000, 10;<br>-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询<br>select id from tb_sku order by id limit 9000000, 10;<br>-- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit<br>-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);<br>-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度<br>select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id;<br></code></pre></td></tr></table></figure><h3 id="4-7-count优化"><a href="#4-7-count优化" class="headerlink" title="4.7 count优化"></a>4.7 count优化</h3><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（前提是不适用where）；<br>InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。<br>优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis</p><p>count的几种用法：</p><ul><li>如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值</li><li>用法：count(*)、count(主键)、count(字段)、count(1)</li><li>count(主键)跟count(*)一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count(*)一样；count(null)返回0</li></ul><p>各种用法的性能：</p><ul><li>count(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空）</li><li>count(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加</li><li>count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加</li><li>count(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加</li></ul><p>按效率排序：count(字段) &lt; count(主键) &lt; count(1) &lt; count(*)，所以尽量使用 count(*)</p><h3 id="4-8-update优化（避免行锁升级为表锁）"><a href="#4-8-update优化（避免行锁升级为表锁）" class="headerlink" title="4.8 update优化（避免行锁升级为表锁）"></a>4.8 update优化（避免行锁升级为表锁）</h3><p>InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p><p>如以下两条语句：<br><code>update student set no = &#39;123&#39; where id = 1;</code>，这句由于id有主键索引，所以只会锁这一行；<br><code>update student set no = &#39;123&#39; where name = &#39;test&#39;;</code>，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引</p><h1 id="数据类型汇总"><a href="#数据类型汇总" class="headerlink" title="数据类型汇总"></a>数据类型汇总</h1><h2 id="一-整型"><a href="#一-整型" class="headerlink" title="一.整型"></a>一.整型</h2><table><thead><tr><th align="center">类型名称</th><th align="center">取值范围</th><th align="center">大小</th></tr></thead><tbody><tr><td align="center">TINYINT</td><td align="center">-128〜127</td><td align="center">1个字节</td></tr><tr><td align="center">SMALLINT</td><td align="center">-32768〜32767</td><td align="center">2个宇节</td></tr><tr><td align="center">MEDIUMINT</td><td align="center">-8388608〜8388607</td><td align="center">3个字节</td></tr><tr><td align="center">INT (INTEGHR)</td><td align="center">-2147483648〜2147483647</td><td align="center">4个字节</td></tr><tr><td align="center">BIGINT</td><td align="center">-9223372036854775808〜9223372036854775807</td><td align="center">8个字节</td></tr></tbody></table><p>无符号在数据类型后加 unsigned 关键字。</p><h2 id="二-浮点型"><a href="#二-浮点型" class="headerlink" title="二.浮点型"></a>二.浮点型</h2><table><thead><tr><th align="center">类型名称</th><th align="center">说明</th><th align="center">存储需求</th></tr></thead><tbody><tr><td align="center">FLOAT</td><td align="center">单精度浮点数</td><td align="center">4 个字节</td></tr><tr><td align="center">DOUBLE</td><td align="center">双精度浮点数</td><td align="center">8 个字节</td></tr><tr><td align="center">DECIMAL (M, D)，DEC</td><td align="center">压缩的“严格”定点数</td><td align="center">M+2 个字节</td></tr></tbody></table><h2 id="三-日期和时间"><a href="#三-日期和时间" class="headerlink" title="三.日期和时间"></a>三.日期和时间</h2><table><thead><tr><th align="center">类型名称</th><th align="center">日期格式</th><th align="center">日期范围</th><th align="center">存储需求</th></tr></thead><tbody><tr><td align="center">YEAR</td><td align="center">YYYY</td><td align="center">1901 ~ 2155</td><td align="center">1 个字节</td></tr><tr><td align="center">TIME</td><td align="center">HH:MM:SS</td><td align="center">-838:59:59 ~ 838:59:59</td><td align="center">3 个字节</td></tr><tr><td align="center">DATE</td><td align="center">YYYY-MM-DD</td><td align="center">1000-01-01 ~ 9999-12-3</td><td align="center">3 个字节</td></tr><tr><td align="center">DATETIME</td><td align="center">YYYY-MM-DD HH:MM:SS</td><td align="center">1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td><td align="center">8 个字节</td></tr><tr><td align="center">TIMESTAMP</td><td align="center">YYYY-MM-DD HH:MM:SS</td><td align="center">1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC</td><td align="center">4 个字节</td></tr></tbody></table><h2 id="四-字符串"><a href="#四-字符串" class="headerlink" title="四.字符串"></a>四.字符串</h2><table><thead><tr><th align="center">类型名称</th><th align="center">说明</th><th align="center">存储需求</th></tr></thead><tbody><tr><td align="center">CHAR(M)</td><td align="center">固定长度非二进制字符串</td><td align="center">M 字节，1&lt;&#x3D;M&lt;&#x3D;255</td></tr><tr><td align="center">VARCHAR(M)</td><td align="center">变长非二进制字符串</td><td align="center">L+1字节，在此，L&lt; &#x3D; M和 1&lt;&#x3D;M&lt;&#x3D;255</td></tr><tr><td align="center">TINYTEXT</td><td align="center">非常小的非二进制字符串</td><td align="center">L+1字节，在此，L&lt;2^8</td></tr><tr><td align="center">TEXT</td><td align="center">小的非二进制字符串</td><td align="center">L+2字节，在此，L&lt;2^16</td></tr><tr><td align="center">MEDIUMTEXT</td><td align="center">中等大小的非二进制字符串</td><td align="center">L+3字节，在此，L&lt;2^24</td></tr><tr><td align="center">LONGTEXT</td><td align="center">大的非二进制字符串</td><td align="center">L+4字节，在此，L&lt;2^32</td></tr><tr><td align="center">ENUM</td><td align="center">枚举类型，只能有一个枚举字符串值</td><td align="center">1或2个字节，取决于枚举值的数目 (最大值为65535)</td></tr><tr><td align="center">SET</td><td align="center">一个设置，字符串对象可以有零个或 多个SET成员</td><td align="center">1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员）</td></tr></tbody></table><h2 id="五-二进制类型"><a href="#五-二进制类型" class="headerlink" title="五.二进制类型"></a>五.二进制类型</h2><table><thead><tr><th align="center">类型名称</th><th align="center">说明</th><th align="center">存储需求</th></tr></thead><tbody><tr><td align="center">BIT(M)</td><td align="center">位字段类型</td><td align="center">大约 (M+7)&#x2F;8 字节</td></tr><tr><td align="center">BINARY(M)</td><td align="center">固定长度二进制字符串</td><td align="center">M 字节</td></tr><tr><td align="center">VARBINARY (M)</td><td align="center">可变长度二进制字符串</td><td align="center">M+1 字节</td></tr><tr><td align="center">TINYBLOB (M)</td><td align="center">非常小的BLOB</td><td align="center">L+1 字节，在此，L&lt;2^8</td></tr><tr><td align="center">BLOB (M)</td><td align="center">小 BLOB</td><td align="center">L+2 字节，在此，L&lt;2^16</td></tr><tr><td align="center">MEDIUMBLOB (M)</td><td align="center">中等大小的BLOB</td><td align="center">L+3 字节，在此，L&lt;2^24</td></tr><tr><td align="center">LONGBLOB (M)</td><td align="center">非常大的BLOB</td><td align="center">L+4 字节，在此，L&lt;2^32</td></tr></tbody></table><h1 id="权限一览表"><a href="#权限一览表" class="headerlink" title="权限一览表"></a>权限一览表</h1><blockquote><p>具体权限的作用详见<a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html" title="官方文档">官方文档</a></p></blockquote><p>GRANT 和 REVOKE 允许的静态权限</p><table><thead><tr><th align="center">Privilege</th><th align="center">Grant Table Column</th><th align="center">Context</th></tr></thead><tbody><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_all"><code>ALL [PRIVILEGES]</code></a></td><td align="center">Synonym for “all privileges”</td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter"><code>ALTER</code></a></td><td align="center"><code>Alter_priv</code></td><td align="center">Tables</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter-routine"><code>ALTER ROUTINE</code></a></td><td align="center"><code>Alter_routine_priv</code></td><td align="center">Stored routines</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create"><code>CREATE</code></a></td><td align="center"><code>Create_priv</code></td><td align="center">Databases, tables, or indexes</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-role"><code>CREATE ROLE</code></a></td><td align="center"><code>Create_role_priv</code></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-routine"><code>CREATE ROUTINE</code></a></td><td align="center"><code>Create_routine_priv</code></td><td align="center">Stored routines</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-tablespace"><code>CREATE TABLESPACE</code></a></td><td align="center"><code>Create_tablespace_priv</code></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-temporary-tables"><code>CREATE TEMPORARY TABLES</code></a></td><td align="center"><code>Create_tmp_table_priv</code></td><td align="center">Tables</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-user"><code>CREATE USER</code></a></td><td align="center"><code>Create_user_priv</code></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-view"><code>CREATE VIEW</code></a></td><td align="center"><code>Create_view_priv</code></td><td align="center">Views</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_delete"><code>DELETE</code></a></td><td align="center"><code>Delete_priv</code></td><td align="center">Tables</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop"><code>DROP</code></a></td><td align="center"><code>Drop_priv</code></td><td align="center">Databases, tables, or views</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop-role"><code>DROP ROLE</code></a></td><td align="center"><code>Drop_role_priv</code></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_event"><code>EVENT</code></a></td><td align="center"><code>Event_priv</code></td><td align="center">Databases</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_execute"><code>EXECUTE</code></a></td><td align="center"><code>Execute_priv</code></td><td align="center">Stored routines</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_file"><code>FILE</code></a></td><td align="center"><code>File_priv</code></td><td align="center">File access on server host</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_grant-option"><code>GRANT OPTION</code></a></td><td align="center"><code>Grant_priv</code></td><td align="center">Databases, tables, or stored routines</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_index"><code>INDEX</code></a></td><td align="center"><code>Index_priv</code></td><td align="center">Tables</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_insert"><code>INSERT</code></a></td><td align="center"><code>Insert_priv</code></td><td align="center">Tables or columns</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_lock-tables"><code>LOCK TABLES</code></a></td><td align="center"><code>Lock_tables_priv</code></td><td align="center">Databases</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_process"><code>PROCESS</code></a></td><td align="center"><code>Process_priv</code></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_proxy"><code>PROXY</code></a></td><td align="center">See <code>proxies_priv</code> table</td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_references"><code>REFERENCES</code></a></td><td align="center"><code>References_priv</code></td><td align="center">Databases or tables</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_reload"><code>RELOAD</code></a></td><td align="center"><code>Reload_priv</code></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-client"><code>REPLICATION CLIENT</code></a></td><td align="center"><code>Repl_client_priv</code></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave"><code>REPLICATION SLAVE</code></a></td><td align="center"><code>Repl_slave_priv</code></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_select"><code>SELECT</code></a></td><td align="center"><code>Select_priv</code></td><td align="center">Tables or columns</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-databases"><code>SHOW DATABASES</code></a></td><td align="center"><code>Show_db_priv</code></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-view"><code>SHOW VIEW</code></a></td><td align="center"><code>Show_view_priv</code></td><td align="center">Views</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_shutdown"><code>SHUTDOWN</code></a></td><td align="center"><code>Shutdown_priv</code></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_super"><code>SUPER</code></a></td><td align="center"><code>Super_priv</code></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_trigger"><code>TRIGGER</code></a></td><td align="center"><code>Trigger_priv</code></td><td align="center">Tables</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_update"><code>UPDATE</code></a></td><td align="center"><code>Update_priv</code></td><td align="center">Tables or columns</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_usage"><code>USAGE</code></a></td><td align="center">Synonym for “no privileges”</td><td align="center">Server administration</td></tr></tbody></table><p>GRANT 和 REVOKE 允许的动态权限</p><table><thead><tr><th align="center">Privilege</th><th align="center">Context</th></tr></thead><tbody><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_application-password-admin"><code>APPLICATION_PASSWORD_ADMIN</code></a></td><td align="center">Dual password administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_audit-abort-exempt"><code>AUDIT_ABORT_EXEMPT</code></a></td><td align="center">Allow queries blocked by audit log filter</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_audit-admin"><code>AUDIT_ADMIN</code></a></td><td align="center">Audit log administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_authentication-policy-admin"><code>AUTHENTICATION_POLICY_ADMIN</code></a></td><td align="center">Authentication administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_backup-admin"><code>BACKUP_ADMIN</code></a></td><td align="center">Backup administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_binlog-admin"><code>BINLOG_ADMIN</code></a></td><td align="center">Backup and Replication administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_binlog-encryption-admin"><code>BINLOG_ENCRYPTION_ADMIN</code></a></td><td align="center">Backup and Replication administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_clone-admin"><code>CLONE_ADMIN</code></a></td><td align="center">Clone administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_connection-admin"><code>CONNECTION_ADMIN</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_encryption-key-admin"><code>ENCRYPTION_KEY_ADMIN</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-admin"><code>FIREWALL_ADMIN</code></a></td><td align="center">Firewall administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-exempt"><code>FIREWALL_EXEMPT</code></a></td><td align="center">Firewall administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-user"><code>FIREWALL_USER</code></a></td><td align="center">Firewall administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-optimizer-costs"><code>FLUSH_OPTIMIZER_COSTS</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-status"><code>FLUSH_STATUS</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-tables"><code>FLUSH_TABLES</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-user-resources"><code>FLUSH_USER_RESOURCES</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-admin"><code>GROUP_REPLICATION_ADMIN</code></a></td><td align="center">Replication administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-stream"><code>GROUP_REPLICATION_STREAM</code></a></td><td align="center">Replication administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_innodb-redo-log-archive"><code>INNODB_REDO_LOG_ARCHIVE</code></a></td><td align="center">Redo log archiving administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_ndb-stored-user"><code>NDB_STORED_USER</code></a></td><td align="center">NDB Cluster</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_passwordless-user-admin"><code>PASSWORDLESS_USER_ADMIN</code></a></td><td align="center">Authentication administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_persist-ro-variables-admin"><code>PERSIST_RO_VARIABLES_ADMIN</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-applier"><code>REPLICATION_APPLIER</code></a></td><td align="center"><code>PRIVILEGE_CHECKS_USER</code> for a replication channel</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave-admin"><code>REPLICATION_SLAVE_ADMIN</code></a></td><td align="center">Replication administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_resource-group-admin"><code>RESOURCE_GROUP_ADMIN</code></a></td><td align="center">Resource group administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_resource-group-user"><code>RESOURCE_GROUP_USER</code></a></td><td align="center">Resource group administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_role-admin"><code>ROLE_ADMIN</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_session-variables-admin"><code>SESSION_VARIABLES_ADMIN</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_set-user-id"><code>SET_USER_ID</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-routine"><code>SHOW_ROUTINE</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-user"><code>SYSTEM_USER</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-variables-admin"><code>SYSTEM_VARIABLES_ADMIN</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_table-encryption-admin"><code>TABLE_ENCRYPTION_ADMIN</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_version-token-admin"><code>VERSION_TOKEN_ADMIN</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_xa-recover-admin"><code>XA_RECOVER_ADMIN</code></a></td><td align="center">Server administration</td></tr></tbody></table><h1 id="图形化界面工具"><a href="#图形化界面工具" class="headerlink" title="图形化界面工具"></a>图形化界面工具</h1><ul><li>Workbench(免费): <a href="http://dev.mysql.com/downloads/workbench/">http://dev.mysql.com/downloads/workbench/</a></li><li>navicat(收费，试用版30天): <a href="https://www.navicat.com/en/download/navicat-for-mysql">https://www.navicat.com/en/download/navicat-for-mysql</a></li><li>Sequel Pro(开源免费，仅支持Mac OS): <a href="http://www.sequelpro.com/">http://www.sequelpro.com/</a></li><li>HeidiSQL(免费): <a href="http://www.heidisql.com/">http://www.heidisql.com/</a></li><li>phpMyAdmin(免费): <a href="https://www.phpmyadmin.net/">https://www.phpmyadmin.net/</a></li><li>SQLyog: <a href="https://sqlyog.en.softonic.com/">https://sqlyog.en.softonic.com/</a></li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><ol><li>在SQL语句之后加上<code>\G</code>会将结果的表格形式转换成行文本形式</li><li>查看Mysql数据库占用空间：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT table_schema &quot;Database Name&quot;<br>     , SUM(data_length + index_length) / (1024 * 1024) &quot;Database Size in MB&quot;<br>FROM information_schema.TABLES<br>GROUP BY table_schema;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>MySql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常用Linux命令</title>
    <link href="/2022/07/29/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/07/29/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="常用Linux命令"><a href="#常用Linux命令" class="headerlink" title="常用Linux命令"></a>常用Linux命令</h1><h2 id="一-目录操作"><a href="#一-目录操作" class="headerlink" title="一.目录操作"></a>一.目录操作</h2><h3 id="1-1-基本命令"><a href="#1-1-基本命令" class="headerlink" title="1.1 基本命令"></a>1.1 基本命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">pwd # 查看当前⼯作⽬录<br>clear # 清除屏幕<br>cd ~ # 当前⽤户⽬录<br>cd / # 根⽬录<br>cd - # 上⼀次访问的⽬录<br>cd .. # 上⼀级⽬录<br></code></pre></td></tr></table></figure><h3 id="1-2-查看目录内信息"><a href="#1-2-查看目录内信息" class="headerlink" title="1.2 查看目录内信息"></a>1.2 查看目录内信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ll # 查看当前⽬录下内容（LL的⼩写）<br></code></pre></td></tr></table></figure><h3 id="1-3-创建目录"><a href="#1-3-创建目录" class="headerlink" title="1.3 创建目录"></a>1.3 创建目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir aaa  # 在当前⽬录下创建aaa⽬录，相对路径；<br>mkdir ./bbb  # 在当前⽬录下创建bbb⽬录，相对路径；<br>mkdir /ccc  # 在根⽬录下创建ccc⽬录，绝对路径；<br>mkdir -p temp/nginx  # 递归创建目录（会创建⾥⾯没有的⽬录⽂件夹）<br></code></pre></td></tr></table></figure><h3 id="1-4-搜索命令"><a href="#1-4-搜索命令" class="headerlink" title="1.4 搜索命令"></a>1.4 搜索命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">find / -name &#x27;b&#x27; # 查询根⽬录下（包括⼦⽬录），名以b的⽬录和⽂件；<br>find / -name &#x27;b*&#x27; # 查询根⽬录下（包括⼦⽬录），名以b开头的⽬录和⽂件；<br></code></pre></td></tr></table></figure><h3 id="1-5-重命名"><a href="#1-5-重命名" class="headerlink" title="1.5 重命名"></a>1.5 重命名</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv 原先⽬录 ⽂件的名称 # 举例：mv tomcat001 tomcat<br></code></pre></td></tr></table></figure><h3 id="1-6-剪切命令"><a href="#1-6-剪切命令" class="headerlink" title="1.6 剪切命令"></a>1.6 剪切命令</h3><blockquote><p>有⽬录剪切到制定⽬录下，没有的话剪切为指定⽬录</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv /aaa /bbb# 将根⽬录下的aaa⽬录，移动到bbb⽬录下，在bbb，麚也叫aaa⽬录；<br>mv bbbb usr/bbb # 将当前⽬录下的bbbb⽬录，移动到usr⽬录下，并且修改名称为bbb；<br>mv bbb usr/aaa # 将当前⽬录下的bbbb⽬录，移动到usr⽬录下，并且修改名称为aaa；<br></code></pre></td></tr></table></figure><h3 id="1-6-复制目录"><a href="#1-6-复制目录" class="headerlink" title="1.6 复制目录"></a>1.6 复制目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp -r /aaa /bbb # 将/⽬录下的aaa⽬录复制到/bbb⽬录下，在/bbb⽬录下的名称为aaa<br>cp -r /aaa /bbb/aaa # 将/⽬录下的aa⽬录复制到/bbb⽬录下，且修改名为aaa;<br></code></pre></td></tr></table></figure><h3 id="1-7-删除目录"><a href="#1-7-删除目录" class="headerlink" title="1.7 删除目录"></a>1.7 删除目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -r /bbb # 普通删除。会询问你是否删除每⼀个⽂件<br>rm -rf /bbb  # 强制删除/⽬录下的bbb⽬录。如果bbb⽬录中的⼦⽬录均被强制删除，不会提示<br></code></pre></td></tr></table></figure><h2 id="二-文件操作"><a href="#二-文件操作" class="headerlink" title="二.文件操作"></a>二.文件操作</h2><h3 id="2-1-删除操作"><a href="#2-1-删除操作" class="headerlink" title="2.1 删除操作"></a>2.1 删除操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -r a.java # 删除当前⽬录下的a.java⽂件（每次回询问是否删除y：同意）<br></code></pre></td></tr></table></figure><h3 id="2-2-强制删除"><a href="#2-2-强制删除" class="headerlink" title="2.2 强制删除"></a>2.2 强制删除</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -rf a.java # 强制删除当前⽬录下的a.java⽂件<br>rm -rf ./a* # 强制删除当前⽬录下以a开头的所有⽂件；<br>rm -rf ./* # 强制删除当前⽬录下所有⽂件（慎⽤）；<br></code></pre></td></tr></table></figure><h3 id="2-3-创建文件"><a href="#2-3-创建文件" class="headerlink" title="2.3 创建文件"></a>2.3 创建文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch 文件名<br></code></pre></td></tr></table></figure><h3 id="2-4-递归删除-pyc格式的文件"><a href="#2-4-递归删除-pyc格式的文件" class="headerlink" title="2.4 递归删除.pyc格式的文件"></a>2.4 递归删除.pyc格式的文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -name &#x27;*.pyc&#x27; -exec rm -rf &#123;&#125; \;<br></code></pre></td></tr></table></figure><h3 id="2-5-打印当前文件夹下指定大小的文件"><a href="#2-5-打印当前文件夹下指定大小的文件" class="headerlink" title="2.5 打印当前文件夹下指定大小的文件"></a>2.5 打印当前文件夹下指定大小的文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -name &quot;*&quot; -size 145800c -print;<br></code></pre></td></tr></table></figure><h3 id="2-6-递归删除指定大小的⽂件-145800）"><a href="#2-6-递归删除指定大小的⽂件-145800）" class="headerlink" title="2.6 递归删除指定大小的⽂件(145800）"></a>2.6 递归删除指定大小的⽂件(145800）</h3><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">find</span> . -<span class="hljs-built_in">name</span> <span class="hljs-string">&quot;*&quot;</span> -<span class="hljs-built_in">size</span> <span class="hljs-number">145800</span>c -<span class="hljs-built_in">exec</span> rm -rf &#123;&#125; \;<br></code></pre></td></tr></table></figure><h3 id="2-7-递归删除指定大小的⽂件，并打印出来"><a href="#2-7-递归删除指定大小的⽂件，并打印出来" class="headerlink" title="2.7 递归删除指定大小的⽂件，并打印出来"></a>2.7 递归删除指定大小的⽂件，并打印出来</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -name &quot;*&quot; -size 145800c -print -exec rm -rf &#123;&#125; \;<br></code></pre></td></tr></table></figure><blockquote><ul><li>“.” 表示从当前⽬录开始递归查找</li><li>“ -name ‘*.exe’ “ 根据名称来查找，要查找所有以.exe结尾的⽂件夹或者⽂件</li><li>“ -type f “ 查找的类型为⽂件</li><li>“-print” 输出查找的⽂件⽬录名</li><li>-size 145800c 指定⽂件的⼤⼩ </li><li>-exec rm -rf {} ; 递归删除（前⾯查询出来的结果）</li></ul></blockquote><p>split命令：</p><p>可以将一个大文件分割成若干个小文件，又是需要将文件分割成更小的片段，比如为提高可读性，生成日志等。</p><blockquote><ul><li>-b：值为每⼀输出档案的⼤⼩，单位为 byte</li><li>-C：每⼀输出档中，单⾏的最⼤ byte 数</li><li>-d：使⽤数字作为后缀 </li><li>-l：值为每⼀输出档的⾏数⼤⼩</li><li>-a：指定后缀⻓度(默认为2)</li></ul></blockquote><p>举例：</p><ol><li>使⽤split命令将上⾯创建的date.file⽂件分割成⼤⼩为10KB的⼩⽂件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">split -b 10k date.file<br></code></pre></td></tr></table></figure><ol start="2"><li>⽂件被分割成多个带有字⺟的后缀⽂件，如果想⽤数字后缀可使⽤-d参数，同时可以使⽤-a length来指定后缀的⻓度</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">split -b 10k date.file -d -a 3<br></code></pre></td></tr></table></figure><ol start="3"><li>为分割后的⽂件指定⽂件名的前缀</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">split -b 10k date.file -d -a 3 split_file<br></code></pre></td></tr></table></figure><ol start="4"><li>使⽤-l选项根据⽂件的⾏数来分割⽂件，例如把⽂件分割成每个包含10⾏的⼩⽂件：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">plit -l 10 date.file<br></code></pre></td></tr></table></figure><h2 id="三-⽂件内容操作（查看⽇志，更改配置⽂件）"><a href="#三-⽂件内容操作（查看⽇志，更改配置⽂件）" class="headerlink" title="三.⽂件内容操作（查看⽇志，更改配置⽂件）"></a>三.⽂件内容操作（查看⽇志，更改配置⽂件）</h2><h3 id="3-1-修改文件内容"><a href="#3-1-修改文件内容" class="headerlink" title="3.1 修改文件内容"></a>3.1 修改文件内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim a.java  # 进⼊⼀般模式<br>i(按键)# 进⼊插⼊模式(编辑模式)<br>ESC(按键) # 退出<br>:wq # 保存退出（shift+：调起输⼊框）<br>:q！      # 不保存退出（shift+：调起输⼊框）（内容更改）<br>:q  # 不保存退出（shift+：调起输⼊框）（没有内容更改）<br></code></pre></td></tr></table></figure><h3 id="3-2-查看文件内容"><a href="#3-2-查看文件内容" class="headerlink" title="3.2 查看文件内容"></a>3.2 查看文件内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat a.java # 查看a.java⽂件的最后⼀⻚内容；<br>more a.java # 从第⼀⻚开始查看a.java⽂件内容，按回⻋键⼀⾏⼀⾏进⾏查看，<br>     # 空格键⼀⻚⼀⻚进⾏查看，q退出；<br>less a.java# 从第⼀⻚开始查看a.java⽂件内容，按回⻋键⼀⾏⼀⾏的看，<br>     # 按空格键⼀⻚⼀⻚的看，⽀持使⽤PageDown和PageUp翻⻚，q退出；<br></code></pre></td></tr></table></figure><p>总结下more和less的区别：</p><blockquote><ol><li>less可以按键盘上下⽅向键显示上下内容,more不能通过上下⽅向键控制显示 </li><li>less不必读整个⽂件，加载速度会⽐more更快</li><li>less退出后shell不会留下刚显示的内容,⽽more退出后会在shell上留下刚显示的内容</li><li>more不能后退.</li></ol></blockquote><h3 id="3-3-查看前后行内容"><a href="#3-3-查看前后行内容" class="headerlink" title="3.3 查看前后行内容"></a>3.3 查看前后行内容</h3><p>实时查看文件的后几行（查询日志文件更方便）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tail -f a.java # 查看a.java⽂件的后10⾏内容；<br></code></pre></td></tr></table></figure><p>前后几行查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">head a.java # 查看a.java⽂件的前10⾏内容（默认是显示十行）<br>tail -f a.java # 查看a.java⽂件的后10⾏内容（默认是显示十行）<br>head -n 7 a.java # 查看a.java⽂件的前7⾏内容<br>tail -n 7 a.java # 查看a.java⽂件的后7⾏内容<br></code></pre></td></tr></table></figure><h3 id="3-4-文件内部搜索指定内容"><a href="#3-4-文件内部搜索指定内容" class="headerlink" title="3.4 文件内部搜索指定内容"></a>3.4 文件内部搜索指定内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep under 123.txt # 在123.txt⽂件中搜索under字符串，⼤⼩写敏感，显示⾏；<br>grep -n under 123.txt # 在123.txt⽂件中搜索under字符串，⼤⼩写敏感，显示⾏及⾏号<br>grep -v under 123.txt # 在123.txt⽂件中搜索under字符串，⼤⼩写敏感，显示没搜索到的⾏<br>grep -i under 123.txt # 在123.txt⽂件中搜索under字符串，⼤⼩写敏感，显示⾏<br>grep -ni under 123.txt  # 在123.txt⽂件中搜索under字符串，⼤⼩写敏感，显示⾏及⾏号<br></code></pre></td></tr></table></figure><h3 id="3-5-终止操作指令"><a href="#3-5-终止操作指令" class="headerlink" title="3.5 终止操作指令"></a>3.5 终止操作指令</h3><p>Ctrl+c 和 Ctrl+z 都是中断命令，但是作⽤却不⼀样</p><blockquote><ol><li><p>Ctrl+C扮演类似的⻆⾊，强制中断程序的执⾏</p></li><li><p>Ctrl+Z就扮演了类似的⻆⾊，将任务中断，但是任务并没有结束，在进程中只是维持挂起的状态，⽤户可以使⽤ fg&#x2F;bg操作前台或后台的任务，fg命令重新启动前台被中断的任务，bg命令把被中断的任务放在后台执⾏</p></li></ol></blockquote><h3 id="3-6-重定向功能"><a href="#3-6-重定向功能" class="headerlink" title="3.6 重定向功能"></a>3.6 重定向功能</h3><p>可以使⽤ &gt; 或 &lt; 将命令的输出的命令重定向到test.txt⽂件中（没有则创建⼀个）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &#x27;Hello World&#x27; &gt; /root/test.txt<br></code></pre></td></tr></table></figure><h2 id="四-系统⽇志位置"><a href="#四-系统⽇志位置" class="headerlink" title="四.系统⽇志位置"></a>四.系统⽇志位置</h2><p>汇总日志信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /etc/redhat-release  # 查看操作系统版本<br>/var/log/message# 系统启动后的信息和错误⽇志，是Red Hat Linux中最常⽤的⽇志之⼀<br>/var/log/message # 系统启动后的信息和错误⽇志，是Red Hat Linux中最常⽤的⽇志之⼀<br>/var/log/secure # 与安全相关的⽇志信息<br>/var/log/maillog# 与邮件相关的⽇志信息<br>/var/log/cron# 与定时任务相关的⽇志信息<br>/var/log/spooler # 与UUCP和news设备相关的⽇志信息<br>/var/log/boot.log # 守护进程启动和停⽌相关的⽇志消息<br></code></pre></td></tr></table></figure><p>查看某⽂件下的⽤户操作⽇志，到达操作的⽬录下，执⾏下⾯的程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat .bash_history<br></code></pre></td></tr></table></figure><h2 id="五-创建与删除软连接"><a href="#五-创建与删除软连接" class="headerlink" title="五.创建与删除软连接"></a>五.创建与删除软连接</h2><h3 id="5-1-建立软连接"><a href="#5-1-建立软连接" class="headerlink" title="5.1 建立软连接"></a>5.1 建立软连接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s /usr/local/app /data<br></code></pre></td></tr></table></figure><blockquote><p> 注意：创建软连接时，data⽬录后不加 &#x2F; (加上后是查找其下⼀级⽬录)；</p></blockquote><h3 id="5-2-删除软连接"><a href="#5-2-删除软连接" class="headerlink" title="5.2 删除软连接"></a>5.2 删除软连接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -rf /data<br></code></pre></td></tr></table></figure><h2 id="六-压缩与解压缩"><a href="#六-压缩与解压缩" class="headerlink" title="六.压缩与解压缩"></a>六.压缩与解压缩</h2><h3 id="6-1-tar命令"><a href="#6-1-tar命令" class="headerlink" title="6.1 tar命令"></a>6.1 tar命令</h3><div style="text-align: center;">      <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/tar%E5%91%BD%E4%BB%A4.png" alt="tar命令"/></div><ol><li>压缩（-c）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将当前⽬录下a.java、b.java打包</span><br>tar -cvf start.tar a.java b.java <br><span class="hljs-meta prompt_"># </span><span class="language-bash">将当前⽬录下的所欲⽂件打包压缩成haha.tar⽂件</span><br>tar -cvf start.tar ./*<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将当前⽬录下a.java、b.java打包</span><br>tar -zcvf start.tar.gz a.java b.java<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将当前⽬录下的所欲⽂件打包压缩成start.tar.gz⽂件</span><br>tar -zcvf start.tar.gz ./* <br></code></pre></td></tr></table></figure><ol start="2"><li>解压缩（-x）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">解压start.tar压缩包，到当前⽂件夹下</span><br>tar -xvf start.tar<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压start.tar压缩包，到/usr/local⽬录下（C为⼤写，中间⽆空格）</span><br>tar -xvf start.tar -C usr/local  <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压start.tar.gz压缩包，到当前⽂件夹下</span><br>tar -zxvf start.tar.gz<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压start.tar.gz压缩包，到/usr/local⽬录下（C为⼤写，中间⽆空格）</span><br>tar -zxvf start.tar.gz -C usr/local <br></code></pre></td></tr></table></figure><ol start="3"><li>解压缩（tar.xz文件）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -xf node-v12.18.1-linux-x64.tar.xz<br></code></pre></td></tr></table></figure><h3 id="6-2-zip-unzip命令"><a href="#6-2-zip-unzip命令" class="headerlink" title="6.2 zip&#x2F;unzip命令"></a>6.2 zip&#x2F;unzip命令</h3><ol><li>压缩（zip）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将单个⽂件压缩(lib.zip)</span><br>zip lib.zip tomcat.jar<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将lib⽬录进⾏压缩(lib.zip)</span><br>zip -r lib.zip lib/ <br><span class="hljs-meta prompt_"># </span><span class="language-bash">将多个⽂件压缩为zip⽂件(lib.zip)</span> <br>zip -r lib.zip tomcat-embed.jar xml-aps.jar <br></code></pre></td></tr></table></figure><ol start="2"><li>解压缩（unzip）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">解压⼀个zip格式压缩包</span><br>unzip file1.zip<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将`english.zip`包，解压到指定目录`/usr/app/`下</span><br>unzip -d /usr/app/com.lydms.english.zip <br></code></pre></td></tr></table></figure><h2 id="七-Linux下文件的详细信息"><a href="#七-Linux下文件的详细信息" class="headerlink" title="七.Linux下文件的详细信息"></a>七.Linux下文件的详细信息</h2><blockquote><p>r:read w:write x: execute执⾏</p><p>解释：</p><ol><li><p>前三位代表当前⽤户对⽂件权限：可以读&#x2F;可以写&#x2F;不能执⾏</p></li><li><p>中间三位代表当前组的其他⽤户对当前⽂件的操作权限：可以读&#x2F;不能写&#x2F;不能执⾏</p></li><li><p>后三位其他⽤户对当前⽂件权限：可以读&#x2F;不能写&#x2F;不能执⾏</p></li></ol><p>d-rw-r–r– 1 root root 34942 Jan 19 2018 bootstrap.jar</p><p>备注各个部分分别为：文件类型，文件权限，链接数，所属用户，所属组，文件大小，最后修改日期，文件名</p></blockquote><h3 id="7-1-更改文件权限"><a href="#7-1-更改文件权限" class="headerlink" title="7.1 更改文件权限"></a>7.1 更改文件权限</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod u+x web.xml （---x------） # 为⽂件拥有者（user）添加执⾏权限；<br>chmod g+x web.xml （------x---） # 为⽂件拥有者所在组（group）添加执⾏权限；<br>chmod 111 web.xml （---x--x--x） # 为所有⽤户分类，添加可执⾏权限；<br>chmod 222 web.xml （--w--w--w-） # 为所有⽤户分类，添加可写⼊权限； <br>chmod 444 web.xml （-r--r--r--） # 为所有⽤户分类，添加可读取权限；<br></code></pre></td></tr></table></figure><h2 id="八-常用的Docker容器命令"><a href="#八-常用的Docker容器命令" class="headerlink" title="八.常用的Docker容器命令"></a>八.常用的Docker容器命令</h2><h3 id="8-1-下载镜像"><a href="#8-1-下载镜像" class="headerlink" title="8.1 下载镜像"></a>8.1 下载镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">格式为：wget+镜像源</span><br>wget https://mirrors.huaweicloud.com/elasticsearch/7.8.0/elasticsearch-7.8.0-windows-x86_64.zip<br></code></pre></td></tr></table></figure><p><a href="https://mirrors.huaweicloud.com/">华为开源镜像源</a>：<a href="https://mirrors.huaweicloud.com/">https://mirrors.huaweicloud.com/</a></p><h3 id="8-2-常用命令"><a href="#8-2-常用命令" class="headerlink" title="8.2 常用命令"></a>8.2 常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1.查看docker中下载好的镜像</span><br>docker images<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.查询需要的容器名称</span><br>docker search mysql<br><span class="hljs-meta prompt_"># </span><span class="language-bash">3.将需要的docker容器下载运⾏到本地(名称、端⼝号、msyql密码、ID)：</span><br>docker run -di --name=first -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root 26d26dsfsd31a<br><span class="hljs-meta prompt_"># </span><span class="language-bash">4.查看运⾏的docker容器</span><br>docker ps<br><span class="hljs-meta prompt_"># </span><span class="language-bash">5.查看所有的docker容器（包括未运⾏的）</span><br>docker ps -a<br><span class="hljs-meta prompt_"># </span><span class="language-bash">6.停⽌当前运⾏的docker容器</span><br>docker stop first<br><span class="hljs-meta prompt_"># </span><span class="language-bash">7.启动docker容器</span><br>docker start first<br><span class="hljs-meta prompt_"># </span><span class="language-bash">8.重启docker容器</span><br>docker restart first<br><span class="hljs-meta prompt_"># </span><span class="language-bash">9.删除docker容器：</span><br>docker rm first<br></code></pre></td></tr></table></figure><h2 id="九-运维常用命令"><a href="#九-运维常用命令" class="headerlink" title="九.运维常用命令"></a>九.运维常用命令</h2><h3 id="9-1-查询服务器状态"><a href="#9-1-查询服务器状态" class="headerlink" title="9.1 查询服务器状态"></a>9.1 查询服务器状态</h3><p>查看服务器是否可用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">ping + IP地址</span><br>ping 49.32.56.164<br></code></pre></td></tr></table></figure><p>查看服务器指定端口是否可用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">telnet + IP地址</span><br>telnet 49.32.56.164<br></code></pre></td></tr></table></figure><blockquote><p>Telnet安装：<a href="https://blog.csdn.net/lydms/article/details/113698856">https://blog.csdn.net/lydms/article/details/113698856</a></p></blockquote><h3 id="9-2-常用命令"><a href="#9-2-常用命令" class="headerlink" title="9.2 常用命令"></a>9.2 常用命令</h3><ol><li>shutdown命令</li></ol><p>关闭计算机。shutdown是最常⽤也是最安全的关机和重启命令，它会在关机之前调⽤fsck检查磁盘，其中-h和-r是最常⽤的参数</p><blockquote><p>-h：停⽌系统服务并关机</p><p>-r：停⽌系统服务后重启</p></blockquote><p>举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">立即关机</span><br>shutdown -h now<br><span class="hljs-meta prompt_"># </span><span class="language-bash">到10:53关机，如果该时间⼩于当前时间，则到隔天</span> <br>shutdown -h 10:53<br><span class="hljs-meta prompt_"># </span><span class="language-bash">10分钟后⾃动关机</span><br>shutdown -h +10<br><span class="hljs-meta prompt_"># </span><span class="language-bash">立即重启</span><br>shutdown -r now<br><span class="hljs-meta prompt_"># </span><span class="language-bash">30分钟后重启并并发送通知给其它在线⽤户</span><br>shutdown -r +30 &#x27;The System Will Reboot in 30 Mins&#x27;  <br></code></pre></td></tr></table></figure><ol start="2"><li>查看处于各种连接状态数量(ESTABLISHED、CLOSE_WAIT、TIME_WAIT)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看处于 ESTABLISHED 状态连接</span><br>netstat -nt | awk &#x27;&#123;if($NF==&quot;ESTABLISHED&quot;)&#123;wait[$5]++&#125;&#125;END&#123;for(i in wait) print i,wait[i]&#125;&#x27;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看处于 CLOSE_WAIT 状态连接</span><br>netstat -nt | awk &#x27;&#123;if($NF==&quot;CLOSE_WAIT&quot;)&#123;wait[$5]++&#125;&#125;END&#123;for(i in wait) print i,wait[i]&#125;&#x27;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看处于 TIME_WAIT 状态连接</span><br>netstat -nt | awk &#x27;&#123;if($NF==&quot;TIME_WAIT&quot;)&#123;wait[$5]++&#125;&#125;END&#123;for(i in wait) print i,wait[i]&#125;&#x27;<br></code></pre></td></tr></table></figure><ol start="3"><li>ping 命令</li></ol><p>对<a href="http://www.dustwind.club/">www.dustwind.club</a> 发送ping 包, 检查与其是否联通</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ping -c 4 dustwind.club<br></code></pre></td></tr></table></figure><ol start="4"><li>netstat命令</li></ol><p>netstat 命令⽤于显示各种⽹络相关信息，如⽹络连接, 路由表, 接⼝状态等等</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有处于监听状态的tcp端⼝</span><br>netstat -lt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看所有的端⼝信息, 包括 PID 和进程名称</span><br>netstat -tulpn<br></code></pre></td></tr></table></figure><ol start="5"><li>查看当前端⼝号占⽤情况</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1.查看某⼀端⼝的占⽤情况</span><br>lsof -i:8080<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.显示tcp，udp的端⼝和进程等相关情况</span><br>netstat -tunlp<br><span class="hljs-meta prompt_"># </span><span class="language-bash">3.指定端口的进程情况</span><br>netstat -tunlp|grep 8080<br><span class="hljs-meta prompt_"># </span><span class="language-bash">4.查看PID进程情况</span><br>ps -aux |grep 28990<br>jstack 2246|grep &#x27;0x9eb&#x27; -A 50   # 根据PID，查看JVM中各线程信息(&#x27;0x9eb&#x27;为nid值）<br></code></pre></td></tr></table></figure><ol start="6"><li>ps命令</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">过滤得到当前系统中的 ssh 进程信息</span><br>ps aux | grep &#x27;ssh&#x27;<br></code></pre></td></tr></table></figure><ol start="7"><li>管道命令</li></ol><p>简单来说, Linux 中管道的作⽤是将上⼀个命令的输出作为下⼀个命令的输⼊, 像 pipe ⼀样将各个命令串联起来执行, 管道的操作符是 |</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">管道命令查看当前运⾏的程序中，名称为java的程序</span><br>ps -ef|grep java<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看/etc/passwd⽂件中的root内容</span><br>cat /etc/passwd | grep &#x27;root&#x27;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前系统的ip连接（Windows和Linux通⽤）</span><br>netstat -an<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将sh test.sh任务放到后台，并将打印的⽇志输出到 nohup.out ⽂件中，终端不再能够接收任何输⼊（标准输⼊）</span><br>nohup sh test.sh &amp;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将sh test.sh任务放到后台，并将打印的⽇志输出到 test.out ⽂件中，终端不再能够接收任何输⼊（标准输⼊）</span><br>nohup sh test.sh &gt;&gt; test.out &amp;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将sh test.sh任务放到后台，并将打印的⽇志输出到nohup.out⽂件中，终端能够接收任何输⼊</span><br>nohup sh test.sh &amp;<br></code></pre></td></tr></table></figure><ol start="8"><li>添加Host地址</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">打开配置文件</span><br>vim /etc/hosts<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在打开文件中添加内容</span><br>49.32.56.164 dustwind.club<br><span class="hljs-meta prompt_"># </span><span class="language-bash">保存文件，重启网络</span><br>/etc/init.d/network restart<br></code></pre></td></tr></table></figure><h2 id="十-yum常用命令"><a href="#十-yum常用命令" class="headerlink" title="十.yum常用命令"></a>十.yum常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1.下载并安装iptables</span><br>yum install iptables-services<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.列出当前系统中安装的所有包</span><br>yum list <br><span class="hljs-meta prompt_"># </span><span class="language-bash">3.在rpm仓库中搜寻软件包</span><br>yum search package_name<br><span class="hljs-meta prompt_"># </span><span class="language-bash">4.更新当前系统中所有安装的rpm包</span><br>yum update package_name.rpm<br><span class="hljs-meta prompt_"># </span><span class="language-bash">5.更新⼀个rpm包</span><br>yum update package_name<br><span class="hljs-meta prompt_"># </span><span class="language-bash">6.删除⼀个rpm包</span><br>yum remove package_name<br><span class="hljs-meta prompt_"># </span><span class="language-bash">7.删除所有缓存的包和头⽂件</span><br>yum clean all<br></code></pre></td></tr></table></figure><h2 id="十一-其他命令"><a href="#十一-其他命令" class="headerlink" title="十一.其他命令"></a>十一.其他命令</h2><ol><li>查看历史使用命令：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看历史使用命令<span class="hljs-built_in">history</span></span><br>history | grep es# 过滤与 es 相关的命令<br></code></pre></td></tr></table></figure><ol start="2"><li>查看占用资源：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -au # 占⽤的资源是从进程启动开始，计算的平均占⽤资源，⽐如cpu等<br>top    # 实时占⽤的资源<br></code></pre></td></tr></table></figure><ol start="3"><li>查看当前目录所占存储：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">du -lh # 查看当前⽂件下各⽂件夹占⽤存储空间<br>du -sh # 查看当前⽂件夹所占存储空间<br>du --max-depth=&lt;⽬录层数&gt;      # 超过指定层数的⽬录后，予以忽略。<br>du --max-depth=1  # 只查看当前⽬录下⽂件占⽤的存储空间<br></code></pre></td></tr></table></figure><ol start="4"><li><p>管道命令：</p><p>根据项⽬查看进程，更加PID查看项⽬，以及项⽬路径</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef 查看所有的进程<br>ps -ef | grep mysql 查看mysql相关的进程<br></code></pre></td></tr></table></figure><ol start="5"><li>通过进程PID查看所占的端口号：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat -nap |grep 进程ID(PID)<br></code></pre></td></tr></table></figure><ol start="6"><li>查看Linux下的系统存储使用率：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">df -h # 查看系统硬盘使⽤情况<br></code></pre></td></tr></table></figure><ol start="7"><li>杀死进程（根据PID）：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kill -9 2630 # 杀死进程pid为2630的进程<br></code></pre></td></tr></table></figure><ol start="8"><li>关闭防火墙：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">service iptables stop # 临时关闭防⽕墙<br>chkconfig iptables off # 防⽕墙开启不启动<br>service iptables status # 查看防⽕墙状态<br></code></pre></td></tr></table></figure><ol start="9"><li>开机启动选项：<a href="https://www.cnblogs.com/lldsn/p/10489593.html"></a></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">msconfig # 查看开机启动选项<br>chkconfig # 查看开机启动服务列表<br></code></pre></td></tr></table></figure><ol start="10"><li>查看MySQL服务的程序状态：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">service mysql start # 开启MySQL <br>service mysql status # 查看MySQL的状态 <br>service mysql stop # 关闭MySQL <br></code></pre></td></tr></table></figure><h2 id="十二-Linux内核优化"><a href="#十二-Linux内核优化" class="headerlink" title="十二.Linux内核优化"></a>十二.Linux内核优化</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">打开配置文件</span><br>vim /etc/sysctl.conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">加载新的配置（需开启防⽕墙iptables，否则会报错）</span><br>sysctl -p<br></code></pre></td></tr></table></figure><blockquote><p>详细查阅地址：<a href="https://www.cnblogs.com/lldsn/p/10489593.html">https://www.cnblogs.com/lldsn/p/10489593.html</a></p></blockquote><h2 id="十三-用户权限操作"><a href="#十三-用户权限操作" class="headerlink" title="十三.用户权限操作"></a>十三.用户权限操作</h2><h3 id="13-1-用户策略"><a href="#13-1-用户策略" class="headerlink" title="13.1 用户策略"></a>13.1 用户策略</h3><ol><li>添加用户sum：</li></ol><blockquote><p>useradd –d &#x2F;usr&#x2F;sum -m sum</p><p>参数注释：</p><p>-u：指定 UID，这个 UID 必须是⼤于等于500，并没有其他⽤户占⽤的 UID</p><p>-g：指定默认组，可以是 GID 或者 GROUPNAME，同样也必须真实存在</p><p>-G：指定额外组</p><p>-c：指定⽤户的注释信息</p><p>-d： 指定⽤户的家⽬录</p></blockquote><ol start="2"><li>已创建用户sum设置密码：</li></ol><blockquote><p>passwd sum</p></blockquote><ol start="3"><li>为用户添加root权限（visudo命令）</li></ol><blockquote><p>visudo</p><p>步骤：</p><ol><li>在sudoers 文件中找到root用户权限位置</li><li>添加与root用户相同的权限（复制root行，修改root为需修改权限的用户名）</li></ol></blockquote><ol start="4"><li>显示新建用户的信息</li></ol><blockquote><p>cat &#x2F;etc&#x2F;passwd</p></blockquote><ol start="5"><li>删除sum用户</li></ol><blockquote><p>userdel sum</p></blockquote><ol start="6"><li>删除用户文件夹</li></ol><blockquote><p>rm -rf &#x2F;usr&#x2F;sum</p></blockquote><ol start="7"><li>切换到添加的用户sum</li></ol><blockquote><p>su sum</p></blockquote><ol start="8"><li>回到root用户</li></ol><blockquote><p>exit</p></blockquote><h3 id="13-2-组策略"><a href="#13-2-组策略" class="headerlink" title="13.2 组策略"></a>13.2 组策略</h3><ol><li>添加用户组</li></ol><blockquote><p>groupadd groupname</p></blockquote><ol start="2"><li>删除用户组</li></ol><blockquote><p>groupdel groupname</p></blockquote><ol start="3"><li>显示分组信息</li></ol><blockquote><p>cat &#x2F;etc&#x2F;group</p></blockquote><h2 id="十四-TOP命令"><a href="#十四-TOP命令" class="headerlink" title="十四.TOP命令"></a>十四.TOP命令</h2><h3 id="14-1-top命令用于查看实时占用的资源"><a href="#14-1-top命令用于查看实时占用的资源" class="headerlink" title="14.1 top命令用于查看实时占用的资源"></a>14.1 top命令用于查看实时占用的资源</h3><blockquote><p>top [参数]</p><p>详细参数：</p><p>-b 批处理</p><p>-c 显示完整的治命令</p><p>-I 忽略失效过程</p><p>-s 保密模式</p><p>-S 累积模式</p><p>-i&lt;时间&gt; 设置间隔时间</p><p>-u&lt;用户名&gt; 指定用户名</p><p>-p&lt;进程号&gt; 指定进程</p><p>-n&lt;次数&gt; 循环显示的次数</p></blockquote><h3 id="14-2-举例"><a href="#14-2-举例" class="headerlink" title="14.2 举例"></a>14.2 举例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs shell">top - 14:06:23 up 70 days, 16:44,  2 users,  load average: 1.25, 1.32, 1.35<br>Tasks: 206 total,   1 running, 205 sleeping,   0 stopped,   0 zombie<br>Cpu(s):  5.9%us,  3.4%sy,  0.0%ni, 90.4%id,  0.0%wa,  0.0%hi,  0.2%si,  0.0%st<br>Mem:  32949016k total, 14411180k used, 18537836k free,   169884k buffers<br>Swap: 32764556k total,        0k used, 32764556k free,  3612636k cached<br><br>  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                               <br>28894 root      22   0 1501m 405m  10m S 52.2  1.3   2534:16 java                                                                   <br>18249 root      18   0 3201m 1.9g  11m S 35.9  6.0 569:39.41 java                                                                   <br> 2808 root      25   0 3333m 1.0g  11m S 24.3  3.1 526:51.85 java                                                               <br>25668 root      23   0 3180m 704m  11m S 14.0  2.2 360:44.53 java                                                                   <br>  574 root      25   0 3168m 611m  10m S 12.6  1.9 556:59.63 java                                                                   <br> 1599 root      20   0 3237m 1.9g  11m S 12.3  6.2 262:01.14 java                                                                   <br> 1008 root      21   0 3147m 842m  10m S  0.3  2.6   4:31.08 java                                                                   <br>13823 root      23   0 3031m 2.1g  10m S  0.3  6.8 176:57.34 java                                                                   <br>28218 root      15   0 12760 1168  808 R  0.3  0.0   0:01.43 top                                                                    <br>29062 root      20   0 1241m 227m  10m S  0.3  0.7   2:07.32 java                                                                   <br>    1 root      15   0 10368  684  572 S  0.0  0.0   1:30.85 init                                                                   <br>    2 root      RT  -5     0    0    0 S  0.0  0.0   0:01.01 migration/0                                                            <br>    3 root      34  19     0    0    0 S  0.0  0.0   0:00.00 ksoftirqd/0                                                            <br>    4 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 watchdog/0                                                             <br>    5 root      RT  -5     0    0    0 S  0.0  0.0   0:00.80 migration/1                                                            <br>    6 root      34  19     0    0    0 S  0.0  0.0   0:00.00 ksoftirqd/1                                               <br>    7 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 watchdog/1                                                             <br>    8 root      RT  -5     0    0    0 S  0.0  0.0   0:20.59 migration/2                                                            <br>    9 root      34  19     0    0    0 S  0.0  0.0   0:00.09 ksoftirqd/2                                                            <br>   10 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 watchdog/2                                                             <br>   11 root      RT  -5     0    0    0 S  0.0  0.0   0:23.66 migration/3                                                            <br>   12 root      34  19     0    0    0 S  0.0  0.0   0:00.03 ksoftirqd/3                                                            <br>   13 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 watchdog/3                                                             <br>   14 root      RT  -5     0    0    0 S  0.0  0.0   0:20.29 migration/4                                                            <br>   15 root      34  19     0    0    0 S  0.0  0.0   0:00.07 ksoftirqd/4                                                            <br>   16 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 watchdog/4                                                             <br>   17 root      RT  -5     0    0    0 S  0.0  0.0   0:23.07 migration/5                                                            <br>   18 root      34  19     0    0    0 S  0.0  0.0   0:00.07 ksoftirqd/5                                                            <br>   19 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 watchdog/5                                                             <br>   20 root      RT  -5     0    0    0 S  0.0  0.0   0:17.16 migration/6                                                            <br>   21 root      34  19     0    0    0 S  0.0  0.0   0:00.05 ksoftirqd/6                                                            <br>   22 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 watchdog/6                                                             <br>   23 root      RT  -5     0    0    0 S  0.0  0.0   0:58.28 migration/7<br></code></pre></td></tr></table></figure><p>前五行是当前系统情况整体的统计信息区，具体内容构成如下：</p><ol><li><p>第一行：任务队列信息，同 uptime 命令的执行结果。</p><p>具体参数说明：</p><p>14:06:23 — 当前系统时间</p><p>up 70 days, 16:44 — 系统已经运行了70天16小时44分钟（在这期间系统没有重启过的吆！）</p><p>2 users — 当前有2个用户登录系统</p><p>load average: 1.15, 1.42, 1.44 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。</p><blockquote><p>load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。</p></blockquote></li><li><p>第二行：任务总述。</p><p>具体参数说明：</p><p>Tasks — 任务（进程）</p><p>系统现在共有206个进程，其中处于运行中的有1个，205个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。</p></li><li><p>第三行：cpu状态信息。</p><p>具体参数说明：</p><p>5.9%us — 用户空间占用CPU的百分比。</p><p>3.4% sy — 内核空间占用CPU的百分比。</p><p>0.0% ni — 改变过优先级的进程占用CPU的百分比</p><p>90.4% id — 空闲CPU百分比</p><p>0.0% wa — IO等待占用CPU的百分比</p><p>0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比</p><p>0.2% si — 软中断（Software Interrupts）占用CPU的百分比</p></li></ol><blockquote><p>备注：在这里CPU的使用比率和windows概念不同，需要理解linux系统用户空间和内核空间的相关知识！</p></blockquote><ol start="4"><li><p>第四行：内存状态。</p><p>具体参数说明：</p><p>32949016k total — 物理内存总量（32GB）</p><p>14411180k used — 使用中的内存总量（14GB）</p><p>18537836k free — 空闲内存总量（18GB）</p><p>169884k buffers — 缓存的内存量 （169M）</p></li><li><p>第五行，swap交换分区信息。</p><p>具体参数说明：</p><p>32764556k total — 交换区总量（32GB）</p><p>0k used — 使用的交换区总量（0K）</p><p>32764556k free — 空闲交换区总量（32GB）</p><p>3612636k cached — 缓冲的交换区总量（3.6GB）</p></li><li><p>第六行：空行。</p></li><li><p>第七行：各进程（任务）的状态监控。</p><p>具体参数说明：PID — 进程id</p><p>USER — 进程所有者</p><p>PR — 进程优先级</p><p>NI — nice值。负值表示高优先级，正值表示低优先级</p><p>VIRT — 进程使用的虚拟内存总量，单位kb。VIRT&#x3D;SWAP+RES</p><p>RES — 进程使用的、未被换出的物理内存大小，单位kb。RES&#x3D;CODE+DATA</p><p>SHR — 共享内存大小，单位kb</p><p>S — 进程状态。D&#x3D;不可中断的睡眠状态 R&#x3D;运行 S&#x3D;睡眠 T&#x3D;跟踪&#x2F;停止 Z&#x3D;僵尸进程</p><p>%CPU — 上次更新到现在的CPU时间占用百分比</p><p>%MEM — 进程使用的物理内存百分比</p><p>TIME+ — 进程使用的CPU时间总计，单位1&#x2F;100秒</p><p>COMMAND — 进程名称（命令名&#x2F;命令行）</p></li></ol><h2 id="十五-文件安装"><a href="#十五-文件安装" class="headerlink" title="十五.文件安装"></a>十五.文件安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">下载文件（file.name）：</span><br>yum install -y file.name<br><span class="hljs-meta prompt_"># </span><span class="language-bash">上传文件：</span><br>rz<br><span class="hljs-meta prompt_"># </span><span class="language-bash">保存文件：</span><br>sz<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git学习</title>
    <link href="/2022/06/27/Git%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/06/27/Git%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="一-Git简介"><a href="#一-Git简介" class="headerlink" title="一.Git简介"></a>一.Git简介</h1><h2 id="1-1-Git工作机制"><a href="#1-1-Git工作机制" class="headerlink" title="1.1 Git工作机制"></a>1.1 Git工作机制</h2><p>Git包含两部分仓库，一个是本地仓库，一个是远程仓库。其基本工作机制如下图所示：</p><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="Git工作机制"></p><hr><h1 id="二-本地仓库"><a href="#二-本地仓库" class="headerlink" title="二.本地仓库"></a>二.本地仓库</h1><p>本地仓库的操作包含分支内操作以及分支间操作。</p><h2 id="2-1-Git分支内操作常用命令"><a href="#2-1-Git分支内操作常用命令" class="headerlink" title="2.1 Git分支内操作常用命令"></a>2.1 Git分支内操作常用命令</h2><table><thead><tr><th align="center">命令名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git config –global user.name “用户名”</td><td align="center">设置用户签名（用户名）</td></tr><tr><td align="center">git config –global user.email “邮箱号”</td><td align="center">设置用户签名（邮箱名）</td></tr><tr><td align="center">git init</td><td align="center">初始化本地库</td></tr><tr><td align="center">git status</td><td align="center">查看本地库状态</td></tr><tr><td align="center">git add 文件名</td><td align="center">添加到暂存区</td></tr><tr><td align="center">git commit -m “日志信息” 文件名</td><td align="center">提交到本地库</td></tr><tr><td align="center">git reflog</td><td align="center">查看版本信息</td></tr><tr><td align="center">git log</td><td align="center">查看版本详细信息</td></tr><tr><td align="center">get reset –hard 版本号</td><td align="center">回退到指定版本</td></tr></tbody></table><h2 id="2-2-Git分支间操作常用命令"><a href="#2-2-Git分支间操作常用命令" class="headerlink" title="2.2 Git分支间操作常用命令"></a>2.2 Git分支间操作常用命令</h2><table><thead><tr><th align="center">操作名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git branch 分支名</td><td align="center">创建分支</td></tr><tr><td align="center">git branch -v</td><td align="center">查看分支</td></tr><tr><td align="center">git checkout 分支名</td><td align="center">切换分支</td></tr><tr><td align="center">git merge 分支名</td><td align="center">将指定分支合并到当前分支上</td></tr><tr><td align="center">git branch -D 分支名</td><td align="center">明确要删除指定分支</td></tr></tbody></table><h2 id="2-3-什么是分支"><a href="#2-3-什么是分支" class="headerlink" title="2.3 什么是分支"></a>2.3 什么是分支</h2><ol><li>在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支；</li><li>使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行；</li><li>对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本。</li></ol><h2 id="2-4-分支的好处"><a href="#2-4-分支的好处" class="headerlink" title="2.4 分支的好处"></a>2.4 分支的好处</h2><ol><li>同时并行推进多个功能开发，提高开发效率；</li><li>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。</li></ol><hr><h1 id="三-远程仓库"><a href="#三-远程仓库" class="headerlink" title="三.远程仓库"></a>三.远程仓库</h1><p>常用的远程仓库包括GitHub和Gitee。</p><h2 id="3-1-远程仓库的创建"><a href="#3-1-远程仓库的创建" class="headerlink" title="3.1 远程仓库的创建"></a>3.1 远程仓库的创建</h2><ol><li>GitHub仓库的创建</li></ol><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/GitHub%E5%88%9B%E5%BB%BA%E4%BD%A0%E6%96%B0%E4%BB%93%E5%BA%93.png" alt="GitHub创建新仓库"></p><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/GitHub%E4%BB%93%E5%BA%93%E5%88%9B%E5%BB%BA%E6%88%90%E5%8A%9F.png" alt="GitHub创建仓库成功"></p><ol start="2"><li>Gitee仓库的创建</li></ol><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Gitee%E5%88%9B%E5%BB%BA%E6%96%B0%E4%BB%93%E5%BA%93.png" alt="Gitee创建仓库"></p><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Gitee%E4%BB%93%E5%BA%93%E5%88%9B%E5%BB%BA%E6%88%90%E5%8A%9F.png" alt="Gitee创建仓库成功"></p><h2 id="3-2-远程仓库的操作常用命令"><a href="#3-2-远程仓库的操作常用命令" class="headerlink" title="3.2 远程仓库的操作常用命令"></a>3.2 远程仓库的操作常用命令</h2><table><thead><tr><th align="center">命令名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git remote -v</td><td align="center">查看当前所有远程仓库地址别名</td></tr><tr><td align="center">git remote add 别名 远程地址</td><td align="center">给远程仓库地址起别名</td></tr><tr><td align="center">git push 别名 分支</td><td align="center">推送本地仓库的分支内容到远程仓库</td></tr><tr><td align="center">git clone 远程地址</td><td align="center">从远程仓库克隆内容到本地</td></tr><tr><td align="center">git pull 远程库</td><td align="center">将远程仓库对于分支的最新内容拉下来后与当前本地分支直接合并</td></tr><tr><td align="center">git diff</td><td align="center">对比两个版本的差异</td></tr><tr><td align="center">git fetch</td><td align="center">更新远程仓库所包含分支的最新commit-id并记录到.git&#x2F;FETCH_HEAD文件</td></tr></tbody></table><blockquote><p><strong>git diff具体说明</strong>：</p><ul><li>本地工作区和暂存区的diff信息：git diff 或者 git diff file</li><li>暂存区和版本库的diff信息（使用git add 将工作区修改保存到了暂存区后）：git diff –cached</li><li>版本库中不同commit、分支的diff信息（使用git commit 将暂存区修改提交到了版本库）：git diff commit1 commit2 或 git diff branch1 branch2</li></ul></blockquote><hr><h1 id="四-Git团队协作机制"><a href="#四-Git团队协作机制" class="headerlink" title="四.Git团队协作机制"></a>四.Git团队协作机制</h1><h2 id="4-1-团队内协作"><a href="#4-1-团队内协作" class="headerlink" title="4.1 团队内协作"></a>4.1 团队内协作</h2><h2 id="4-2-团队间协作"><a href="#4-2-团队间协作" class="headerlink" title="4.2 团队间协作"></a>4.2 团队间协作</h2><h1 id="五-Git命令汇总"><a href="#五-Git命令汇总" class="headerlink" title="五.Git命令汇总"></a>五.Git命令汇总</h1><h2 id="5-1-分支内操作命令"><a href="#5-1-分支内操作命令" class="headerlink" title="5.1 分支内操作命令"></a>5.1 分支内操作命令</h2><table><thead><tr><th align="center">命令名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git config –global user.name “用户名”</td><td align="center">设置用户签名（用户名）</td></tr><tr><td align="center">git config –global user.email 邮箱号</td><td align="center">设置用户签名（邮箱名）</td></tr><tr><td align="center">git init</td><td align="center">初始化本地库</td></tr><tr><td align="center">git status</td><td align="center">查看本地库状态</td></tr><tr><td align="center">git add 文件名</td><td align="center">添加到暂存区</td></tr><tr><td align="center">git commit -m “日志信息” 文件名</td><td align="center">提交到本地库</td></tr><tr><td align="center">git reflog</td><td align="center">查看版本信息</td></tr><tr><td align="center">git log</td><td align="center">查看版本详细信息</td></tr><tr><td align="center">get reset –hard 版本号</td><td align="center">回退版本</td></tr></tbody></table><h2 id="5-2-分支间操作命令"><a href="#5-2-分支间操作命令" class="headerlink" title="5.2 分支间操作命令"></a>5.2 分支间操作命令</h2><table><thead><tr><th align="center">命令名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git branch {-v}</td><td align="center">查看本地分支</td></tr><tr><td align="center">git branch -r</td><td align="center">查看远程分支</td></tr><tr><td align="center">git branch [name]</td><td align="center">创建本地分支（新分支创建后不会自动切换为当前分支）</td></tr><tr><td align="center">git checkout [name]</td><td align="center">切换本地分支</td></tr><tr><td align="center">git checkout -b [name]</td><td align="center">创建新分支并立即切换到新分支</td></tr><tr><td align="center">git branch -d [name]</td><td align="center">删除本地分支</td></tr><tr><td align="center">git branch -D [name]</td><td align="center">删除本地分支（强制删除）</td></tr><tr><td align="center">git merge [name]</td><td align="center">将名为name的分支合并到当前分支</td></tr><tr><td align="center">git push origin [name]</td><td align="center">创建远程分支（本地分支推送到远程仓库）</td></tr><tr><td align="center">git push origin :heads&#x2F;[name]</td><td align="center">删除远程分支</td></tr><tr><td align="center">git push [remoteName] –delete [name]</td><td align="center">删除远程分支</td></tr><tr><td align="center">git branch -m [oldName] [newName]</td><td align="center">分支重命名</td></tr></tbody></table><h2 id="5-3-远程仓库操作命令"><a href="#5-3-远程仓库操作命令" class="headerlink" title="5.3 远程仓库操作命令"></a>5.3 远程仓库操作命令</h2><table><thead><tr><th align="center">命令名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git <strong>clone</strong> [address]</td><td align="center">从远程仓库克隆到本地</td></tr><tr><td align="center">git <strong>remote</strong> -v</td><td align="center">查看远程仓库</td></tr><tr><td align="center">git remote add [name] [url]</td><td align="center">添加远程仓库并给其取别名</td></tr><tr><td align="center">git remote rm [name]</td><td align="center">删除远程仓库</td></tr><tr><td align="center">git remote set-url –push[name]</td><td align="center">修改远程仓库</td></tr><tr><td align="center">git <strong>pull</strong> [remoteName] [localBranchName]</td><td align="center">拉取远程仓库</td></tr><tr><td align="center">git <strong>push</strong> [remoteName] [localBranchName]</td><td align="center">推送本地仓库的分支内容到远程仓库</td></tr></tbody></table><h2 id="5-4-版本操作命令（很少使用）"><a href="#5-4-版本操作命令（很少使用）" class="headerlink" title="5.4 版本操作命令（很少使用）"></a>5.4 版本操作命令（很少使用）</h2><table><thead><tr><th align="center">命令名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git tag</td><td align="center">查看版本</td></tr><tr><td align="center">git tag [name]</td><td align="center">创建版本</td></tr><tr><td align="center">git tag -d [name]</td><td align="center">删除版本</td></tr><tr><td align="center">git tag -r</td><td align="center">查看远程版本</td></tr><tr><td align="center">git push [remoteName] [localBranchName]</td><td align="center">创建远程版本</td></tr><tr><td align="center">git push origin :refs&#x2F;tags&#x2F;[name]</td><td align="center">删除远程版本</td></tr></tbody></table><h2 id="5-5-子模块操作命令"><a href="#5-5-子模块操作命令" class="headerlink" title="5.5 子模块操作命令"></a>5.5 子模块操作命令</h2><table><thead><tr><th align="center">命令名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git submodule add [url] [path]</td><td align="center">添加子模块</td></tr><tr><td align="center"><strong>git</strong> submodule init</td><td align="center">初始化子模块（只需首次检出仓库时运行一下）</td></tr><tr><td align="center"><strong>git</strong> submodule update</td><td align="center">更新子模块（每次更新或切换分支后都需要运行一下）</td></tr></tbody></table><p>PS:删除子模块的步骤：</p><ul><li><p>git rm –cached [path]</p></li><li><p>编辑 “.gitmodules” 文件，将子模块的相关配置节点删除掉</p></li><li><p>编辑 “. <strong>git</strong>&#x2F;config” 文件，将子模块的相关配置节点删除掉</p></li><li><p>手动删除子模块残留的目录</p></li></ul><h2 id="5-6-Git忽略文件、文件夹不提交"><a href="#5-6-Git忽略文件、文件夹不提交" class="headerlink" title="5.6 Git忽略文件、文件夹不提交"></a>5.6 Git忽略文件、文件夹不提交</h2><p>在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># See https://help.github.com/articles/ignoring-files/ for more about ignoring</span><br><span class="hljs-comment"># dependencies</span><br>/node_modules<br><span class="hljs-comment"># production</span><br>/dist<br><span class="hljs-comment"># misc</span><br>.DS_Store<br>npm-debug.log*<br>.idea<br></code></pre></td></tr></table></figure><h2 id="5-7-其他操作命令"><a href="#5-7-其他操作命令" class="headerlink" title="5.7 其他操作命令"></a>5.7 其他操作命令</h2><table><thead><tr><th align="center">命令名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git reset –hard [version]</td><td align="center">回退到指定版本</td></tr><tr><td align="center">git clone -b [branchName] [address]</td><td align="center">拉取指定分支代码</td></tr><tr><td align="center">git push –set-upstream origin test</td><td align="center">服务上未创建分支时提交代码</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL标准模板库</title>
    <link href="/2022/06/25/STL%E6%A0%87%E5%87%86%E6%A8%A1%E7%89%88%E7%B1%BB/"/>
    <url>/2022/06/25/STL%E6%A0%87%E5%87%86%E6%A8%A1%E7%89%88%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="一-STL的六大组件"><a href="#一-STL的六大组件" class="headerlink" title="一.STL的六大组件"></a>一.STL的六大组件</h1><p>STL（Standard Template Library，标准模板库）是为了建立数据结构和算法的一套标准，并且降低它们之间的耦合关系，以提升各自的独立性、弹性、交互操作性。STL包含容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器六大组件。</p><blockquote><p>STL的优点：</p><ol><li>被内建在编译器内部，无需额外安装。</li><li>将数据和操作分离。数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当连接的桥梁，以使算法可以和容器交互运作。</li><li>高可重用性，高性能，高移植性，跨平台的优点</li></ol></blockquote><hr><h2 id="1-1-容器"><a href="#1-1-容器" class="headerlink" title="1.1 容器"></a>1.1 容器</h2><p>容器（Containers）存放的是各种数据结构，如vector、list、deque等；而从<strong>实现角度</strong>讲，STL容器就是一种 class template。</p><p>根据数据在容器中的排列特性，容器可分为序列式容器和关联式容器：</p><ul><li>序列式容器：强调值的排序，序列式容器中的每个元素均有固定位置，除非用插入或删除操作改变这个位置。</li><li>关联式容器：是非线性的树结构，更准确的说是二叉树结构。各元素之间没有严格的物理上的顺序关系，元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器的显著特点：它是以键值的方式来保存数据。</li></ul><p>此外还有容器适配器：适配器是使一事物的行为类似于另一事物的行为的一种机制。容器适配器是让一种已存在的容器类型采用另一种不同的抽象类型的工作方式来实现的一种机制。</p><hr><h2 id="1-2-算法"><a href="#1-2-算法" class="headerlink" title="1.2 算法"></a>1.2 算法</h2><p>算法（Algorithms）是什么，<strong>算法就是步骤</strong>。算法就是解决特定逻辑问题及数学问题的有限步骤的合集。</p><p>算法具有<strong>五大基本特性</strong>：输入输出、有穷性、确定性、可行性。</p><p>STL 收录的算法是经过了无数程序人在实践中证明极具复用价值的合集。算法大致可以分为：</p><ul><li>质变算法：运算中会更改区间内元素的内容。如拷贝，替换，删除等。</li><li>非质变算法：运算中不会更改区间内的元素内容。如查找、计数、遍历等。</li></ul><hr><h2 id="1-3-迭代器"><a href="#1-3-迭代器" class="headerlink" title="1.3 迭代器"></a>1.3 迭代器</h2><p>迭代器（Iterators）是一种抽象的设计概念，现实程序语言中并没有直接对应于这个概念的实物。</p><p>《Design Patterns》中 iterator 模式定义如下：提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。</p><p>迭代器的分类：</p><table><thead><tr><th align="center">迭代器</th><th align="center">功能</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">输入迭代器</td><td align="center">提供数据的只读访问</td><td align="center">只读</td></tr><tr><td align="center">输出迭代器</td><td align="center">提供数据的只写访问</td><td align="center">只写</td></tr><tr><td align="center">前向迭代器</td><td align="center">提供数据的读写操作并能向前推进推进操作</td><td align="center">读写</td></tr><tr><td align="center">双向迭代器</td><td align="center">提供数据的读写操作并能向前和向后推进操作</td><td align="center">读写</td></tr><tr><td align="center">随机访问迭代器</td><td align="center">提供数据的读写操作并能随机跳跃访问容器任意位置数据</td><td align="center">读写</td></tr></tbody></table><hr><h2 id="1-4-仿函数"><a href="#1-4-仿函数" class="headerlink" title="1.4 仿函数"></a>1.4 仿函数</h2><p>仿函数（Functors）是行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了 operator() 的 class 或者class template</p><hr><h2 id="1-5-适配器（配接器）"><a href="#1-5-适配器（配接器）" class="headerlink" title="1.5 适配器（配接器）"></a>1.5 适配器（配接器）</h2><p>适配器（Adapters）是使一事物的行为类似于另一事物的行为的一种机制。容器适配器是让一种已存在的容器类型采用另一种不同的抽象类型的工作方式来实现的一种机制。它实质还是一个容器，只是它不依赖于具体的标准容器类型，可以理解为容器的模版；或者理解为容器的接口，适配器具体采用哪种容器类型去实现，在定义适配器的时候决定。</p><hr><h2 id="1-6-配置器"><a href="#1-6-配置器" class="headerlink" title="1.6 配置器"></a>1.6 配置器</h2><p>配置器（Allocators）是负责空间的配置与管理。从实现角度看配置器是一个实现了动态空间配置、空间管理、空间释放的class tempalte。</p><blockquote><p>STL六大组件关系交错：</p><p>容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，而适配器可以修饰仿函数。</p></blockquote><hr><h1 id="二-STL常用容器类"><a href="#二-STL常用容器类" class="headerlink" title="二.STL常用容器类"></a>二.STL常用容器类</h1><p>STL常用容器类包括如下：</p><p> string、vector、deque、list、forward_list、stack、queue、priority_queue、map、multimap、set、multiset、unordered_map 、unordered_multimap、unordered_set、unordered_multiset。</p><p>标准容器类的分类及其特点：</p><ol><li>顺序式容器</li></ol><table><thead><tr><th align="center">名称</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">array</td><td align="center">大小是固定的，无法动态的扩展或收缩</td></tr><tr><td align="center">vector</td><td align="center">从后面快速插入与删除元素，可直接访问任何元素</td></tr><tr><td align="center">deque</td><td align="center">从前面或者后面插入与删除元素，可直接访问任何元素</td></tr><tr><td align="center">list</td><td align="center">双向链表，可从任意地方快速插入与删除</td></tr><tr><td align="center">forward_list</td><td align="center">单链表，可从任意地方快速插入与删除</td></tr></tbody></table><ol start="2"><li>容器适配器</li></ol><table><thead><tr><th align="center">名称</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">stack</td><td align="center">后进先出（LIFO）</td></tr><tr><td align="center">queue</td><td align="center">先进先出（FIFO）</td></tr><tr><td align="center">priority_queue</td><td align="center">最高优先级总是第一个出列</td></tr></tbody></table><ol start="3"><li>关联式容器</li></ol><table><thead><tr><th align="center">名称</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">map</td><td align="center">一对多映射，基于关键字快速查找，不允许重复值</td></tr><tr><td align="center">multimap</td><td align="center">一对多映射，基于关键字快速查找，允许重复值</td></tr><tr><td align="center">set</td><td align="center">快速查找，不允许重复值</td></tr><tr><td align="center">multiset</td><td align="center">快速查找，允许重复值</td></tr></tbody></table><ol start="4"><li>无序关联式容器</li></ol><table><thead><tr><th align="center">名称</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">unordered_map</td><td align="center">无序</td></tr><tr><td align="center">unordered_multimap</td><td align="center">无序</td></tr><tr><td align="center">unordered_set</td><td align="center">无序</td></tr><tr><td align="center">unordered_multiset</td><td align="center">无序</td></tr></tbody></table><hr><h2 id="2-1-string-类"><a href="#2-1-string-类" class="headerlink" title="2.1 string 类"></a>2.1 string 类</h2><p>string  是 C++ 标准库中一个重要的容器，实际上它是一个类，而不是一个容器模板。</p><p>C语言字符串（以空字符结尾的字符数组）太过复杂难于掌握，不适合大程序的开发，所以C++标准库定义了一种 string 类，定义在 <string> 头文件当中。string 类是 STL 中 对 basic_string 模板实例化得到的模板类。其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> basic_string string;<br></code></pre></td></tr></table></figure><hr><h2 id="2-2-array-容器"><a href="#2-2-array-容器" class="headerlink" title="2.2 array 容器"></a>2.2 array 容器</h2><p>是 C++ 11 标准中新增的顺序容器，它就是在 C++ 普通数组的基础上，添加了成员函数和全局函数。</p><p>它使用比普通数组更安全，且效率相当。array 容器的大小是固定的，无法动态的扩展或收缩，因此它只允许访问或者替换存储的数据元素。</p><hr><h2 id="2-3-vector-容器"><a href="#2-3-vector-容器" class="headerlink" title="2.3 vector 容器"></a>2.3 vector 容器</h2><p>vector 称为向量容器，是一种线性顺序结构。相当于数组，但其大小可以不预先指定，并且自动扩展。它可以像数组一样被操作，由于它的特性我们完全可以将 vector 看作动态数组。</p><p>在创建一个vector 后，它会自动在内存中分配一块连续的内存空间进行数据存储，初始的空间大小可以预先指定也可以由vector 默认指定，这个大小由 capacity() 函数的返回值确定。当存储的数据超过分配的空间时 vector 会重新分配一块内存块，但这样的分配是很耗时的，在重新分配空间时它会做这样的动作：</p><ol><li><p>首先，vector 申请一块更大的内存块；</p></li><li><p>其次，将原来的数据拷贝到新的内存块中；</p></li><li><p>然后，销毁掉原内存块中的对象（调用对象的析构函数）；</p></li><li><p>最后，将原来的内存空间释放掉。</p></li></ol><blockquote><p>注：vector 容器更擅长在尾部插入或删除元素而不擅长在容器头部或者中部插入或删除元素。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span> <span class="hljs-comment">// 头文件引用</span></span><br>vector&lt;<span class="hljs-type">int</span>&gt; vec;  <span class="hljs-comment">// 创建</span><br>vec.<span class="hljs-built_in">push_back</span>(x); <span class="hljs-comment">// 添加 o(1)</span><br>vec.<span class="hljs-built_in">pop_back</span>();   <span class="hljs-comment">// 删除 o(1)</span><br>vec[i]            <span class="hljs-comment">// 访问 o(1)</span><br></code></pre></td></tr></table></figure><hr><h2 id="2-4-deque-容器"><a href="#2-4-deque-容器" class="headerlink" title="2.4 deque 容器"></a>2.4 deque 容器</h2><p>deque 是 double-ended queue 的缩写，又称双端队列。</p><p>deque 容器和 vector 容器的相同点：</p><ol><li><p>deque 容器也擅长在序列尾部添加或删除元素，而不擅长在序列中间添加或删除元素；</p></li><li><p>deque 容器也可根据需要修改自身的容量和大小。</p></li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span> <span class="hljs-comment">//引用头文件</span></span><br>deque&lt;<span class="hljs-type">int</span>&gt; deq;  <span class="hljs-comment">// 创建</span><br><span class="hljs-comment">// 添加 o(1)</span><br>deq.<span class="hljs-built_in">push_front</span>();<br>deq.<span class="hljs-built_in">push_back</span>();<br><span class="hljs-comment">// 删除 o(1)</span><br>deq.<span class="hljs-built_in">pop_front</span>();<br>deq.<span class="hljs-built_in">pop_back</span>();<br><span class="hljs-comment">// 访问 o(1)</span><br>deq.<span class="hljs-built_in">front</span>();<br>deq.<span class="hljs-built_in">back</span>();<br></code></pre></td></tr></table></figure><hr><h2 id="2-5-list-容器"><a href="#2-5-list-容器" class="headerlink" title="2.5 list 容器"></a>2.5 list 容器</h2><p>list 容器，又称双向链表容器，即该容器的底层是以双向链表的形式实现的。这意味着，list 容器中的元素可以分散存储在内存空间里，而不是必须存储在一整块连续的内存空间中。</p><hr><h2 id="2-6-forward-list-容器"><a href="#2-6-forward-list-容器" class="headerlink" title="2.6 forward_list 容器"></a>2.6 forward_list 容器</h2><p>forward_list 容器是 C++ 11 新加入的容器，其底层实现和 list 容器一样，采用的也是链表结构，但是 forward_list 使用的是<strong>单链表</strong>，而 list 使用的是<strong>双向链表</strong>。</p><hr><h2 id="2-7-stack-容器"><a href="#2-7-stack-容器" class="headerlink" title="2.7 stack 容器"></a>2.7 stack 容器</h2><p>stack 是限定仅在表尾进行插入删除操作的线性表，又称为后进先出（<strong>LIFO</strong>）的线性表。它不允许遍历，任何时候外界只能访问 stack 顶部的元素，只有在移除 stack 顶部的元素后，才能访问下方的元素。默认情况下，stack 使用 deque 作为底层容器。stack 容器应用广泛，如编辑器中的 undo （撤销操作）机制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span> <span class="hljs-comment">//引用头文件</span></span><br>stack&lt;<span class="hljs-type">int</span>&gt; stk;  <span class="hljs-comment">// 创建</span><br>stk.<span class="hljs-built_in">push</span>(x);     <span class="hljs-comment">// 添加 o(1)</span><br>stk.<span class="hljs-built_in">pop</span>();       <span class="hljs-comment">// 删除 o(1)</span><br>stk.<span class="hljs-built_in">top</span>();       <span class="hljs-comment">// 访问 o(1)</span><br></code></pre></td></tr></table></figure><hr><h2 id="2-8-queue-容器"><a href="#2-8-queue-容器" class="headerlink" title="2.8 queue 容器"></a>2.8 queue 容器</h2><p>queue 是限定表的一端进行插入操作，表的另一端进行删除操作的线性表，队列又称为先进先出（<strong>FIFO</strong>）的线性表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span> <span class="hljs-comment">//引用头文件</span></span><br>queue&lt;<span class="hljs-type">int</span>&gt; que;  <span class="hljs-comment">// 创建</span><br>que.<span class="hljs-built_in">push</span>();      <span class="hljs-comment">// 添加 o(1)</span><br>que.<span class="hljs-built_in">pop</span>();       <span class="hljs-comment">// 删除 o(1)</span><br>que.<span class="hljs-built_in">front</span>();     <span class="hljs-comment">// 访问 o(1)</span><br></code></pre></td></tr></table></figure><hr><h2 id="2-9-priority-queue-容器"><a href="#2-9-priority-queue-容器" class="headerlink" title="2.9 priority_queue 容器"></a>2.9 priority_queue 容器</h2><p>priority_queue 的本质是<strong>大顶堆</strong>。priority_queue 在内部维护一个基于二叉树的大顶堆数据结构，在这个数据结构中，最大的元素始终位于堆顶部，只有堆顶部的数据元素（max heap element）才能被访问获取。当然，也可以通过自定义模板参数中的 class Compare 实现一个<strong>小顶堆</strong>。相比于 queue（普通队列）的先进先出（FIFO），priority_queue 实现最高优先级先出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span>       <span class="hljs-comment">//引用头文件</span></span><br>priority_queue&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">// 创建</span><br>q.<span class="hljs-built_in">push</span>(x);             <span class="hljs-comment">// 添加 o(logn)</span><br>q.<span class="hljs-built_in">pop</span>();               <span class="hljs-comment">// 删除 o(logn)</span><br>q.<span class="hljs-built_in">top</span>();               <span class="hljs-comment">// 访问 o(1)</span><br></code></pre></td></tr></table></figure><hr><h2 id="2-10-map-容器"><a href="#2-10-map-容器" class="headerlink" title="2.10 map 容器"></a>2.10 map 容器</h2><p>map 通过底层的<strong>红黑树</strong>数据结构将所有的数据元素按照 key 的相对大小进行排序，所实现的排序效果也是严格弱序特性。map 支持在一个子集合上进行直接迭代器访问，因为 map 中的元素是被有序组织的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span>      <span class="hljs-comment">//引用头文件</span></span><br>map&lt;string, <span class="hljs-type">int</span>&gt; m; <span class="hljs-comment">// 创建</span><br>m[str] = x;         <span class="hljs-comment">// 添加 o(logn)</span><br>m.<span class="hljs-built_in">erase</span>(it);        <span class="hljs-comment">// 删除 o(logn)</span><br><span class="hljs-comment">// 访问 o(logn)</span><br>m.<span class="hljs-built_in">count</span>(str);<br>m[str];<br></code></pre></td></tr></table></figure><hr><h2 id="2-11-multimap-容器"><a href="#2-11-multimap-容器" class="headerlink" title="2.11 multimap 容器"></a>2.11 multimap 容器</h2><p>multimap 是关联式容器，是使用红黑树对记录型的元素数据,按元素键值的比较关系，进行快速的插入、删除和检索操作，所不同的是 multimap 允许将具有重复键值的元素插入容器。</p><p>multimap 按照特定顺序来存储键值对 &lt;key、value&gt; ，其中多个键值对之间的 key 可以重复；键 key 通常用于排序及唯一标识元素，值 value 则存储与键 key 关联的内容。</p><hr><h2 id="2-12-set-容器"><a href="#2-12-set-容器" class="headerlink" title="2.12 set 容器"></a>2.12 set 容器</h2><p>set 就是集合，是利用二叉树实现，集合中的每个元素只出现一次(参照数学中集合的互斥性)，并且是排好序的（默认按键值升序排列）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span> <span class="hljs-comment">//引用头文件</span></span><br>set&lt;<span class="hljs-type">int</span>&gt; s;    <span class="hljs-comment">// 创建</span><br>s.<span class="hljs-built_in">insert</span>(x);   <span class="hljs-comment">// 添加 o(logn)</span><br>s.<span class="hljs-built_in">erase</span>(it);   <span class="hljs-comment">// 删除 o(logn)</span><br>s.<span class="hljs-built_in">count</span>(x);    <span class="hljs-comment">// 访问 o(k+logn)</span><br></code></pre></td></tr></table></figure><hr><h2 id="2-13-multiset-容器"><a href="#2-13-multiset-容器" class="headerlink" title="2.13 multiset 容器"></a>2.13 multiset 容器</h2><ol><li>multiset 是按照特定顺序存储元素的容器，其中元素是可以重复的；</li><li>元素的 value 会识别它组成的键值对，multiset 元素的值不能在容器中进行修改，但可以插入和删除；</li><li>multiset 在内部按照特定的严格弱排序准则进行排序；</li><li>multiset 容器通过 key 访问单个元素比 unordered_multiset 容器慢，但当使用迭代器遍历的时候，会得到一个有序序列；</li><li>multiset 的底层是二叉搜索树（红黑树）。</li></ol><hr><h2 id="2-14-unordered-map-容器"><a href="#2-14-unordered-map-容器" class="headerlink" title="2.14 unordered_map 容器"></a>2.14 unordered_map 容器</h2><ol><li>unordered_map 是一个将 key 和 value 关联起来的容器，可以根据单个 key 键高效查找对应 value 值；</li><li>key 键是唯一的，key 键和 value 值的数据类型可以不同；</li><li>unordered_map 存储是无序的，是根据 key 键的哈希值将元素存储在指定位置，并且根据 key 键查找单个value 值时非常高效；</li><li>unordered_map 查询单个 key 键效率比 map 高，但是查询某一范围内的 key 键时比 map 效率低；</li><li>可以使用 [ ] 操作符来访问 key 键对应的 value 值。</li></ol><blockquote><p>注：如果需要内部元素自动排序，使用map，不需要排序使用unordered_map。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span>      <span class="hljs-comment">//引用头文件</span></span><br>unordered_map&lt;string, <span class="hljs-type">int</span>&gt; m; <span class="hljs-comment">// 创建</span><br>m[str] = x;                   <span class="hljs-comment">// 添加 o(1) / o(n)</span><br>m.<span class="hljs-built_in">erase</span>(it);                  <span class="hljs-comment">// 删除 o(1) / o(n)</span><br><span class="hljs-comment">// 访问 o(1) / o(n)</span><br>m.<span class="hljs-built_in">count</span>(str);<br>m[str];<br></code></pre></td></tr></table></figure><hr><h2 id="2-15-unordered-multimap-容器"><a href="#2-15-unordered-multimap-容器" class="headerlink" title="2.15 unordered_multimap 容器"></a>2.15 unordered_multimap 容器</h2><p>unordered_multimap 是一个封装哈希表的无序容器。容器中每个元素都是键值对 &lt;key、value&gt; ，每个 key 键可重复出现。</p><hr><h2 id="2-16-unordered-set-容器"><a href="#2-16-unordered-set-容器" class="headerlink" title="2.16 unordered_set  容器"></a>2.16 unordered_set  容器</h2><p>unordered_set 是一种不按特定顺序存储唯一元素的容器，允许根据元素的值快速检索单个元素。unordered_set 容器和 set 容器很像，唯一的区别就在于 set 容器会自行对存储的数据进行排序，而unordered_set 容器不会。</p><p>几大特性：</p><ol><li>不以键值对 &lt;key、value&gt;的形式存储数据，而是直接存储数据的值；</li><li>容器内部存储的各个元素的值都互不相等，且不能被修改；</li><li>不对内部存储的数据进行排序。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span> <span class="hljs-comment">//引用头文件</span></span><br>unordered_set&lt;<span class="hljs-type">int</span>&gt; s;    <span class="hljs-comment">// 创建</span><br>s.<span class="hljs-built_in">insert</span>(x);             <span class="hljs-comment">// 添加 o(1) / o(n)</span><br>s.<span class="hljs-built_in">erase</span>(it);             <span class="hljs-comment">// 删除 o(1) / o(n)</span><br>s.<span class="hljs-built_in">count</span>(x);              <span class="hljs-comment">// 访问 o(1) / o(n)</span><br></code></pre></td></tr></table></figure><hr><h2 id="2-17-unordered-multiset-容器"><a href="#2-17-unordered-multiset-容器" class="headerlink" title="2.17 unordered_multiset  容器"></a>2.17 unordered_multiset  容器</h2><p>unordered_multiset 容器可同时存储多个相同值的元素，且这些元素会存储到哈希表中（本质就是链表）。</p><p>它有如下特性：</p><ul><li>不以键值对 &lt;key、value&gt;的形式存储数据，而是直接存储数据的值；</li><li>该类型容器底层采用的也是哈希表存储结构，它不会对内部存储的数据进行排序；</li><li>容器内部存储的元素值不能被修改。</li></ul><hr><h1 id="三-C-的一些函数使用"><a href="#三-C-的一些函数使用" class="headerlink" title="三.C++的一些函数使用"></a>三.C++的一些函数使用</h1><h2 id="3-1-algorithm头文件"><a href="#3-1-algorithm头文件" class="headerlink" title="3.1 algorithm头文件"></a>3.1 algorithm头文件</h2><p>algorithm 头文件是C++的标准算法库，它主要应用在容器上。此头文件常用的函数有：</p><ol><li>max()、min()、abs() 函数</li><li>swap() 函数</li><li>reverse() 函数</li><li>sort() 函数</li><li>find() 函数</li><li>upper_bound()、lower_bound() 函数</li><li>fill() 函数</li><li>count() 函数</li><li>_gcd() 函数求最大公约数</li><li>set_intersection()、set_union()、set_difference() 函数</li></ol><hr><h2 id="3-2-转换和判定函数"><a href="#3-2-转换和判定函数" class="headerlink" title="3.2 转换和判定函数"></a>3.2 转换和判定函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">stoi</span>(<span class="hljs-type">const</span> string *str);<span class="hljs-comment">//</span><br><span class="hljs-built_in">atoi</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *ch);<span class="hljs-comment">//</span><br><span class="hljs-built_in">atol</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str);<span class="hljs-comment">//</span><br><br><span class="hljs-built_in">islower</span>(<span class="hljs-type">char</span> c);<span class="hljs-comment">//是否为小写字母</span><br><span class="hljs-built_in">isuppper</span>(<span class="hljs-type">char</span> c);<span class="hljs-comment">//为大写字母</span><br><span class="hljs-built_in">isdigit</span>(<span class="hljs-type">char</span> c);<span class="hljs-comment">//是否为数字</span><br><span class="hljs-built_in">isalpha</span>(<span class="hljs-type">char</span> c);<span class="hljs-comment">//是否为字母</span><br><span class="hljs-built_in">isalnum</span>(<span class="hljs-type">char</span> c); <span class="hljs-comment">//是否为字母或者数字</span><br><span class="hljs-built_in">toupper</span>(<span class="hljs-type">char</span> c); <span class="hljs-comment">//字母小转大</span><br><span class="hljs-built_in">tolower</span>(<span class="hljs-type">char</span> c); <span class="hljs-comment">//字母大转小</span><br></code></pre></td></tr></table></figure><hr><h2 id="3-3-pair-tuple-容器"><a href="#3-3-pair-tuple-容器" class="headerlink" title="3.3 pair &amp; tuple  容器"></a>3.3 pair &amp; tuple  容器</h2><p>std::pair 和 std::tuple 不是STL容器库中的容器，由于经常用到，顺便整理。pair 相当于 tuple 的特例。</p><ul><li>pair 是将2个数据组合成一个数据，当需要这样的需求时就可以使用pair，如STL中的map就是将key和value放在一起来保存。另一个应用是，当一个函数需要返回2个数据的时候，可以选择 pair。pair 的实现是一种结构体，主要的两个成员变量是 first , second。</li><li>tuple是C++11新标准里的类型。它是一个类似 pair 类型的模板。pair 类型是每个成员变量各自可以是任意类型，但是只能有俩个成员，而 tuple 与 pair 不同的是它可以有任意数量的成员。但是每个确定的 tuple 类型的成员数目是固定的。</li></ul><hr>]]></content>
    
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>远程聊天室</title>
    <link href="/2022/05/03/%E8%BF%9C%E7%A8%8B%E8%81%8A%E5%A4%A9%E5%AE%A4/"/>
    <url>/2022/05/03/%E8%BF%9C%E7%A8%8B%E8%81%8A%E5%A4%A9%E5%AE%A4/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="1-设计思路"><a href="#1-设计思路" class="headerlink" title="1.设计思路"></a>1.设计思路</h2><p>注册登录、多客户端数据传输问题（高并发）</p><h2 id="2-高并发额解决方案："><a href="#2-高并发额解决方案：" class="headerlink" title="2.高并发额解决方案："></a>2.高并发额解决方案：</h2><ul><li><p>TCP+多线程，缺点对服务器性能要求比较高</p></li><li><p>select（集合） 一个线程不断循环，对服务器性能要求比较低，但并发量比较低，处理效率比较低</p></li><li><p>epoll 并发量理论上无限，处理效率高</p></li><li><p>epoll+多线程（访问时再创建线程），频繁启动线程消耗时间资源</p></li><li><p>epoll+线程池（提前创建一定数量的线程）</p></li><li><p>libevent（有同步的机制）</p></li><li><p>libevent+多线程</p></li></ul><p>关于libevent，可以参考如下链接：<a href="https://blog.csdn.net/initphp/article/details/41946061?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169701410116800226580641%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169701410116800226580641&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-41946061-null-null.142%5Ev96%5Epc_search_result_base9&utm_term=libevent&spm=1018.2226.3001.4187">libevent库的使用</a></p><h2 id="3-数据保存方式"><a href="#3-数据保存方式" class="headerlink" title="3.数据保存方式"></a>3.数据保存方式</h2><ul><li>数据库：服务器数据存储。单用户的个人信息存储和多用户的群组信息存储</li><li>链表：实时数据保存。用来保存当前网络在线用户以及当前网络在线群成员</li></ul><h1 id="一-轻量级服务器登录"><a href="#一-轻量级服务器登录" class="headerlink" title="一.轻量级服务器登录"></a>一.轻量级服务器登录</h1><h2 id="1-1-购买Linux服务器"><a href="#1-1-购买Linux服务器" class="headerlink" title="1.1 购买Linux服务器"></a>1.1 购买Linux服务器</h2><p>笔者购买的是腾讯云轻量服务器，系统是 Ubuntu 20.04 LTS 版本</p><h2 id="1-2-重置密码"><a href="#1-2-重置密码" class="headerlink" title="1.2 重置密码"></a>1.2 重置密码</h2><p>将密码重置为一个自己熟悉的密码</p><h2 id="1-3-设定密钥"><a href="#1-3-设定密钥" class="headerlink" title="1.3 设定密钥"></a>1.3 设定密钥</h2><p>创建密钥可以通过ssh远程登录</p><h2 id="1-4-ssh远程登录"><a href="#1-4-ssh远程登录" class="headerlink" title="1.4 ssh远程登录"></a>1.4 ssh远程登录</h2><ul><li>一种是通过密码登录</li><li>一种是密钥登录，此时需要将第3步中的密钥绑定到服务器系统上</li></ul><blockquote><p><strong>说明</strong>:Ubuntu系统ssh远程登录默认关闭了<strong>root</strong>权限，需要手动更改步骤如下：</p></blockquote><ol><li><p>使用 <strong>ubuntu</strong> 帐户登录轻量应用服务器。</p></li><li><p>执行以下命令，设置 <strong>root</strong> 密码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo passwd root<br></code></pre></td></tr></table></figure></li><li><p>输入 <strong>root</strong> 的密码，按 <strong>Enter</strong>。</p></li><li><p>重复输入 <strong>root</strong> 的密码，按 <strong>Enter</strong>。返回如下信息，即表示 <strong>root</strong> 密码设置成功。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">passwd: password updated successfully<br></code></pre></td></tr></table></figure></li><li><p>执行以下命令，打开 <strong>sshd_config</strong> 配置文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vi /etc/ssh/sshd_config<br></code></pre></td></tr></table></figure></li><li><p>按 <strong>i</strong> 切换至编辑模式，找到 <strong>#Authentication</strong>，将 <strong>PermitRootLogin</strong> 参数修改为 <strong>yes</strong>。如果 <strong>PermitRootLogin</strong> 参数被注释，请去掉首行的注释符号 <strong>（#）</strong>。</p></li><li><p>找到 <strong>#Authentication</strong>，将 <strong>PasswordAuthentication</strong> 参数修改为 <strong>yes</strong>。说明：若 sshd_config 配置文件中无此配置项，则添加 <strong>PasswordAuthentication yes</strong> 项即可。</p></li><li><p>按 <strong>Esc</strong>，输入 <strong>:wq</strong>，保存文件并返回。</p></li><li><p>执行以下命令，重启 ssh 服务。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo service ssh restart<br></code></pre></td></tr></table></figure></li><li><p>然后便可以在XShell上配置远程登录服务器</p></li></ol><h1 id="二-服务器端的环境部署"><a href="#二-服务器端的环境部署" class="headerlink" title="二.服务器端的环境部署"></a>二.服务器端的环境部署</h1><h2 id="2-1-更新源"><a href="#2-1-更新源" class="headerlink" title="2.1 更新源"></a>2.1 更新源</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get update<br></code></pre></td></tr></table></figure><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/TCP%E7%BD%91%E7%BB%9C%E8%81%8A%E5%A4%A9%E5%AE%A4/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/2.%E6%9B%B4%E6%96%B0%E6%BA%90.png" alt="更新源"  /></div><h2 id="2-2-安装MySQL库"><a href="#2-2-安装MySQL库" class="headerlink" title="2.2 安装MySQL库"></a>2.2 安装MySQL库</h2><p>主要是安装mysql-server、mysql-client以及libmysqlclient-dev</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install mysql-server mysql-client libmysqlclient-dev <br></code></pre></td></tr></table></figure><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/TCP%E7%BD%91%E7%BB%9C%E8%81%8A%E5%A4%A9%E5%AE%A4/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/3.%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%AE%89%E8%A3%85MySQL%E5%BA%93-1-%E5%91%BD%E4%BB%A4.png" alt="服务器端安装MySQL库"  /></div><h2 id="2-3-安装libevent-dev的库"><a href="#2-3-安装libevent-dev的库" class="headerlink" title="2.3 安装libevent-dev的库"></a>2.3 安装libevent-dev的库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install libevent-dev<br></code></pre></td></tr></table></figure><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/TCP%E7%BD%91%E7%BB%9C%E8%81%8A%E5%A4%A9%E5%AE%A4/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/4.%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%AE%89%E8%A3%85Libevent%E5%BA%93-1-%E5%91%BD%E4%BB%A4.png" alt="服务器端安装Libevent库"  /></div><h2 id="2-4-安装libjsoncpp-dev库"><a href="#2-4-安装libjsoncpp-dev库" class="headerlink" title="2.4 安装libjsoncpp-dev库"></a>2.4 安装libjsoncpp-dev库</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install libjsoncpp-dev<br></code></pre></td></tr></table></figure><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/TCP%E7%BD%91%E7%BB%9C%E8%81%8A%E5%A4%A9%E5%AE%A4/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/5.%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%AE%89%E8%A3%85JSON%E5%BA%93-1-%E5%91%BD%E4%BB%A4.png" alt="服务器端安装JSON库"  /></div><h2 id="2-5-安装g-gcc编译器"><a href="#2-5-安装g-gcc编译器" class="headerlink" title="2.5 安装g++&#x2F;gcc编译器"></a>2.5 安装g++&#x2F;gcc编译器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt-get install gcc g++<br></code></pre></td></tr></table></figure><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/TCP%E7%BD%91%E7%BB%9C%E8%81%8A%E5%A4%A9%E5%AE%A4/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/6.%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%AB%AF%E5%AE%89%E8%A3%85gcc%E5%92%8Cg%2B%2B%E5%BA%93.png" alt="服务器端安装gcc和g++库"  /></div><h2 id="2-6-建立两张表user和chatgroup"><a href="#2-6-建立两张表user和chatgroup" class="headerlink" title="2.6 建立两张表user和chatgroup"></a>2.6 建立两张表user和chatgroup</h2><p>运行MySQL程序：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">mysql -u root -p<br></code></pre></td></tr></table></figure><p>创建两个数据库用于存储用户信息以及用户群组信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-keyword">create</span> database <span class="hljs-keyword">user</span>;<br><span class="hljs-keyword">create</span> database chatgroup;<br></code></pre></td></tr></table></figure><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/TCP%E7%BD%91%E7%BB%9C%E8%81%8A%E5%A4%A9%E5%AE%A4/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/7.%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%B8%A4%E4%B8%AAMySQL%E6%95%B0%E6%8D%AE%E5%BA%93.png" alt="创建两个MySQL数据库"  /></div>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C/C++『排序算法』</title>
    <link href="/2022/05/02/C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%89%8B%E6%92%95%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%812-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2022/05/02/C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%89%8B%E6%92%95%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%812-%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="前言：定义排序的结构和交换函数"><a href="#前言：定义排序的结构和交换函数" class="headerlink" title="前言：定义排序的结构和交换函数"></a>前言：定义排序的结构和交换函数</h1><p>在代码举例的过程中会用到顺序表结构，同时排序过程难免涉及数据交换，故此设计以下结构体和函数<br>顺序表结构如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义排序的所用到的结构</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 10</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    <span class="hljs-type">int</span> r[MAXSIZE + <span class="hljs-number">1</span>]; <span class="hljs-comment">//通常将r[0]作为哨兵或者临时变量</span><br>    <span class="hljs-type">int</span> Length;<span class="hljs-comment">//顺序表长度</span><br>&#125; SqList;<br></code></pre></td></tr></table></figure><p>交换函数如下所示：<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义在排序中常常用到的交换数据的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(SqList *L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> temp = L-&gt;r[i];<br>    L-&gt;r[i] = L-&gt;r[j];<br>    L-&gt;r[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>此外，为了使用统一的函数接口SqList，有些情况下的排序算法采取多层封装</p><hr><h1 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1 冒泡排序"></a>1 冒泡排序</h1><h2 id="1-1-交换排序"><a href="#1-1-交换排序" class="headerlink" title="1.1 交换排序"></a>1.1 交换排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 1.冒泡排序初级版，仅对顺序表L作交换排序，输入参数为一个顺序表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Bubble_Sort0</span><span class="hljs-params">(SqList *L)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; L-&gt;Length; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; L-&gt;Length; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (L-&gt;r[i] &gt; L-&gt;r[j])<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(L, i, j); <span class="hljs-comment">//交换L-&gt;r[i] 和 L-&gt;r[j] 的值</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-2-冒泡排序"><a href="#1-2-冒泡排序" class="headerlink" title="1.2 冒泡排序"></a>1.2 冒泡排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 2.冒泡排序，输入参数为一个顺序表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Bubble_Sort</span><span class="hljs-params">(SqList *L)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; L-&gt;Length; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (j = L-&gt;Length - <span class="hljs-number">1</span>; j &gt;= i; j--) <span class="hljs-comment">// j从后往前循环</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (L-&gt;r[j] &gt; L-&gt;r[j + <span class="hljs-number">1</span>]) <span class="hljs-comment">//若前者大于后者</span><br>            &#123;<br>                <span class="hljs-built_in">swap</span>(L, j, j + <span class="hljs-number">1</span>); <span class="hljs-comment">//交换L-&gt;r[j] 和 L-&gt;r[j+1] 的值</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-3-冒泡排序优化"><a href="#1-3-冒泡排序优化" class="headerlink" title="1.3 冒泡排序优化"></a>1.3 冒泡排序优化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 3.冒泡排序优化，输入参数为一个顺序表</span><br><span class="hljs-comment">// typedef bool Status;</span><br><span class="hljs-comment">// #define TRUE 1</span><br><span class="hljs-comment">// #define FALSE 0</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Bubble_Sort_Improve</span><span class="hljs-params">(SqList *L)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;                       <span class="hljs-comment">// flag用来做标记</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; L-&gt;Length &amp;&amp; flag; i++) <span class="hljs-comment">//若flag为false则退出循环</span><br>    &#123;<br>        flag = <span class="hljs-literal">false</span>;                        <span class="hljs-comment">// flag初始化为false</span><br>        <span class="hljs-keyword">for</span> (j = L-&gt;Length - <span class="hljs-number">1</span>; j &gt;= i; j--) <span class="hljs-comment">// j从后往前循环</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (L-&gt;r[j] &gt; L-&gt;r[j + <span class="hljs-number">1</span>]) <span class="hljs-comment">//若前者大于后者</span><br>            &#123;<br>                <span class="hljs-built_in">swap</span>(L, j, j + <span class="hljs-number">1</span>); <span class="hljs-comment">//交换L-&gt;r[j] 和 L-&gt;r[j+1] 的值</span><br>                flag = <span class="hljs-literal">true</span>;       <span class="hljs-comment">//如果有数据交换，则flag为true</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="2-简单选择排序"><a href="#2-简单选择排序" class="headerlink" title="2 简单选择排序"></a>2 简单选择排序</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//执行简单选择排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Select_Sort</span><span class="hljs-params">(SqList *L)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i, j, min;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; L-&gt;Length; i++)<br>    &#123;<br>        min = i; <span class="hljs-comment">//将当前下标定义为最小值下标</span><br>        <span class="hljs-keyword">for</span> (j = i + <span class="hljs-number">1</span>; j &lt; L-&gt;Length; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (L-&gt;r[min] &gt; L-&gt;r[j]) <span class="hljs-comment">//如果有小于当前最小值的关键字</span><br>            &#123;<br>                min = j; <span class="hljs-comment">//将此关键字的下标赋值给min</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i != min) <span class="hljs-comment">//若min不等于i，说明找到最小值，交换</span><br>        &#123;<br>            <span class="hljs-built_in">swap</span>(L, j, j + <span class="hljs-number">1</span>); <span class="hljs-comment">//交换L-&gt;r[j] 和 L-&gt;r[min] 的值</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="3-直接插入排序"><a href="#3-直接插入排序" class="headerlink" title="3 直接插入排序"></a>3 直接插入排序</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//执行插入排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert_Sort</span><span class="hljs-params">(SqList *L)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt; L-&gt;Length; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (L-&gt;r[i] &lt; L-&gt;r[i - <span class="hljs-number">1</span>])<br>        &#123;<br>            L-&gt;r[<span class="hljs-number">0</span>] = L-&gt;r[i]; <span class="hljs-comment">//设置哨兵</span><br>            <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; L-&gt;r[j] &gt; L-&gt;r[<span class="hljs-number">0</span>]; j--)<br>            &#123;<br>                L-&gt;r[j + <span class="hljs-number">1</span>] = L-&gt;r[j]; <span class="hljs-comment">//记录后移</span><br>            &#125;<br>            L-&gt;r[j] = L-&gt;r[<span class="hljs-number">0</span>]; <span class="hljs-comment">//插入到正确位置</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4 希尔排序"></a>4 希尔排序</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//执行希尔排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Shell_Sort</span><span class="hljs-params">(SqList *L)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-type">int</span> increment = L-&gt;Length;<br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        increment = increment / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (i = increment + <span class="hljs-number">1</span>; i &lt; L-&gt;Length; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (L-&gt;r[i] &lt; L-&gt;r[i - increment])<br>            &#123;<br>                <span class="hljs-comment">/*需将 L-&gt;r[i] 插入有序增量表w*/</span><br>                L-&gt;r[<span class="hljs-number">0</span>] = L-&gt;r[i]; <span class="hljs-comment">//暂存在L-&gt;r[0]</span><br>                <span class="hljs-keyword">for</span> (j = i - increment; j &gt; <span class="hljs-number">0</span> &amp;&amp; L-&gt;r[<span class="hljs-number">0</span>] &lt; L-&gt;r[j]; j++)<br>                &#123;<br>                    L-&gt;r[j + increment] = L-&gt;r[j]; <span class="hljs-comment">//记录后移，查找插入位置</span><br>                &#125;<br>                L-&gt;r[j + increment] = L-&gt;r[<span class="hljs-number">0</span>]; <span class="hljs-comment">//插入</span><br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (increment &gt; <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5 堆排序"></a>5 堆排序</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//首先本函数调整L-&gt;r[s]的关键字，使得L-&gt;r[s......m]成为一个大顶堆</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeapAdjust</span><span class="hljs-params">(SqList *L, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> temp;<br>    temp = L-&gt;r[s];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span> * s; j &lt;= m; j *= <span class="hljs-number">2</span>) <span class="hljs-comment">//沿关键字较大的的孩子节点向下筛选</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (j &lt; m &amp;&amp; L-&gt;r[j] &lt; L-&gt;r[j + <span class="hljs-number">1</span>])<br>        &#123;<br>            ++j; <span class="hljs-comment">// j为关键字中较大记录的下标</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (temp &gt;= L-&gt;r[j])<br>        &#123;<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// rc应当插入在位置s上</span><br>        &#125;<br>        L-&gt;r[s] = L-&gt;r[j];<br>        s = j;<br>    &#125;<br>    L-&gt;r[s] = temp; <span class="hljs-comment">//插入</span><br>&#125;<br><span class="hljs-comment">//然后执行堆排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Heap_Sort</span><span class="hljs-params">(SqList *L)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = L-&gt;Length / <span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-built_in">HeapAdjust</span>(L, i, L-&gt;Length); <span class="hljs-comment">//将L中的r构建成一个大顶堆</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = L-&gt;Length; i &gt; <span class="hljs-number">1</span>; i--)<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(L, <span class="hljs-number">1</span>, i);           <span class="hljs-comment">//将堆顶记录与当前未经排序的子序列的最后一个记录交换</span><br>        <span class="hljs-built_in">HeapAdjust</span>(L, <span class="hljs-number">1</span>, i - <span class="hljs-number">1</span>); <span class="hljs-comment">//将L-&gt;r[1.....i-1]重新调整为大顶堆</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6 归并排序"></a>6 归并排序</h1><h2 id="6-1-递归版归并排序"><a href="#6-1-递归版归并排序" class="headerlink" title="6.1 递归版归并排序"></a>6.1 递归版归并排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//首先归并两个序列</span><br><span class="hljs-comment">//将有序的两个序列SRC[i......m]和SRC[m+1......n]归并为有序的DES[i......n]</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(<span class="hljs-type">int</span> SRC[], <span class="hljs-type">int</span> DES[], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> j, k, l;<br>    <span class="hljs-keyword">for</span> (j = m + <span class="hljs-number">1</span>, k = i; j &lt;= m &amp;&amp; j &lt;= n; k++) <span class="hljs-comment">//将SRC中记录由小到大归并到DES中</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (SRC[i] &lt; SRC[j])<br>        &#123;<br>            DES[k] = SRC[i++];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            DES[k] = SRC[j++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i &lt;= m)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (l = <span class="hljs-number">0</span>; l &lt;= m - i; l++)<br>        &#123;<br>            DES[k + <span class="hljs-number">1</span>] = SRC[i + <span class="hljs-number">1</span>]; <span class="hljs-comment">//将剩余的SRC[i......m]复制到DES中</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (j &lt;= n)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (l = <span class="hljs-number">0</span>; l &lt;= n - j; l++)<br>        &#123;<br>            DES[k + <span class="hljs-number">1</span>] = SRC[j + <span class="hljs-number">1</span>]; <span class="hljs-comment">//将剩余的SRC[j......n]复制到DES中</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//然后外封装一个函数，将SRC[s......t]归并排序为DES[s......t]</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MSort</span><span class="hljs-params">(<span class="hljs-type">int</span> SRC[], <span class="hljs-type">int</span> DES[], <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> TEMP[MAXSIZE + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (s == t)<br>    &#123;<br>        DES[s] = SRC[s];<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        m = (s + t) / <span class="hljs-number">2</span>;            <span class="hljs-comment">//将SRC[s......t]平分为两个序列SRC[s......m]和SRC[m+1......t]</span><br>        <span class="hljs-built_in">MSort</span>(SRC, TEMP, s, m);     <span class="hljs-comment">//递归将SRC[s......m]归并为有序的TEMP[s......m]</span><br>        <span class="hljs-built_in">MSort</span>(SRC, TEMP, m + <span class="hljs-number">1</span>, t); <span class="hljs-comment">//递归将SRC[m+1......t]归并为有序的TEMP[m+1......t]</span><br>        <span class="hljs-built_in">Merge</span>(TEMP, DES, s, m, t);  <span class="hljs-comment">//将TEMP[s......m]和TEMP[m+1......t]归并到DES[s......t]</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//最后递归归并排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Merge_Sort_Recursion</span><span class="hljs-params">(SqList *L)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">MSort</span>(L-&gt;r, L-&gt;r, <span class="hljs-number">1</span>, L-&gt;Length);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-2-迭代版归并排序"><a href="#6-2-迭代版归并排序" class="headerlink" title="6.2 迭代版归并排序"></a>6.2 迭代版归并排序</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//首先</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergePass</span><span class="hljs-params">(<span class="hljs-type">int</span> SRC[], <span class="hljs-type">int</span> DES[], <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> j;<br>    <span class="hljs-keyword">while</span> (i &lt;= n - <span class="hljs-number">2</span> * s + <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">Merge</span>(SRC, DES, i, i + s - <span class="hljs-number">1</span>, i + <span class="hljs-number">2</span> * s - <span class="hljs-number">1</span>); <span class="hljs-comment">//两两归并</span><br>        i = i + <span class="hljs-number">2</span> * s;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i &lt; n - s + <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">Merge</span>(SRC, DES, i, i + s - <span class="hljs-number">1</span>, n); <span class="hljs-comment">//归并最后两个序列</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (j = i; j &lt;= n; j++) <span class="hljs-comment">//若剩下最后单个序列</span><br>        &#123;<br>            DES[j] = SRC[j];<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//然后迭代归并排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Merge_Sort_Iterate</span><span class="hljs-params">(SqList *L)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> *TR = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(L-&gt;Length * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>)); <span class="hljs-comment">//申请额外空间</span><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k &lt; L-&gt;Length)<br>    &#123;<br>        <span class="hljs-built_in">MergePass</span>(L-&gt;r, TR, k, L-&gt;Length);<br>        k = <span class="hljs-number">2</span> * k; <span class="hljs-comment">//子序列长度加倍</span><br>        <span class="hljs-built_in">MergePass</span>(TR, L-&gt;r, k, L-&gt;Length);<br>        k = <span class="hljs-number">2</span> * k; <span class="hljs-comment">//子序列长度加倍</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="7-快速排序"><a href="#7-快速排序" class="headerlink" title="7 快速排序"></a>7 快速排序</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//首先，交换顺序表中的子表记录，并使枢轴记录到位，并返回相应位置</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(SqList *L, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> pivotkey;<br>    pivotkey = L-&gt;r[low]; <span class="hljs-comment">//将表的第一个记录作枢轴记录</span><br>    <span class="hljs-keyword">while</span> (low &lt; high)    <span class="hljs-comment">//从表的两边交替向中间扫描</span><br>    &#123;<br>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; L-&gt;r[high] &gt;= pivotkey)<br>        &#123;<br>            high--;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(L, low, high); <span class="hljs-comment">//将比枢轴记录小的记录交换到低端</span><br>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; L-&gt;r[low] &lt;= pivotkey)<br>        &#123;<br>            low++;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(L, low, high); <span class="hljs-comment">//将比枢轴记录大的记录交换到高端</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> low; <span class="hljs-comment">//返回枢轴所在位置</span><br>&#125;<br><span class="hljs-comment">//然后，递归排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QSort</span><span class="hljs-params">(SqList *L, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> pivot;<br>    <span class="hljs-keyword">if</span> (low &lt; high)<br>    &#123;<br>        pivot = <span class="hljs-built_in">Partition</span>(L, low, high); <span class="hljs-comment">//将L-&gt;r[low ...... high]一分为二并算出枢轴值pivot</span><br>        <span class="hljs-built_in">QSort</span>(L, low, pivot - <span class="hljs-number">1</span>);        <span class="hljs-comment">//对低子表递归排序</span><br>        <span class="hljs-built_in">QSort</span>(L, pivot + <span class="hljs-number">1</span>, high);       <span class="hljs-comment">//对高子表递归排序</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//最后，执行快速排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Quick_Sort</span><span class="hljs-params">(SqList *L)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">QSort</span>(L, <span class="hljs-number">1</span>, L-&gt;Length);<br>&#125;<br></code></pre></td></tr></table></figure><p>快速排序算法的优化：</p><ol><li>优化选取枢轴—-三数取中（始终保持左端较小）：在Partition函数第3行和第4行插入如下代码</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> mid = low + (high - low)/<span class="hljs-number">2</span>;<br><span class="hljs-keyword">if</span> (L-&gt;r[low]&gt;L-&gt;r[high])<br>    <span class="hljs-built_in">swap</span>(L,low,high);<br><span class="hljs-keyword">if</span> (L-&gt;r[mid]&gt;L-&gt;r[high])<br>    <span class="hljs-built_in">swap</span>(L,mid,high);<br><span class="hljs-keyword">if</span> (L-&gt;r[mid]&gt;L-&gt;r[low])<br>    <span class="hljs-built_in">swap</span>(L,low,mid);<br></code></pre></td></tr></table></figure><ol start="2"><li><p>优化不必要交换—-在Partition函数中</p><ol><li>首先，将枢轴关键字pivotkey备份到L-&gt;r[0];</li><li>其次，采用替换而不是交换的方式进行操作;</li><li>再者，将枢轴数值替换回L-&gt;r[low];</li></ol></li><li><p>优化小数组时的排序方案<br>定义一个插入排序的最大数值【#define MAX_LENGTH_INSERT_SORT 7】<br>在QSort函数中high-low的值 如果大于这个定义值就用快速排序，如果小于等于这个定义值就用插入排序</p></li><li><p>优化递归操作</p><p>将QSort函数的if语句改成while语句，并将第二个QSort改为low&#x3D;pivot+1的尾递归</p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C/C++『查找算法』</title>
    <link href="/2022/05/01/C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%89%8B%E6%92%95%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%811-%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <url>/2022/05/01/C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98-%E6%89%8B%E6%92%95%E7%AE%97%E6%B3%95%E4%BB%A3%E7%A0%811-%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="1-顺序表查找"><a href="#1-顺序表查找" class="headerlink" title="1 顺序表查找"></a>1 顺序表查找</h1><h2 id="1-1-常规顺序表查找"><a href="#1-1-常规顺序表查找" class="headerlink" title="1.1 常规顺序表查找"></a>1.1 常规顺序表查找</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//顺序查找算法，a为数组，n为要查找的数组个数/数组下标最大值，key为要查找的关键字</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Sequential_Search</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (key == a[i])<br>            <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-2-顺序表查找的优化"><a href="#1-2-顺序表查找的优化" class="headerlink" title="1.2 顺序表查找的优化"></a>1.2 顺序表查找的优化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//顺序查找算法改进，a 为数组，n 为要查找的数组个数/数组下标最大值，key 为要查找的关键字</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Sequential_Search_Improve</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    i = n;      <span class="hljs-comment">//设置搜索范围从数组结尾开始</span><br>    a[<span class="hljs-number">0</span>] = key; <span class="hljs-comment">//设置a[0]为key，即设置哨兵（此时在a中一定有key值，如果返回下标为0，表示查询失败；如果返回下标非0，表示查询到key所在的位置）</span><br>    <span class="hljs-keyword">while</span> (a[i] != key)<br>    &#123;<br>        i--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i; <span class="hljs-comment">//返回0则表示查找失败</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="2-有序表查找"><a href="#2-有序表查找" class="headerlink" title="2 有序表查找"></a>2 有序表查找</h1><h2 id="2-1-折半查找-二分查找"><a href="#2-1-折半查找-二分查找" class="headerlink" title="2.1 折半查找&#x2F;二分查找"></a>2.1 折半查找&#x2F;二分查找</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//折半查找，又叫二分查找,a 为数组，n 为要查找的数组个数/数组下标最大值，key 为要查找的关键字</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Binary_Search</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> low, mid, high;<br>    low = <span class="hljs-number">1</span>;  <span class="hljs-comment">//定义最低下标为记录首位</span><br>    high = n; <span class="hljs-comment">//定义最高下标为记录末位</span><br>    <span class="hljs-keyword">while</span> (low &lt;= high)<br>    &#123;<br>        mid = (low + high) / <span class="hljs-number">2</span>; <span class="hljs-comment">//折半</span><br>        <span class="hljs-keyword">if</span> (key &lt; a[mid])       <span class="hljs-comment">//若查找值比中值小，则最高下标调整到 mid - 1 位</span><br>        &#123;<br>            high = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; a[mid]) <span class="hljs-comment">//若查找值比中值大，则最低下标调整到 mid + 1 位</span><br>        &#123;<br>            low = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">//若相等，则说明mid为key所查找的位置</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-插值查找"><a href="#2-2-插值查找" class="headerlink" title="2.2 插值查找"></a>2.2 插值查找</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//插值查找,a 为数组，n 为要查找的数组个数/数组下标最大值，key 为要查找的关键字</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Interporlation_Search</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> low, mid, high;<br>    low = <span class="hljs-number">1</span>;  <span class="hljs-comment">//定义最低下标为记录首位</span><br>    high = n; <span class="hljs-comment">//定义最高下标为记录末位</span><br>    <span class="hljs-keyword">while</span> (low &lt;= high)<br>    &#123;<br>        mid = low + (high - low) * (key - a[low]) / (a[high] - a[low]); <span class="hljs-comment">//插值</span><br>        <span class="hljs-keyword">if</span> (key &lt; a[mid])                                               <span class="hljs-comment">//若查找值比中值小，则最高下标调整到 mid - 1 位</span><br>        &#123;<br>            high = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; a[mid]) <span class="hljs-comment">//若查找值比中值大，则最低下标调整到 mid + 1 位</span><br>        &#123;<br>            low = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">//若相等，则说明mid为key所查找的位置</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-斐波拉契查找"><a href="#2-3-斐波拉契查找" class="headerlink" title="2.3 斐波拉契查找"></a>2.3 斐波拉契查找</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//斐波拉契查找,a 为数组，n 为要查找的数组个数/数组下标最大值，key 为要查找的关键字</span><br><br><span class="hljs-comment">//首先定义个斐波拉契分割函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> i == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fibonacci</span>(i - <span class="hljs-number">1</span>) + <span class="hljs-built_in">Fibonacci</span>(i - <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-comment">//然后定义斐波拉契搜索法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fibonacci_Search</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> low, high, mid, i, k;<br>    low = <span class="hljs-number">1</span>;  <span class="hljs-comment">//定义最低下标为记录首位</span><br>    high = n; <span class="hljs-comment">//定义最高下标为记录末位</span><br>    k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-built_in">Fibonacci</span>(k) - <span class="hljs-number">1</span>) <span class="hljs-comment">//计算n位于斐波拉契数列的位置</span><br>    &#123;<br>        k++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = n; i &lt; <span class="hljs-built_in">Fibonacci</span>(k) - <span class="hljs-number">1</span>; i++) <span class="hljs-comment">//将不满的数值补满</span><br>    &#123;<br>        a[i] = a[n];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (low &lt;= high)<br>    &#123;<br>        mid = low + <span class="hljs-built_in">Fibonacci</span>(k - <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>; <span class="hljs-comment">//计算当前分隔的下标</span><br>        <span class="hljs-keyword">if</span> (key &lt; a[mid])                 <span class="hljs-comment">//若查找记录小于当前分隔记录</span><br>        &#123;<br>            high = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">//最高下标调整到 mid - 1 位</span><br>            k = k - <span class="hljs-number">1</span>;      <span class="hljs-comment">//斐波拉契数列下标减一位</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; a[mid]) <span class="hljs-comment">//若查找记录大于当前分隔记录</span><br>        &#123;<br>            low = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">//最低下标调整到 mid + 1 位</span><br>            k = k - <span class="hljs-number">2</span>;     <span class="hljs-comment">//斐波拉契数列下标减两位</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (mid &lt;= n)<br>            &#123;<br>                <span class="hljs-keyword">return</span> mid; <span class="hljs-comment">//若相等则说明 mid 即为查找到的位置</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> n; <span class="hljs-comment">//若 mid &gt; n 则说明是补全数值，返回n</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="3-线性索引查找"><a href="#3-线性索引查找" class="headerlink" title="3 线性索引查找"></a>3 线性索引查找</h1><hr><h1 id="4-……"><a href="#4-……" class="headerlink" title="4 ……"></a>4 ……</h1>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C/C++『数据结构』</title>
    <link href="/2022/04/27/C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2022/04/27/C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h2><p>什么是数据结构？数据结构就是相互之间存在的一种或者多种特定关系的数据元素集合。</p><h2 id="2-数据结构的分类"><a href="#2-数据结构的分类" class="headerlink" title="2.数据结构的分类"></a>2.数据结构的分类</h2><p>按照视点不同分成<strong>逻辑结构</strong>和<strong>物理结构</strong>两种：</p><h3 id="2-1-逻辑结构"><a href="#2-1-逻辑结构" class="headerlink" title="2.1 逻辑结构"></a>2.1 逻辑结构</h3><p>逻辑结构是值数据对象中各个数据元素之间的相互关系。其大致可分为一下四种：</p><ol><li>集合结构：集合结构当中数据元素除<strong>同属一个集合</strong>外它们之间没任何关系。</li><li>线性结构：线性结构当中数据元素之间是<strong>一对一</strong>关系。</li><li>树形结构：树形结构当中数据元素之间存在<strong>一对多</strong>的层次关系。</li><li>图形结构：图形结构当中数据元素之间存在<strong>多对多</strong>关系。</li></ol><h3 id="2-2-物理结构"><a href="#2-2-物理结构" class="headerlink" title="2.2 物理结构"></a>2.2 物理结构</h3><p>物理结构是指数据的逻辑结构在计算机当中的存储形式。其大致可分为一下两种：</p><ol><li>顺序存储结构</li></ol><p>顺序存储结构是把数据元素存放在地址连续的存储单元中，其数据间的逻辑关系与物理关系保持一致。</p><ol start="2"><li>链式存储结构</li></ol><p>链式存储结构是把数据元素存在任意存储单元中。其存储单元可以连续也可以不连续。这就意味着数据存在哪里并不重要，只要用一个指针存储地址信息便能查找到它。</p><hr><h1 id="分类介绍"><a href="#分类介绍" class="headerlink" title="分类介绍"></a>分类介绍</h1><p>数据结构按照存储结构可大致分为：</p><ol><li><p><strong>线性表</strong>，具体的还可细分为顺序表（可近似理解为数组）、链表、栈和队列、串；</p></li><li><p><strong>树结构</strong>，包括普通树，二叉树，线索二叉树等；</p></li><li><p><strong>图结构</strong>。</p></li></ol><h2 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1.线性表"></a>1.线性表</h2><p>线性表是什么？线性表就是由零个或者多个数据元素组成的有限序列。其各元素依次排列，每个元素的前面和后边有且仅有一个元素与之相邻（首元素和尾元素除外）。</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="线性表结构"  /></div><blockquote><p><strong>注</strong>：线性表不只有一种存储结构，它包含了顺序存储结构和链式存储结构两种表述方式，是顺序表和链表的统称。作为特殊的线性表，栈和队列同样有顺序存储结构和链式存储结构两种表述方式</p></blockquote><ol><li><strong>顺序表</strong>：是线性表的顺序存储结构，即用一段地址连续的存储单元依次存储线性表的数据元素。顺序表结构的底层实现借助的是数组，可以把顺序表近似等价为数组。</li></ol><blockquote><p><strong>注</strong>：数据结构是研究数据存储方式的，它囊括的都是各种存储结构，而数组只是各种编程语言中的基本数据类型，并不属于数据结构的范畴。</p></blockquote><ol start="2"><li><strong>链表</strong>：是线性表的链式存储结构，即用一组任意的存储单元存储线性表的数据结构。</li><li><strong>栈和队列</strong>：栈和队列是特殊的线性表，因为它们对线性表的数据元素进出做出明确要求。<strong>栈</strong>是限定仅在表尾进行插入删除操作的线性表，又称为后进先出（<strong>LIFO</strong>）的线性表；而<strong>队列</strong>则是限定在表的一端进行插入操作，表的另一端进行删除操作的线性表，队列又称为先进先出（<strong>FIFO</strong>）的线性表。</li><li><strong>串</strong>：又叫字符串，是由另个或者多个多个字符组成的有限序列。</li></ol><h2 id="2-树结构"><a href="#2-树结构" class="headerlink" title="2.树结构"></a>2.树结构</h2><p>树（Tree）是 n（n≥0）个节点的有限集。树结构是典型的一对多关系。</p><p>当 n &#x3D; 0 时称为空树；</p><p>当 n ≠ 0 时的非空树中：</p><ul><li>有且仅有一个特定的节点称为根节点（Root）；</li><li>当 n &gt; 1 时，其余节点可以分割成若干个互不相交的子集，其每个集合本身也为一棵树，这棵树便是根的子树（SubTree）。</li></ul><p>特别的，当所有的节点的子集都不超过两个时称为二叉树。</p><p>特别的，堆是特殊的二叉树，即堆是完全二叉树。</p><h2 id="3-图结构"><a href="#3-图结构" class="headerlink" title="3.图结构"></a>3.图结构</h2><p>图是由定点的有穷非空集合与顶点之间边的集合组成，通常可表示为 G(V,E) ，其中 G 表示一个图，V 表示 G 当中定点的集合，E 表示 G 当中边的集合。图结构是典型的多对多关系。</p><h2 id="4-顺序表、树、图的关系"><a href="#4-顺序表、树、图的关系" class="headerlink" title="4.顺序表、树、图的关系"></a>4.顺序表、树、图的关系</h2><blockquote><p>线性表可以没有数据元素，称空表；树可以没有结点，称空树；而图当中不能没有顶点，因此图必须是有穷非空的。</p></blockquote><table><thead><tr><th align="center">存储类型</th><th align="center">数据元素名称</th><th align="center">相邻数据元素关系</th></tr></thead><tbody><tr><td align="center">线性表</td><td align="center">元素 (Element)</td><td align="center">线性关系</td></tr><tr><td align="center">树</td><td align="center">结点 (Node)</td><td align="center">层次关系</td></tr><tr><td align="center">图</td><td align="center">顶点 (Vertex)</td><td align="center">边（边集可以为空）</td></tr></tbody></table><hr><h1 id="一-顺序表（数组）"><a href="#一-顺序表（数组）" class="headerlink" title="一.顺序表（数组）"></a>一.顺序表（数组）</h1><p><strong>顺序表（SeqList）</strong>：是线性表的顺序存储结构，用一段地址连续的存储单元依次存储线性表的数据元素。顺序表结构的底层实现借助的是数组。顺序表的C++代码实现可参考如下链接：<a href="https://blog.csdn.net/weixin_48025315/article/details/119778068?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169391870016800186532858%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169391870016800186532858&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-119778068-null-null.142%5Ev93%5Einsert_down1&utm_term=SeqList&spm=1018.2226.3001.4187">顺序表（SeqList）的初始化、增、删、查、改等</a></p><h1 id="二-链表"><a href="#二-链表" class="headerlink" title="二.链表"></a>二.链表</h1><p><strong>链表（Linked List）</strong>：是线性表的链式存储结构，用一组任意的存储单元存储线性表的数据结构。</p><p>常用的链表建立方式：</p><ul><li><p>头插法（逆序建立链表）</p></li><li><p>尾插法（正序建立链表）</p></li></ul><h2 id="2-1-单链表"><a href="#2-1-单链表" class="headerlink" title="2.1 单链表"></a>2.1 单链表</h2><ol><li>结点定义</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 结点定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> SLTData; <span class="hljs-comment">// 定义单链表数据域类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SLTNode</span><br>&#123;<br>    SLTData data;  <span class="hljs-comment">// 数据域</span><br>    SLTNode *next; <span class="hljs-comment">// 指针域</span><br>&#125; SListNode;<br></code></pre></td></tr></table></figure><ol start="2"><li>创建单链表结点</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 创建单链表结点</span><br><span class="hljs-function">SListNode *<span class="hljs-title">SLTNode_Create</span><span class="hljs-params">(SLTData x)</span></span><br><span class="hljs-function"></span>&#123;<br>    SListNode *newNode = (SListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(SListNode));<br>    <span class="hljs-keyword">if</span> (newNode == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;内存申请失败&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    newNode-&gt;data = x;<br>    newNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> newNode;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>插入操作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 插入头插，尾插，指定pos前插，指定pos后插</span><br><span class="hljs-comment">// 单链表头插法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SLT_PushFront</span><span class="hljs-params">(SListNode **pphead, SLTData x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pphead);<br>    SListNode *newnode = <span class="hljs-built_in">SLTNode_Create</span>(x);<br>    newnode-&gt;next = *pphead;<br>    *pphead = newnode;<br>&#125;<br><br><span class="hljs-comment">// 单链表尾插法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SLT_PushBack</span><span class="hljs-params">(SListNode **pphead, SLTData x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pphead); <span class="hljs-comment">// 断言，验证pphead的合法性</span><br>    SListNode *newnode = <span class="hljs-built_in">SLTNode_Create</span>(x);<br>    <span class="hljs-comment">// 1.链表为空</span><br>    <span class="hljs-keyword">if</span> (*pphead == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        *pphead = newnode;<br>        <span class="hljs-comment">// 不需要让newnode-&gt;next=NULL,在SLTNode_Create函数中已经进行过此操作</span><br>    &#125;<br>    <span class="hljs-comment">// 2.链表不为空</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// 找到链表的尾巴tail</span><br>        SListNode *tail = *pphead;<br>        <span class="hljs-keyword">while</span> (tail-&gt;next)<br>        &#123;<br>            tail = tail-&gt;next;<br>        &#125;<br>        tail-&gt;next = newnode;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 单链表在指定pos前插入</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SLTInsertFront</span><span class="hljs-params">(SListNode **pphead, SListNode *pos, SLTData x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pphead);<br>    <span class="hljs-built_in">assert</span>(pos);<br><br>    SListNode *newnode = <span class="hljs-built_in">SLTNode_Create</span>(x);<br>    <span class="hljs-comment">// 头插</span><br>    <span class="hljs-keyword">if</span> ((*pphead)-&gt;next == pos)<br>    &#123;<br>        newnode-&gt;next = *pphead;<br>        *pphead = newnode;<br>    &#125;<br>    <span class="hljs-comment">// 非头插</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        SListNode *prev = *pphead;<br>        <span class="hljs-keyword">while</span> (prev-&gt;next != pos)<br>        &#123;<br>            prev = prev-&gt;next;<br>            <span class="hljs-built_in">assert</span>(prev-&gt;next);<br>        &#125;<br>        newnode-&gt;next = pos;<br>        prev-&gt;next = newnode;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 单链表在指定pos后插入</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SLTInsertBack</span><span class="hljs-params">(SListNode *phead, SListNode *pos, SLTData x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pos);<br>    SListNode *cur = phead;<br>    <span class="hljs-comment">// 防止pos传错了</span><br>    <span class="hljs-keyword">while</span> (cur != pos)<br>    &#123;<br>        cur = cur-&gt;next;<br>        <span class="hljs-built_in">assert</span>(pos);<br>    &#125;<br>    SListNode *newnode = <span class="hljs-built_in">SLTNode_Create</span>(x);<br>    newnode-&gt;next = pos-&gt;next;<br>    pos-&gt;next = newnode;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>删除操作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 删除  头删，尾删，在指定pos删</span><br><span class="hljs-comment">// 单链表头删法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SLT_PopFront</span><span class="hljs-params">(SListNode **pphead)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pphead);<br>    <span class="hljs-built_in">assert</span>(*pphead);<br>    SListNode *cur = *pphead;<br>    *pphead = (*pphead)-&gt;next;<br>    <span class="hljs-built_in">free</span>(cur);<br>    cur = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// 单链表尾删法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SLT_PopBack</span><span class="hljs-params">(SListNode **pphead)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pphead);<br>    <span class="hljs-built_in">assert</span>(*pphead);<br>    <span class="hljs-comment">// 1.链表只有一个元素</span><br>    <span class="hljs-comment">// 2.链表有两个及两个以上的元素</span><br>    <span class="hljs-keyword">if</span> ((*pphead)-&gt;next == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">free</span>(*pphead);<br>        *pphead = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        SListNode* tail = *pphead;<br>        <span class="hljs-keyword">while</span> (tail-&gt;next-&gt;next)<br>        &#123;<br>        tail = tail-&gt;next;<br>        &#125;<br>        <span class="hljs-built_in">free</span>(tail-&gt;next);<br>        tail-&gt;next = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 删除某个结点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SLT_PosErase</span><span class="hljs-params">(SListNode **pphead, SListNode *pos)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pphead);<br>    <span class="hljs-built_in">assert</span>(pos);<br>    <span class="hljs-comment">// 头删</span><br><br>    <span class="hljs-keyword">if</span> (*pphead == pos)<br>    &#123;<br>        SListNode *cur = *pphead;<br>        *pphead = (*pphead)-&gt;next;<br>        <span class="hljs-built_in">free</span>(cur);<br>        cur = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-comment">// 非头删</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        SListNode *prev = *pphead;<br>        <span class="hljs-keyword">while</span> (prev-&gt;next != pos)<br>        &#123;<br>            prev = prev-&gt;next;<br>            <span class="hljs-built_in">assert</span>(prev-&gt;next);<br>        &#125;<br>        prev-&gt;next = pos-&gt;next;<br>        <span class="hljs-built_in">free</span>(pos);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>修改操作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 单链表结点修改</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SLT_Alter</span><span class="hljs-params">(SLTNode *phead, SLTNode *pos, SLTData x)</span></span><br><span class="hljs-function"></span>&#123;<br>    SLTNode *cur = phead;<br>    <span class="hljs-keyword">while</span> (cur != pos)<br>    &#123;<br>        cur = cur-&gt;next;<br>        <span class="hljs-built_in">assert</span>(cur);<br>    &#125;<br>    pos-&gt;data = x;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li>查找操作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 单链表结点查找</span><br><span class="hljs-function">SListNode *<span class="hljs-title">SLT_Search</span><span class="hljs-params">(SListNode *phead, SLTData x)</span></span><br><span class="hljs-function"></span>&#123;<br>    SListNode *cur = phead;<br>    <span class="hljs-keyword">while</span> (cur)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (cur-&gt;data == x)<br>        &#123;<br>            <span class="hljs-keyword">return</span> cur;<br>        &#125;<br>        cur = cur-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="7"><li>单链表打印</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 打印单链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SLT_Print</span><span class="hljs-params">(SListNode *phead)</span></span><br><span class="hljs-function"></span>&#123;<br>    SListNode *cur = phead;<br>    <span class="hljs-keyword">while</span> (cur)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;%d-&gt;&quot;</span> &lt;&lt; cur-&gt;data; <span class="hljs-comment">// 打印当前结点</span><br>        cur = cur-&gt;next;             <span class="hljs-comment">// 指针指向下一个节点</span><br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;NULL&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">// 最后打印出来的效果如同 1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="8"><li>单链表销毁</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 销毁链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SLT_Destory</span><span class="hljs-params">(SListNode **pphead)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pphead);<br>    SListNode *cur = *pphead;<br>    <span class="hljs-keyword">while</span> (cur)<br>    &#123;<br>        SListNode *next = cur-&gt;next;<br>        <span class="hljs-built_in">free</span>(cur);<br>        cur = next;<br>    &#125;<br>    *pphead = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-双向链表"><a href="#2-2-双向链表" class="headerlink" title="2.2 双向链表"></a>2.2 双向链表</h2><h2 id="2-3-循环链表"><a href="#2-3-循环链表" class="headerlink" title="2.3 循环链表"></a>2.3 循环链表</h2><h2 id="2-4-静态链表"><a href="#2-4-静态链表" class="headerlink" title="2.4 静态链表"></a>2.4 静态链表</h2><h1 id="三-栈"><a href="#三-栈" class="headerlink" title="三.栈"></a>三.栈</h1><p><strong>栈（Stack）</strong>：是限定仅在表尾进行插入删除操作的线性表。栈是一种后进先出的线性表，称为 LIFO 。</p><h2 id="3-1-栈的顺序存储结构"><a href="#3-1-栈的顺序存储结构" class="headerlink" title="3.1 栈的顺序存储结构"></a>3.1 栈的顺序存储结构</h2><ol><li>栈基本参数的定义</li></ol><p>由于静态容量的栈结构实际上并不实用，因此下面主要实现动态容量的顺序栈。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义顺序栈的参数</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Stack_DataType; <span class="hljs-comment">// 栈中元素类型重命名为int</span><br><br><span class="hljs-comment">// 静态容量栈结构</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Stack_Capacity 20 <span class="hljs-comment">// 栈容量设定</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stack</span><br>&#123;<br>    Stack_DataType st[Stack_Capacity]; <span class="hljs-comment">// 定长数组</span><br>    <span class="hljs-type">int</span> top;                           <span class="hljs-comment">// 记录栈顶位置</span><br>&#125; Static_SeqStack;<br><br><span class="hljs-comment">// 动态容量栈结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stack</span><br>&#123;<br>    Stack_DataType *st; <span class="hljs-comment">// 指向动态开辟的数组</span><br>    <span class="hljs-type">int</span> top;            <span class="hljs-comment">// 记录栈顶位置</span><br>    <span class="hljs-type">int</span> capacity;       <span class="hljs-comment">// 栈容量设定</span><br>&#125; Dynamic_SeqStack;<br></code></pre></td></tr></table></figure><ol start="2"><li>栈的初始化</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stack_Init</span><span class="hljs-params">(DynamicStack *dst)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(dst);<br>    dst-&gt;a = <span class="hljs-literal">NULL</span>;<br>    dst-&gt;top = <span class="hljs-number">-1</span>;<br>    dst-&gt;capacity = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>栈的销毁</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 销毁栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stack_Destroy</span><span class="hljs-params">(DynamicStack *dst)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(dst);<br><br>    <span class="hljs-keyword">if</span> (dst-&gt;a)<br>    &#123;<br>        <span class="hljs-built_in">free</span>(dst-&gt;a);<br>    &#125;<br>    dst-&gt;a = <span class="hljs-literal">NULL</span>;<br>    dst-&gt;top = <span class="hljs-number">-1</span>;<br>    dst-&gt;capacity = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>入栈操作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 入栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stack_Push</span><span class="hljs-params">(DynamicStack *dst, Stack_DataType x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(dst);<br>    <span class="hljs-keyword">if</span> (dst-&gt;top == dst-&gt;capacity - <span class="hljs-number">1</span>) <span class="hljs-comment">// 检查栈空间是否满了</span><br>    &#123;<br>        <span class="hljs-comment">// 如果栈原始容量为0，新容量设为4，否则设为原始容量的2倍</span><br>        <span class="hljs-type">int</span> newcapacity = (dst-&gt;capacity == <span class="hljs-number">0</span>) ? <span class="hljs-number">4</span> : (dst-&gt;capacity) * <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 扩容至新容量</span><br>        Stack_DataType *temp = (Stack_DataType *)<span class="hljs-built_in">realloc</span>(dst-&gt;a, newcapacity * <span class="hljs-built_in">sizeof</span>(Stack_DataType));<br>        <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;申请内存失败&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        dst-&gt;a = temp;<br>        <span class="hljs-comment">// 更新容量</span><br>        dst-&gt;capacity = newcapacity;<br>    &#125;<br>    dst-&gt;top++;           <span class="hljs-comment">// 栈顶指针加一</span><br>    dst-&gt;a[dst-&gt;top] = x; <span class="hljs-comment">// 将新增元素放入栈顶空间</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>出栈操作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 出栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stack_Pop</span><span class="hljs-params">(DynamicStack *dst)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(dst);<br>    <span class="hljs-built_in">assert</span>(dst-&gt;top != <span class="hljs-number">-1</span>); <span class="hljs-comment">// 栈不能为空</span><br><br>    dst-&gt;top--; <span class="hljs-comment">// 栈顶指针减一</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li>检测栈是否为空</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 检测栈是否为空，如果为空返回true，否则返回NULL</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Stack_isEmpty</span><span class="hljs-params">(DynamicStack *dst)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(dst);<br>    <span class="hljs-keyword">return</span> dst-&gt;top == <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="7"><li>获取栈中有效元素个数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 获取栈中有效元素个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Stack_Size</span><span class="hljs-params">(DynamicStack *dst)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(dst);<br>    <span class="hljs-keyword">return</span> dst-&gt;top + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="8"><li>获取栈顶元素</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 获取栈顶元素</span><br><span class="hljs-function">Stack_DataType <span class="hljs-title">Stack_Top</span><span class="hljs-params">(DynamicStack *dst)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(dst);<br>    <span class="hljs-built_in">assert</span>(!<span class="hljs-built_in">Stack_isEmpty</span>(dst)); <span class="hljs-comment">// 栈不能为空</span><br><br>    <span class="hljs-keyword">return</span> dst-&gt;a[dst-&gt;top];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-栈的链式存储结构"><a href="#3-2-栈的链式存储结构" class="headerlink" title="3.2 栈的链式存储结构"></a>3.2 栈的链式存储结构</h2><p>由于栈只允许在表尾进行插入和删除元素操作。可以将单链表的尾部作为栈底，头部作为栈顶，方便插入和删除（进栈头插，出栈头删），这样头指针 head 和栈顶指针 top 就合二为一。</p><ol><li>栈的基本参数定义</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义链式栈的参数</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> LinkStack_DataType; <span class="hljs-comment">// 队列中元素类型重命名为int</span><br><span class="hljs-comment">// 定义链式栈的链表结点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LinkStackNode</span><br>&#123;<br><br>    LinkStack_DataType data; <span class="hljs-comment">// 数据域</span><br>    LinkStackNode *next;     <span class="hljs-comment">// 指针域</span><br>&#125; *LinkStackPtr;<br><br><span class="hljs-comment">// 定义栈的链式结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LinkStack</span><br>&#123;<br>    LinkStackNode *top;          <span class="hljs-comment">// 栈顶结点(表示整个链表的内存初始地址)</span><br>    LinkStack_DataType capacity; <span class="hljs-comment">// 栈容量</span><br>&#125; LinkStack;<br></code></pre></td></tr></table></figure><ol start="2"><li>链式栈的初始化</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化链式栈</span><br><span class="hljs-function">LinkStack *<span class="hljs-title">LinkStack_Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    LinkStack *mystack = (LinkStack *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LinkStack));<br>    mystack-&gt;capacity = <span class="hljs-number">0</span>;<br>    LinkStackNode *newNode = (LinkStackNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LinkStackNode));<br>    newNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>    mystack-&gt;top = newNode;<br>    <span class="hljs-keyword">return</span> mystack;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>链式栈的摧毁</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 摧毁链式栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LinkStack_Destory</span><span class="hljs-params">(LinkStack *ls)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(ls);<br>    LinkStackNode *cur = ls-&gt;top;<br>    <span class="hljs-keyword">while</span> (cur)<br>    &#123;<br>        LinkStackNode *next = cur-&gt;next;<br>        <span class="hljs-built_in">free</span>(cur);<br>        cur = next;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(ls);<br>    ls = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>入栈操作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 入栈操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LinkStack_Push</span><span class="hljs-params">(LinkStack *mystack, LinkStack_DataType data)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 创建一个临时结点</span><br>    LinkStackNode *newNode = (LinkStackNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LinkStackNode));<br>    newNode-&gt;data = data;<br>    newNode-&gt;next = mystack-&gt;top-&gt;next;<br>    mystack-&gt;top-&gt;next = newNode;<br>    mystack-&gt;capacity++;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>出栈操作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 出栈操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LinkStack_Pop</span><span class="hljs-params">(LinkStack *mystack)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (mystack-&gt;capacity == <span class="hljs-number">0</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;无法出栈&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// 创建一个临时结点</span><br>        LinkStackNode *newNode = mystack-&gt;top-&gt;next;<br>        mystack-&gt;top-&gt;next = newNode-&gt;next;<br>        newNode = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-built_in">free</span>(newNode);<br>        mystack-&gt;capacity--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li>判断栈是否为空</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 判断栈是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LinkStack_isEmpty</span><span class="hljs-params">(LinkStack *mystack)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">bool</span>)!mystack-&gt;capacity;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="7"><li>获取栈顶元素</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 获取栈顶元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LinkStack_Top</span><span class="hljs-params">(LinkStack *mystack)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (mystack-&gt;capacity == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> mystack-&gt;top-&gt;next-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="8"><li>获取栈中有效元素个数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 获取栈中有效元素个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LinkStack_Size</span><span class="hljs-params">(LinkStack *mystack)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(mystack);<br>    <span class="hljs-keyword">return</span> mystack-&gt;capacity;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-栈的应用"><a href="#3-3-栈的应用" class="headerlink" title="3.3 栈的应用"></a>3.3 栈的应用</h2><p>栈可应用于递归和四则运算</p><blockquote><p>注：递归和迭代的区别</p><ul><li><strong>递归</strong>：要解决一个问题，递归的思想是将这一问题通过递推式转换成另一小范围的表示，通过层层递归到达解决一个递归尽头的问题，然后层层返回解决这一问题</li><li><strong>迭代</strong>：要解决一个问题，迭代的思想是初始条件，通过初始条件以及一个递推式一次一次迭代，最终解决这一问题</li></ul></blockquote><h1 id="四-队列"><a href="#四-队列" class="headerlink" title="四.队列"></a>四.队列</h1><p><strong>队列（Queue）</strong>：是限定表的一端进行插入操作，表的另一端进行删除操作的线性表。队列是一种先进先出的线性表，称为 FIFO 。</p><ol><li>队列的顺序结构</li></ol><p>入队操作，不需要移动任何元素，时间复杂度为O(1)</p><p>出队操作，所有元素需要往前移动，时间复杂度为O(N)</p><ol start="2"><li>队列的链式结构</li></ol><p>首先我们定义两个指针，队头指针指向第一个节点，队尾指针指向尾节点</p><p>入队操作（尾插），时间复杂度为O(1)</p><p>出队操作（头删），时间复杂度为O(1)</p><h2 id="4-1-队列的顺序存储结构"><a href="#4-1-队列的顺序存储结构" class="headerlink" title="4.1 队列的顺序存储结构"></a>4.1 队列的顺序存储结构</h2><ol><li>顺序队列的定义</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义顺序队列的参数</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Queue_DataType; <span class="hljs-comment">// 队列中元素类型重命名为int</span><br><br><span class="hljs-comment">// 静态容量队列结构</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Queue_Capacity 20 <span class="hljs-comment">// 队列容量设定</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">StaticSeqQueue</span><br>&#123;<br>    Queue_DataType *base; <span class="hljs-comment">// 队列基地址</span><br>    <span class="hljs-type">int</span> front;            <span class="hljs-comment">// 记录队首</span><br>    <span class="hljs-type">int</span> rear;             <span class="hljs-comment">// 记录队尾</span><br>&#125; SeqQueue;<br></code></pre></td></tr></table></figure><ol start="2"><li>初始化顺序队列</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化顺序队列</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SeqQueue_Init</span><span class="hljs-params">(SeqQueue *dQ)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 为顺序队列开辟存储空间</span><br>    dQ-&gt;base = (Queue_DataType *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Queue_DataType) * Queue_Capacity);<br>    <span class="hljs-built_in">assert</span>(dQ-&gt;base != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 初始化时，队头和队尾都在0位置</span><br>    dQ-&gt;front = dQ-&gt;rear = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>入队操作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 入队操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SeqQueue_Push</span><span class="hljs-params">(SeqQueue *sQ, Queue_DataType x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 判断队列是否还有存储空间</span><br>    <span class="hljs-keyword">if</span> (sQ-&gt;rear &gt;= Queue_Capacity)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 如果还有存储空间，将数据入队</span><br>    sQ-&gt;base[sQ-&gt;rear++] = x;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>出队操作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 出队</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SeqQueue_pop</span><span class="hljs-params">(SeqQueue *sQ)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 判断队列中的元素是否为空</span><br>    <span class="hljs-keyword">if</span> (sQ-&gt;front == sQ-&gt;rear)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 如果队列中的元素不为空，进行出队操作</span><br>    sQ-&gt;front++;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>队列容量和队首元素的访问</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 获取队列元素个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SeqQueue_Capacity</span><span class="hljs-params">(SeqQueue *sQ)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//也可以将Capacity字段直接整合到队列结构体中</span><br>    <span class="hljs-comment">// 将尾指针位置减去头指针的位置就是队列中元素的个数</span><br>    <span class="hljs-keyword">return</span> (sQ-&gt;rear - sQ-&gt;front);<br>&#125;<br><br><span class="hljs-comment">// 获取队首元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SeqQueue_Front</span><span class="hljs-params">(SeqQueue *sQ, Queue_DataType *v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 判断队列中的元素是否为空</span><br>    <span class="hljs-keyword">if</span> (sQ-&gt;front == sQ-&gt;rear)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 如果队列中的元素不为空，取出队头元素</span><br>    *v = sQ-&gt;base[sQ-&gt;front];<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="6"><li>打印顺序队列的元素</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 打印顺序队列中的元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SeqQueue_Print</span><span class="hljs-params">(SeqQueue *sQ)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 遍历队头到队尾中的每个元素，并将其打印输出</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = sQ-&gt;front; i &lt; sQ-&gt;rear; ++i)<br>    &#123;<br>        cout &lt;&lt; sQ-&gt;base[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="7"><li>队列的清空与销毁</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 清空队列</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SeqQueue_Clear</span><span class="hljs-params">(SeqQueue *sQ)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 将队头指针和队尾指针都重置为0</span><br>    sQ-&gt;front = sQ-&gt;rear = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 销毁队列</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SeqQueue_Destroy</span><span class="hljs-params">(SeqQueue *sQ)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 释放队列的存储空间</span><br>    <span class="hljs-built_in">free</span>(sQ-&gt;base);<br>    <span class="hljs-comment">// 将队列空间的位置指针置空</span><br>    sQ-&gt;base = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-2-队列的链式存储结构"><a href="#4-2-队列的链式存储结构" class="headerlink" title="4.2 队列的链式存储结构"></a>4.2 队列的链式存储结构</h2><ol><li>链式队列结点定义</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 队列的定义</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Queue_DataType; <span class="hljs-comment">// 队列中元素类型重命名为int</span><br><br><span class="hljs-comment">// 定义队列链式结点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">QueueNode</span><br>&#123;<br>    Queue_DataType data;    <span class="hljs-comment">// 节点数据</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">QueueNode</span> *next; <span class="hljs-comment">// 节点指针</span><br>&#125; QueueNode;<br><br><span class="hljs-comment">// 定义队列的链式结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">QueuePtr</span><br>&#123;<br>    QueueNode *phead; <span class="hljs-comment">// 队头指针</span><br>    QueueNode *ptail; <span class="hljs-comment">// 队尾指针</span><br>&#125; LinkQueue;<br><br></code></pre></td></tr></table></figure><ol start="2"><li>判定队列是否为空</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 检查队列是否为空，若为空返回true，否则返回false</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Queue_isEmpty</span><span class="hljs-params">(LinkQueue *pQ)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pQ);<br>    <span class="hljs-keyword">return</span> pQ-&gt;phead == <span class="hljs-literal">NULL</span> &amp;&amp; pQ-&gt;ptail == <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>链式队列的初始化</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化队列</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Queue_Init</span><span class="hljs-params">(LinkQueue *pQ)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pQ);<br>    <span class="hljs-comment">// 队列为空</span><br>    pQ-&gt;phead = pQ-&gt;ptail = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>链式队列的销毁</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 销毁队列</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Queue_Destroy</span><span class="hljs-params">(LinkQueue *pQ)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pQ);<br><br>    QueueNode *cur = pQ-&gt;phead;<br>    <span class="hljs-keyword">while</span> (cur) <span class="hljs-comment">// 遍历链式队列</span><br>    &#123;<br>        QueueNode *next = cur-&gt;next;<br>        <span class="hljs-built_in">free</span>(cur);<br>        cur = next;<br>    &#125;<br>    cur = <span class="hljs-literal">NULL</span>;<br>    pQ-&gt;phead = pQ-&gt;ptail = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 队列为空</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>链式队列的入队操作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 入队（尾插法）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Queue_Push</span><span class="hljs-params">(LinkQueue *pQ, Queue_DataType x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pQ);<br><br>    QueueNode *newnode = (QueueNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(QueueNode)); <span class="hljs-comment">// 动态申请一个节点</span><br>    <span class="hljs-keyword">if</span> (newnode == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;动态申请失败&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    newnode-&gt;data = x;<br>    newnode-&gt;next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 尾节点next指针置空</span><br><br>    <span class="hljs-keyword">if</span> (pQ-&gt;phead == <span class="hljs-literal">NULL</span>) <span class="hljs-comment">// 队列为空</span><br>    &#123;<br>        pQ-&gt;phead = newnode;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// 队列不为空</span><br>    &#123;<br>        pQ-&gt;ptail-&gt;next = newnode;<br>    &#125;<br>    pQ-&gt;ptail = newnode; <span class="hljs-comment">// 更新队尾指针</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li>链式队列的出队操作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 出队（头删法）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Queue_Pop</span><span class="hljs-params">(LinkQueue *pQ)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pQ);<br>    <span class="hljs-built_in">assert</span>(!<span class="hljs-built_in">Queue_isEmpty</span>(pQ)); <span class="hljs-comment">// 队列不能为空</span><br><br>    <span class="hljs-keyword">if</span> (pQ-&gt;phead == pQ-&gt;ptail) <span class="hljs-comment">// 队列中只有一个节点</span><br>    &#123;<br>        <span class="hljs-built_in">free</span>(pQ-&gt;phead);<br>        pQ-&gt;phead = pQ-&gt;ptail = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        QueueNode *next = pQ-&gt;phead-&gt;next; <span class="hljs-comment">// 记录头节点的直接后继</span><br>        <span class="hljs-built_in">free</span>(pQ-&gt;phead);                   <span class="hljs-comment">// 释放头节点</span><br>        pQ-&gt;phead = next;                  <span class="hljs-comment">// 更新队头指针</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="7"><li>链式队列元素个数统计</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 获取队列元素个数</span><br><span class="hljs-comment">// 如果会频繁调用此接口函数，可以在QueuePtr结构体中加一个size字段记录数据个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Queue_Size</span><span class="hljs-params">(LinkQueue *pQ)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pQ);<br>    <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br>    QueueNode *cur = pQ-&gt;phead;<br>    <span class="hljs-keyword">while</span> (cur) <span class="hljs-comment">// 遍历链表</span><br>    &#123;<br>        size++;<br>        cur = cur-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> size;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="8"><li>链式队列的访问</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 链式队列元素查询</span><br><span class="hljs-comment">// 获取队头元素</span><br><span class="hljs-function">Queue_DataType <span class="hljs-title">QueueFront</span><span class="hljs-params">(LinkQueue *pQ)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pQ);<br>    <span class="hljs-built_in">assert</span>(!<span class="hljs-built_in">Queue_isEmpty</span>(pQ)); <span class="hljs-comment">// 队列不能为空</span><br><br>    <span class="hljs-keyword">return</span> pQ-&gt;phead-&gt;data;<br>&#125;<br><br><span class="hljs-comment">// 队列为空是获取不了队尾元素的</span><br><span class="hljs-comment">// 获取队尾元素</span><br><span class="hljs-function">Queue_DataType <span class="hljs-title">QueueBack</span><span class="hljs-params">(LinkQueue *pQ)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pQ);<br>    <span class="hljs-built_in">assert</span>(!<span class="hljs-built_in">Queue_isEmpty</span>(pQ)); <span class="hljs-comment">// 队列不能为空</span><br><br>    <span class="hljs-keyword">return</span> pQ-&gt;ptail-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-3-循环队列"><a href="#4-3-循环队列" class="headerlink" title="4.3 循环队列"></a>4.3 循环队列</h2><p>循环队列就是将正常的队列的队首与队尾相连形成一个循环。同普通队列一样，循环队列依然存在顺序存储结构与链式存储结构，本文便不作更多代码阐述。</p><blockquote><p>注意：</p><ol><li><p>循环队列中，tail 永远指向最后一个元素的下一个位置；</p></li><li><p>循环队列中，永远要多开一个存储空间。</p></li></ol></blockquote><h1 id="五-串（字符串）"><a href="#五-串（字符串）" class="headerlink" title="五.串（字符串）"></a>五.串（字符串）</h1><p><strong>串（String）</strong>：是由另个或者多个多个字符组成的有限序列，又称字符串。零个字符的串称为空串，可直接用 <strong>“”</strong> 表示。</p><blockquote><p>注：区分 char[]（或者char *） 与 string：</p><ul><li><p>char[]（char *）是一组 char 类型字符变量组成的，它就是一个数组，每个单元里面放一个字符数据；</p></li><li><p>string 是一个整体，以字符 ‘\0’ 作为分隔标识结尾，而且它还有很多<strong>类函数</strong>可以调用使用。</p></li></ul></blockquote><p>C++中有大量的字符串操作函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//复制字符串 s2 到字符串 s1</span><br><span class="hljs-built_in">strcpy</span>(s1, s2);<br><br><span class="hljs-comment">//连接字符串 s2 到字符串 s1 的末尾</span><br><span class="hljs-built_in">strcat</span>(s1, s2);<br><br><span class="hljs-comment">//返回字符串 s1 的长度</span><br><span class="hljs-built_in">strlen</span>(s1);<br><br><span class="hljs-comment">//如果 s1 和 s2 是相同的，则返回 0</span><br><span class="hljs-comment">//如果 s1&lt;s2 则返回值小于 0</span><br><span class="hljs-comment">//如果 s1&gt;s2 则返回值大于 0</span><br><span class="hljs-built_in">strcmp</span>(s1, s2);<br><br><span class="hljs-comment">//返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置</span><br><span class="hljs-built_in">strchr</span>(s1, ch);<br><br><span class="hljs-comment">//返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置</span><br><span class="hljs-built_in">strstr</span>(s1, s2);<br></code></pre></td></tr></table></figure><h2 id="5-1-串的顺序存储结构"><a href="#5-1-串的顺序存储结构" class="headerlink" title="5.1 串的顺序存储结构"></a>5.1 串的顺序存储结构</h2><p>串的顺序存储结构就是将所有字符数据元素保存在一个数组当中并以“\0”来表示字符串的结束。注意，字符串的长度加“\0”的长度不应当超过定义数组本身的长度。</p><h2 id="5-2-串的链式存储结构"><a href="#5-2-串的链式存储结构" class="headerlink" title="5.2 串的链式存储结构"></a>5.2 串的链式存储结构</h2><p>串的链式存储结构与链式表是相似的，由于串的结构中每个数据元素都是一个字符。</p><h1 id="六-树"><a href="#六-树" class="headerlink" title="六.树"></a>六.树</h1><p><strong>树（Tree）</strong>：是 n（n≥0）个节点的有限集。树结构是典型的<strong>一对多</strong>关系。</p><p>当 n &#x3D; 0 时称为空树；</p><p>当 n ≠ 0 时的非空树中：</p><ul><li>有且仅有一个特定的节点称为根节点（Root）；</li><li>当 n &gt; 1 时，其余节点可以分割成若干个互不相交的子集，其每个集合本身也为一棵树，这棵树便是根的子树（SubTree）。</li></ul><h1 id="七-堆（完全二叉树）"><a href="#七-堆（完全二叉树）" class="headerlink" title="七.堆（完全二叉树）"></a>七.堆（完全二叉树）</h1><p><strong>堆（Heap）</strong>：堆本质上就是一棵完全二叉树。与内存管理的堆区不同，这儿是说的是一种数据结构。</p><h2 id="7-1-堆的结构性质"><a href="#7-1-堆的结构性质" class="headerlink" title="7.1 堆的结构性质"></a>7.1 堆的结构性质</h2><p>堆一般使用数组来实现，即利用数组的索引来表示节点之间的关系。因此堆具有如下<strong>性质</strong>：</p><ol><li>根节点索引一般为 0 ；</li><li>对于堆中任意非根节点 i ，它的左孩子节点为 2 i + 1 ，右孩子节点为 2 i + 2 ，父节点为 ( i - 1 ) &#x2F; 2 ；</li><li>每个节点的左右子树也都必须是一个堆；</li><li>小堆不是升序，大堆不是降序。</li></ol><p>堆的实现参考如下链接：<a href="https://blog.csdn.net/weixin_48025315/article/details/123165836">堆（Heap）</a></p><h1 id="八-哈希"><a href="#八-哈希" class="headerlink" title="八.哈希"></a>八.哈希</h1><p><strong>哈希（Hash）</strong>：哈希表，又称为散列表，是根据码值访问的数据结构。哈希表的码就是数组的索引下标，然后通过码下标就可以直接访问数组中的数据元素。</p><p>C++ 中的哈希集合为 unordered_set，可以查找元素是否在集合中。如需同时存储键和值，则就要用 unordered_map 。</p><h2 id="8-1-哈希函数设计原则"><a href="#8-1-哈希函数设计原则" class="headerlink" title="8.1 哈希函数设计原则"></a>8.1 哈希函数设计原则</h2><p>哈希函数的设计原则：</p><ol><li><p>哈希函数的定义域必须包括需要存储的全部关键码，有m个地址的散列表的值域在 0 到 m-1 之间</p></li><li><p>哈希函数所计算的地址能均匀分布在整个空间中且尽量简单</p></li></ol><h2 id="8-2-常见哈希函数"><a href="#8-2-常见哈希函数" class="headerlink" title="8.2 常见哈希函数"></a>8.2 常见哈希函数</h2><p>常见的哈希构造函数：</p><ol><li>直接寻址法<br>取关键字的某个线性函数为哈希函数：H a s h ( k e y ) &#x3D; A ∗ k e y + B<br>优点：简单、均匀<br>缺点：需要事先知道关键字的分布情况<br>场景：适合查找比较小且连续的情况</li><li>除留余数法<br>设哈希表中允许的地址数为 m ，取一个不大于 m 且最接近或者等于m的质数 p 作为除数，<br>然后按照哈希函数：H a s h ( k e y ) &#x3D; k e y % p ( p &lt; &#x3D; m ) 将关键码转换成哈希地址</li><li>平方取中法<br>假设关键字为 1234 ，对它平方就是 1522756 ，抽取中间的 3 位 277 作为哈希地址；再比如关键字为 4321 ，对它平方就是 18671041 ，抽取中间的 3 位 671（或710）作为哈希地址。平方取中法比较适合：不知道关键字的分布，而位数又不是很大的情况。</li><li>折叠法<br>折叠法是将关键字从左到右分割成位数相等的几部分（最后一部分位数可以短些），然后将这几部分叠加求和，并按哈希表表长，取后几位作为哈希地址。</li><li>随机数法<br>选择一个随机函数，取关键字的随机函数值为它的哈希地址，即 H a s h ( k e y ) &#x3D; r a n d o m ( k e y )，其中 random 为随机数函数。</li><li>如果关键字由多位字符或者数字组成，就可以考虑抽取其中的两位或者多位作为该关键字对应的哈希地址，在取法上尽量选择变化较多的位，避免冲突发生。</li></ol><blockquote><p>注：哈希函数设计越精妙，就越不容易产生哈希冲突，尽管如此依然无法完全避免哈希冲突。</p></blockquote><h1 id="九-图"><a href="#九-图" class="headerlink" title="九.图"></a>九.图</h1><p><strong>图（Graph）</strong>：是由定点的有穷非空集合与顶点之间边的集合组成，通常可表示为 G(V,E) ，其中 G 表示一个图，V 表示 G 当中定点的集合，E 表示 G 当中边的集合。图结构是典型的<strong>多对多</strong>关系。更详细的内容可参照如下链接：<a href="https://blog.csdn.net/Real_Fool_/article/details/114141377?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169392471216800227439245%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169392471216800227439245&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114141377-null-null.142%5Ev93%5Einsert_down1&utm_term=graph&spm=1018.2226.3001.4187">图(Graph)</a></p><p>图的类型包括：有向图、无向、简单图、完全图（简单完全图）、多重图。</p><h2 id="9-1-图的存储"><a href="#9-1-图的存储" class="headerlink" title="9.1 图的存储"></a>9.1 图的存储</h2><p>图的任意两个顶点之间都可能存在联系，因此图无法用较为简单的顺序存储结构表示。而多重链表的方式，要么浪费众多存储单元，要么操作不方便。因此诞生如下五种图的存储结构：邻接矩阵，邻接表，十字链表，邻接多重表，边集数组。</p><ol><li>邻接矩阵：存储方式是用两个数组来表示图。一个一维数组存储顶点信息，一个二维数组存储图中边的信息；</li><li>邻接表：存储方式是用一个一维数组存储顶点信息，图中每个顶点形成的邻接点构成一个线性表（由于邻接点个数不定，则用单链表存储）；</li><li>十字链表：是邻接表与逆邻接表结合形成的；</li><li>邻接多重表：是针对有向图的邻接表处理；</li><li>边集数组：由两个一维数组构成。一个存储顶点信息，一个存储边的信息。而这个边的数组每个数据元素由一条边的起点下标（Begin）、终点下标（End）、权重（Weight）组成。</li></ol><h2 id="9-2-图的遍历"><a href="#9-2-图的遍历" class="headerlink" title="9.2 图的遍历"></a>9.2 图的遍历</h2><p>图的遍历通常是从某一顶点出发访问遍所有其余顶点，且使每个顶点仅被访问一遍。对于图的遍历，为了避免陷入回路的死循环，通常采用如下两种访问方式：</p><ol><li><strong>深度优先遍历（Depth_First_Search）</strong>：简称 DFS 搜索算法。具体操作为：从图中某一个顶点 v 出发访问此顶点，然后从 v 的为被访问的邻接点出发深度优先遍历图，直到图中所有和 v 有路径想通的顶点都被访问到。若图中有未被访问，则另外选取未曾访问的顶点出发重复如上操作直至图中所有顶点均被访问到。</li><li><strong>广度优先遍历（Breadth_First_Search）</strong>：简称 BFS 搜索算法，此种遍历方式类似于树的层序遍历。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C/C++『概念理解』</title>
    <link href="/2022/04/24/C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98_%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/"/>
    <url>/2022/04/24/C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98_%E6%A6%82%E5%BF%B5%E7%90%86%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="1-变量的声明和定义有什么区别"><a href="#1-变量的声明和定义有什么区别" class="headerlink" title="1 变量的声明和定义有什么区别"></a>1 变量的声明和定义有什么区别</h1><ul><li>变量的声明：告诉编译器变量的名称和类型称为声明，变量的声明不为变量分配地址和存储空间。</li><li>变量的定义：为变量分配地址和存储空间的称为定义。</li></ul><p><strong>注意</strong>：一个变量可以在多个地方声明，但是只在一个地方定义。很多时候一个变量，只是声明不分配内存空间，直到具体使用时才初始化，分配内存空间，如外部变量。</p><hr><h1 id="2-bool、int、float、指针变量与“零值”比较的if-语句"><a href="#2-bool、int、float、指针变量与“零值”比较的if-语句" class="headerlink" title="2 bool、int、float、指针变量与“零值”比较的if 语句"></a>2 bool、int、float、指针变量与“零值”比较的if 语句</h1><ul><li><p>bool 类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>( flag )<br>&#123;<br>A;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>B;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>int 类型:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>( <span class="hljs-number">0</span> != flag )<br>&#123;<br>A;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>B;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>float 类型:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span> ( ( flag &gt;= NORM ) &amp;&amp; ( flag &lt;= NORM ) )<br>&#123;<br>A；<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>指针类型：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">if</span>( <span class="hljs-literal">NULL</span> == flag )<br>&#123;<br>A;<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>B;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><hr><h1 id="3-sizeof-和-strlen-的区别"><a href="#3-sizeof-和-strlen-的区别" class="headerlink" title="3 sizeof 和 strlen 的区别"></a>3 sizeof 和 strlen 的区别</h1><ol><li>sizeof是操作符，strlen是库函数</li><li>sizeof的参数可以是数据类型，也可以是变量；strlen的参数必须是以”\0”结尾的字符串</li><li>sizeof在编译器编译时出结果，而strlen在运行时才出结果</li><li>sizeof计算的是数据类型占内存的大小，而strlen计算的是字符串的实际长度</li></ol><hr><h1 id="4-C-语言的关键字-static-和-C-的关键字-static-有什么区别"><a href="#4-C-语言的关键字-static-和-C-的关键字-static-有什么区别" class="headerlink" title="4 C 语言的关键字 static 和 C++ 的关键字 static 有什么区别"></a>4 C 语言的关键字 static 和 C++ 的关键字 static 有什么区别</h1><ul><li>在 C 中，static 用来是修饰局部静态变量和外部静态变量以及函数。</li><li>在 C++ 中，static 既可以用来是修饰局部静态变量和外部静态变量以及函数，也可以用来定义类的成员变量和函数。</li></ul><hr><h1 id="5-C语言中的malloc和C-中的new的区别"><a href="#5-C语言中的malloc和C-中的new的区别" class="headerlink" title="5 C语言中的malloc和C++中的new的区别"></a>5 C语言中的malloc和C++中的new的区别</h1><ul><li>malloc、free 是<strong>函数</strong>，<strong>可以覆盖</strong>，在 C、C++ 中都可以使用。</li><li>new、delete 是<strong>操作符</strong>，<strong>可以重载</strong>，只能在 C++中使用。</li><li>malloc 仅仅分配内存，free 仅仅回收内存，并不执行构造和析构函数。</li><li>new 可以调用对象的构造函数，对应的 delete 调用相应的析构函数。</li><li>new、delete 返回的是某种<strong>数据类型指针</strong>，malloc、free 返回的是 <strong>void 指针</strong>。</li></ul><hr><h1 id="6-“标准”宏-MIN和MAX"><a href="#6-“标准”宏-MIN和MAX" class="headerlink" title="6 “标准”宏 MIN和MAX"></a>6 “标准”宏 MIN和MAX</h1><ul><li><p>标准宏 MIN ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> min(a,b)((a)&lt;=(b)?(a):(b))</span><br></code></pre></td></tr></table></figure></li><li><p>标准宏 MAX ：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">define</span> max(a,b)((a)&gt;=(b)?(a):(b))</span><br></code></pre></td></tr></table></figure></li></ul><hr><h1 id="7-一个指针可以是-volatile-吗"><a href="#7-一个指针可以是-volatile-吗" class="headerlink" title="7 一个指针可以是 volatile 吗"></a>7 一个指针可以是 volatile 吗</h1><p>可以，因为指针和普通变量一样，有时也有变化程序的不可控性。常见例：子中断服务子程序修改<br>一个指向一个 buffer 的指针时，必须用 volatile 来修饰这个指针。</p><p><strong>注意</strong>：指针是一种普通的变量，从访问上没有什么不同于其他变量的特性。其保存的数值是个整型<br>数据，和整型变量不同的是，这个整型数据指向的是一段内存地址。</p><hr><h1 id="8-数组名-a-和-a-的区别"><a href="#8-数组名-a-和-a-的区别" class="headerlink" title="8 数组名 a 和 &amp;a 的区别"></a>8 数组名 a 和 &amp;a 的区别</h1><p>数组名 a 是数组的首地址，而 &amp;a 是数组的指针（即对数组名取地址的二级指针）</p><hr><h1 id="9-三种C-C-的内存分配机制"><a href="#9-三种C-C-的内存分配机制" class="headerlink" title="9 三种C&#x2F;C++的内存分配机制"></a>9 三种C&#x2F;C++的内存分配机制</h1><p>一个 C、C++ 程序编译时内存分为 5 大存储区：堆区、栈区、全局区、文字常量区、程序代码区。<strong>？？？？</strong></p><ul><li><p>栈：存放函数的参数和局部变量，编译器自动分配和释放</p></li><li><p>堆：new关键字动态分配的内存，由程序员手动进行释放，否则程序结束后，由操作系统自动进行回收</p></li><li><p>自由存储区：由malloc分配的内存，和堆十分相似，由对应的free进行释放</p></li><li><p>全局区：包含静态区和全局区。用于存放静态变量和全局变量</p></li><li><p>常量区：存放常量，不允许被修改</p></li></ul><h2 id="9-1-从静态存储区域分配"><a href="#9-1-从静态存储区域分配" class="headerlink" title="9.1 从静态存储区域分配"></a>9.1 从<strong>静态存储区域</strong>分配</h2><p>内存在程序编译时就已经分配好，这块内存在程序的整个运行期间都存在。</p><p><strong>优缺点</strong>：速度快、不容易出错，因为有系统会善后。例如全局变量，static 变量等。</p><h2 id="9-2-从栈上分配"><a href="#9-2-从栈上分配" class="headerlink" title="9.2 从栈上分配"></a>9.2 从<strong>栈</strong>上分配</h2><p>在执行函数时，函数内局部变量的存储单元都在栈上创建，函数执行结束时这些存储单元自动被释<br>放。</p><p><strong>优缺点</strong>：栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。</p><h2 id="9-3-从堆上分配-动态内存分配"><a href="#9-3-从堆上分配-动态内存分配" class="headerlink" title="9.3 从堆上分配(动态内存分配)"></a>9.3 从<strong>堆</strong>上分配(动态内存分配)</h2><p>程序在运行的时候用 malloc 或 new 申请任意大小的内存，程序员自己负责在何时用 free 或 delete 释放内存。</p><p><strong>优缺点</strong>：动态内存的生存期由程序员决定，使用非常灵活。如果在堆上分配了空间，就有责任回收它，否则运行的程序会出现内存泄漏，另外频繁地分配和释放不同大小的堆空间将会产生堆内碎块。</p><hr><h1 id="10-strcpy、sprintf、memcpy-的区别"><a href="#10-strcpy、sprintf、memcpy-的区别" class="headerlink" title="10 strcpy、sprintf、memcpy 的区别"></a>10 strcpy、sprintf、memcpy 的区别</h1><ol><li>操作对象不同：strcpy 的两个操作对象均为字符串，sprintf 的操作源对象可以是多种数据类型，目的操作对象是字符串，memcpy 的两个操作对象为两个任意可操作的内存地址，并不限于何种数据类型。</li><li>执行效率不同：memcpy 最高，strcpy 其次，sprintf 的效率最低。</li><li>实现功能不同：strcpy 主要实现字符串变量间的拷贝，sprintf 主要实现其他数据类型格式到字符串的转化，memcpy 主要是内存块间的拷贝。</li></ol><hr><h1 id="11-设置地址为-0x67a9-的整形变量值为-0xaa66"><a href="#11-设置地址为-0x67a9-的整形变量值为-0xaa66" class="headerlink" title="11 设置地址为 0x67a9 的整形变量值为 0xaa66"></a>11 设置地址为 0x67a9 的整形变量值为 0xaa66</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-type">int</span> *ptr;<span class="hljs-comment">//创建一个指针变量</span><br>ptr = <span class="hljs-number">0x67a9</span>;<span class="hljs-comment">//将指针地址赋值为0x67a9</span><br>*ptr = <span class="hljs-number">0xaa66</span>;<span class="hljs-comment">//将指针变量数值赋值为0xaa66</span><br></code></pre></td></tr></table></figure><p><strong>注意</strong>：一个整型数据可以强制转换成地址指针类型，只要有意义即可</p><hr><h1 id="12-面向对象的三大特征"><a href="#12-面向对象的三大特征" class="headerlink" title="12 面向对象的三大特征"></a>12 面向对象的三大特征</h1><p>面向对象的三大特性包括封装性、继承性和多态性。</p><h2 id="12-1-封装性"><a href="#12-1-封装性" class="headerlink" title="12.1 封装性"></a>12.1 封装性</h2><p>将客观事物抽象成类，每个类对应自己的数据和方法实行 protection（ private、protected、public ）</p><h2 id="12-2-继承性"><a href="#12-2-继承性" class="headerlink" title="12.2 继承性"></a>12.2 继承性</h2><p>广义继承有三种实现形式：实现继承、可视继承、接口继承</p><ul><li>实现继承：使用基类的属性和方法而无需额外编码的能力</li><li>可视继承：子窗体使用父窗体的外观和实现代码</li><li>接口继承：仅使用属性和方法,实现滞后到子类实现</li></ul><h2 id="12-3-多态性"><a href="#12-3-多态性" class="headerlink" title="12.3 多态性"></a>12.3 多态性</h2><p>是将父类对象设置成为和一个或更多它的子对象相等的技术。用子类对象给父类对象赋值之后，父类对象就可以根据当前赋值给它的子对象的特性以不同的方式运作。</p><h1 id="13-C-空类默认产生的6个类成员函数"><a href="#13-C-空类默认产生的6个类成员函数" class="headerlink" title="13 C++ 空类默认产生的6个类成员函数"></a>13 C++ 空类默认产生的6个类成员函数</h1><ul><li>缺省构造函数</li><li>缺省拷贝构造函数</li><li>缺省析构函数</li><li>缺省赋值运算符：<a href="https://blog.csdn.net/Achenming1314/article/details/105315561?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522165209850616782246494940%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=165209850616782246494940&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-2-105315561-null-null.142%5Ev9%5Epc_search_result_control_group,157%5Ev4%5Enew_style&utm_term=%E7%BC%BA%E7%9C%81%E8%B5%8B%E5%80%BC%E8%BF%90%E7%AE%97%E7%AC%A6&spm=1018.2226.3001.4187">赋值运算符讲解</a></li><li>缺省取址运算符（缺省的取地址运算符）</li><li>缺省取址运算符 const</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">A</span>  <br>&#123;  <br><span class="hljs-keyword">public</span>:  <br>    <span class="hljs-built_in">A</span>()&#123;&#125;<span class="hljs-comment">//缺省构造函数  </span><br>  <br>    <span class="hljs-built_in">A</span>(<span class="hljs-type">const</span> A&amp;)&#123;&#125;<span class="hljs-comment">//拷贝构造函数  </span><br>  <br>    ~<span class="hljs-built_in">A</span>()&#123;&#125;<span class="hljs-comment">//析构函数  </span><br>  <br>    A&amp;<span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> A&amp;)&#123;&#125;<span class="hljs-comment">//赋值运算符  </span><br>  <br>    A*<span class="hljs-keyword">operator</span>&amp;()&#123;&#125;<span class="hljs-comment">//取址运算符  </span><br>  <br>    <span class="hljs-type">const</span> A*<span class="hljs-keyword">operator</span>&amp;()<span class="hljs-type">const</span>&#123;&#125;<span class="hljs-comment">//取址运算符const  </span><br>&#125;;<br></code></pre></td></tr></table></figure><p><strong>注意</strong>：有些书上只是简单的介绍了前四个函数。没有提及后面这两个函数。但后面这两个函数也是空类的默认函数。另外需要注意的是，只有当实际使用这些函数的时候，编译器才会去定义它们。</p><hr><h1 id="14-拷贝构造函数和赋值运算符重载的不同"><a href="#14-拷贝构造函数和赋值运算符重载的不同" class="headerlink" title="14 拷贝构造函数和赋值运算符重载的不同"></a>14 拷贝构造函数和赋值运算符重载的不同</h1><ol><li>拷贝构造函数生成新的类对象，而赋值运算符不能</li><li>由于拷贝构造函数是直接构造一个新的类对象，所以在初始化这个对象之前不用检验源对象是否和新建对象相同。而赋值运算符则需要这个操作，另外赋值运算中如果原来的对象中有内存分配要先把内存释放</li></ol><p><strong>注意</strong>：当有类中有指针类型的成员变量时，一定要重写拷贝构造函数和赋值运算符，不要使用默认的。</p><hr><h1 id="15-类成员函数的重写、重载和隐藏的区别"><a href="#15-类成员函数的重写、重载和隐藏的区别" class="headerlink" title="15 类成员函数的重写、重载和隐藏的区别"></a>15 类成员函数的重写、重载和隐藏的区别</h1><h2 id="15-1-重写和重载的区别"><a href="#15-1-重写和重载的区别" class="headerlink" title="15.1 重写和重载的区别"></a>15.1 重写和重载的区别</h2><ol><li>范围区别：被重写的和重写的函数在两个类中，而重载和被重载的函数在同一个类中。</li><li>参数区别：被重写函数和重写函数的参数列表一定相同，而被重载函数和重载函数的参数列表一<br>定不同。</li><li>virtual区别：重写的基类中被重写的函数必须要有 virtual 修饰，而重载函数和被重载函数可以被virtual 修饰，也可以没有。</li></ol><h2 id="15-2-隐藏和重写、重载的区别"><a href="#15-2-隐藏和重写、重载的区别" class="headerlink" title="15.2 隐藏和重写、重载的区别"></a>15.2 隐藏和重写、重载的区别</h2><ol><li>与重载的范围不同：和重写一样，隐藏函数和被隐藏函数不在同一个类中。</li><li>参数的区别：隐藏函数和被隐藏的函数的参数列表可以相同，也可不同，但是函数名肯定要相同。<br>当参数不相同时，无论基类中的参数是否被 virtual 修饰，基类的函数都是被隐藏，而不是被重写。</li></ol><p><strong>注意</strong>：虽然重载和覆盖都是实现多态的基础，但是两者实现的技术完全不相同，达到的目的也是完<br>全不同的，覆盖是动态态绑定的多态，而重载是静态绑定的多态。</p><hr><h1 id="16-多态的实现原理"><a href="#16-多态的实现原理" class="headerlink" title="16 多态的实现原理"></a>16 多态的实现原理</h1><p>编译器发现一个类中有虚函数，便会立即为此类生成虚函数表 vtable。虚函数表的各表项为指向对应虚函数的指针。编译器还会在此类中隐含插入一个指针 vptr（对 vc 编译器来说，它插在类的第一个位置上）指向虚函数表。调用此类的构造函数时，在类的构造函数中，编译器会隐含执行 vptr 与 vtable 的关联代码，将 vptr 指向对应的 vtable，将类与此类的 vtable 联系了起来。另外在调用类的构造函数时，指向基础类的指针此时已经变成指向具体的类的 this 指针，这样依靠此 this 指针即可得到正确的 vtable，如此才能真正与函数体进行连接，这就是动态联编，实现多态的基本原理。</p><p><strong>注意</strong>：一定要区分虚函数，纯虚函数、虚拟继承的关系和区别。牢记虚函数实现原理，因为多态C++面试的重要考点之一，而虚函数是实现多态的基础。</p><hr><h1 id="17-链表和数组的区别"><a href="#17-链表和数组的区别" class="headerlink" title="17 链表和数组的区别"></a>17 链表和数组的区别</h1><ol><li>存储形式：数组是一块连续的空间，声明时就要确定长度。链表是一块可不连续的动态空间，长度可变，每个结点要保存相邻结点指针。</li><li>数据查找：数组的线性查找速度快，查找操作直接使用偏移地址。链表需要按顺序检索结点，效率低。</li><li>数据插入或删除：链表可以快速插入和删除结点，而数组则可能需要大量数据移动。</li><li>越界问题：链表不存在越界问题，数组有越界问题。</li></ol><p><strong>注意</strong>：在选择数组或链表数据结构时，一定要根据实际需要进行选择。数组便于查询，链表便于插入删除。数组节省空间但是长度固定，链表虽然变长但是占了更多的存储空间。</p><hr><h1 id="18-队列和栈的异同"><a href="#18-队列和栈的异同" class="headerlink" title="18 队列和栈的异同"></a>18 队列和栈的异同</h1><p>队列和栈都是线性存储结构，但是两者的插入和删除数据的操作不同，队列是“先进先出”，栈是“后进先出”。</p><p><strong>注意</strong>：区别栈区和堆区。堆区的存取是“顺序随意”，而栈区是“后进先出”。栈由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。堆一般由程序员分配释放， 若程序员不释放，程序结束时可能由 OS 回收。分配方式类似于链表。堆栈只是一种数据结构，而堆区和栈区是程序的不同内存存储区域。</p><hr><h1 id="19-对于规范编程的理解或认识"><a href="#19-对于规范编程的理解或认识" class="headerlink" title="19 对于规范编程的理解或认识"></a>19 对于规范编程的理解或认识</h1><p>编程规范可以总结为：程序的可行性、可读性、可移植性以及可测试性</p><p><strong>注意</strong>：这是编程规范的总纲目，面试者不一定要去背诵上面给出的那几个例子，应该去理解这几个<br>例子说明的问题，想一想，自己如何解决可行性、可读性、可移植性以及可测试性这几个问题，结合以<br>上几个例子和自己平时的编程习惯来回答这个问题。</p><hr><h1 id="20-short-i-0-i-i-1L；这两句有错吗"><a href="#20-short-i-0-i-i-1L；这两句有错吗" class="headerlink" title="20 short i &#x3D; 0; i &#x3D; i + 1L；这两句有错吗"></a>20 short i &#x3D; 0; i &#x3D; i + 1L；这两句有错吗</h1><p>代码一是错的，代码二是正确的</p><p><strong>注意</strong>：在数据安全的情况下大类型的数据向小类型的数据转换一定要显示的强制类型转换。</p><hr><h1 id="21-和-、-和-有什么区别"><a href="#21-和-、-和-有什么区别" class="headerlink" title="21 &amp;&amp;和&amp;、||和|有什么区别"></a>21 &amp;&amp;和&amp;、||和|有什么区别</h1><ul><li>&amp;和|对操作数进行<strong>求值运算</strong>，&amp;&amp;和||只是判断<strong>逻辑关系</strong>。</li><li>&amp;&amp;和||在在判断左侧操作数就能确定结果的情况下就不再对右侧操作数求值。</li></ul><p><strong>注意</strong>：在编程的时候有些时候将&amp;&amp;或||替换成&amp;或|没有出错，但是其逻辑是错误的，可能会导致不可预想的后果（比如当两个操作数一个是 1 另一个是 2 时）。</p><hr><h1 id="22-C-的引用和-C-语言的指针有什么区别"><a href="#22-C-的引用和-C-语言的指针有什么区别" class="headerlink" title="22 C++的引用和 C 语言的指针有什么区别"></a>22 C++的引用和 C 语言的指针有什么区别</h1><p>指针和引用主要有以下区别：</p><ol><li>引用必须被初始化，但是不分配存储空间。指针不声明时初始化，在初始化的时候需要分配存储空间。</li><li>引用初始化以后不能被改变，指针可以改变所指的对象。</li><li>不存在指向空值的引用，但是存在指向空值的指针。</li></ol><p><strong>注意</strong>：引用作为函数参数时，会引发一定的问题，因为让引用作参数，目的就是想改变这个引用所指向地址的内容，而函数调用时传入的是实参，看不出函数的参数是正常变量，还是引用，因此可能会引发错误。所以使用时一定要小心谨慎。</p><hr><h1 id="23-typedef-和-define-的区别"><a href="#23-typedef-和-define-的区别" class="headerlink" title="23 typedef 和 define 的区别"></a>23 typedef 和 define 的区别</h1><ul><li>用法不同：typedef 用来定义一种数据类型的别名，增强程序的可读性。define 主要用来定义<br>常量，以及书写复杂使用频繁的宏。</li><li>执行时间不同：typedef 是编译过程的一部分，有类型检查的功能。define 是宏定义，是预编译的部分，其发生在编译之前，只是简单的进行字符串的替换，不进行类型的检查。</li><li>作用域不同：typedef 有作用域限定。define 不受作用域约束，只要是在 define 声明后的引用都是正确的。</li><li>对指针的操作不同：typedef 和 define 定义的指针时有很大的区别。</li></ul><p><strong>注意</strong>：typedef 定义是语句，因为句尾要加上分号。而 define 不是语句，千万不能在句尾加分号。</p><hr><h1 id="24-关键字-const-是什么"><a href="#24-关键字-const-是什么" class="headerlink" title="24 关键字 const 是什么"></a>24 关键字 const 是什么</h1><p>const 用来定义一个只读的变量或对象。</p><p><strong>主要优点</strong>：便于类型检查、同宏定义一样可以方便地进行参数的修改和调整、节省空间，避免不必要的内存分配、可为函数重载提供参考。</p><p><strong>注意</strong>：const 修饰函数参数，是一种编程规范的要求，便于阅读，一看即知这个参数不能被改变，实现时不易出错。</p><hr><h1 id="25-static-有什么作用"><a href="#25-static-有什么作用" class="headerlink" title="25 static 有什么作用"></a>25 static 有什么作用</h1><p>static 在 C 中主要用于定义全局静态变量、定义局部静态变量、定义静态函数。在 C++中新增了两种作用：定义静态数据成员、静态函数成员。</p><p><strong>注意</strong>：因为 static 定义的变量分配在静态区，所以其定义的变量的默认值为 0，普通变量的默认值为随机数，在定义指针变量时要特别注意。</p><hr><h1 id="26-extern-有什么作用"><a href="#26-extern-有什么作用" class="headerlink" title="26 extern 有什么作用"></a>26 extern 有什么作用</h1><p>extern 标识的变量或者函数声明其定义在别的文件中，提示编译器遇到此变量和函数时在其它模块中寻找其定义。</p><hr><h1 id="27-流操作符重载为什么返回引用"><a href="#27-流操作符重载为什么返回引用" class="headerlink" title="27 流操作符重载为什么返回引用"></a>27 流操作符重载为什么返回引用</h1><p>在程序中，流操作符&gt;&gt;和&lt;&lt;经常连续使用。因此这两个操作符的返回值应该是一个仍旧支持这两个操作符的流引用。其他的数据类型都无法做到这一点。</p><p><strong>注意</strong>：除了在赋值操作符和流操作符之外的其他的一些操作符中，如+、-、*、&#x2F;等却千万不能返回引用。因为这四个操作符的对象都是右值，因此，它们必须构造一个对象作为返回值。</p><hr><h1 id="28-指针常量与常量指针的区别"><a href="#28-指针常量与常量指针的区别" class="headerlink" title="28 指针常量与常量指针的区别"></a>28 指针常量与常量指针的区别</h1><ul><li>指针常量是指定义了一个指针，这个指针的值只能在定义时初始化，其他地方不能改变；常量指针是指定义了一个指针，这个指针指向一个只读的对象，不能通过常量指针来改变这个对象的值。</li><li>指针常量强调的是指针的不可改变性；而常量指针强调的是指针对其所指对象的不可改变性。</li></ul><p><strong>注意</strong>：无论是指针常量还是常量指针，其最大的用途就是作为函数的形式参数，保证实参在被调用函数中的不可改变特性。</p><hr><h1 id="29-数组名和指针的区别"><a href="#29-数组名和指针的区别" class="headerlink" title="29 数组名和指针的区别"></a>29 数组名和指针的区别</h1><p>举例如下：<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">char</span> str[<span class="hljs-number">13</span>]=<span class="hljs-string">&quot;Hello world!&quot;</span>;<br><span class="hljs-type">char</span> *pStr=<span class="hljs-string">&quot;Hello world!&quot;</span>;<br>cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(str)&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-built_in">sizeof</span>(pStr)&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-built_in">strlen</span>(str)&lt;&lt;endl;<br>cout&lt;&lt;<span class="hljs-built_in">strlen</span>(pStr)&lt;&lt;endl;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>输出结果：<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-number">13</span><br><span class="hljs-number">4</span><br><span class="hljs-number">12</span><br><span class="hljs-number">12</span><br></code></pre></td></tr></table></figure></p><p><strong>注意</strong>：一定要记得数组名并不是真正意义上的指针，它的内涵要比指针丰富的多。但是当数组名当做参数传递给函数后，其失去原来的含义，变作普通的指针。另外要注意 sizeof 不是函数，只是操作符。</p><hr><h1 id="30-如何避免“野指针”"><a href="#30-如何避免“野指针”" class="headerlink" title="30 如何避免“野指针”"></a>30 如何避免“野指针”</h1><p><strong>定义：</strong>野指针不是NULL指针，是未初始化或者未清零的指针，它可能指向一块程序员未知的受限内存地址。</p><p>产生野指针的原因及解决办法：</p><ol><li>问题指针变量声明时没有被初始化。<strong>解决办法</strong>：指针声明时初始化，可以是具体的地址值，也可让它指向 NULL。</li><li>指针 p 被 free 或者 delete 之后，没有置为 NULL。<strong>解决办法</strong>：指针指向的内存空间被释放后指针应该指向 NULL。</li><li>指针操作超越了变量的作用范围，如比如数组b[10]范围为10，但指针为b+11。<strong>解决办法</strong>：在变量的作用域结束前释放掉变量的地址空间并且让指针指向 NULL。</li></ol><p><strong>注意</strong>：“野指针”的解决方法也是编程规范的基本原则，平时使用指针时一定要避免产生“野指针”，在使用指针前一定要检验指针的合法性。</p><hr><h1 id="31-常引用有什么作用"><a href="#31-常引用有什么作用" class="headerlink" title="31 常引用有什么作用"></a>31 常引用有什么作用</h1><p>常引用的引入主要是为了避免使用变量的引用时，在不知情的情况下改变变量的值。常引用主要用于定义一个普通变量的只读属性的别名、作为函数的传入形参，避免实参在调用函数中被意外的改变。</p><p><strong>注意</strong>：很多情况下，需要用常引用做形参，被引用对象等效于常对象，不能在函数中改变实参的值，这样的好处是有较高的易读性和较小的出错率。</p><hr><h1 id="32-用-C-编写一个死循环程序"><a href="#32-用-C-编写一个死循环程序" class="headerlink" title="32 用 C 编写一个死循环程序"></a>32 用 C 编写一个死循环程序</h1><p>代码如下：<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123; &#125;<br></code></pre></td></tr></table></figure></p><p>​</p><h1 id="33-构造函数与析构函数能否为虚函数"><a href="#33-构造函数与析构函数能否为虚函数" class="headerlink" title="33 构造函数与析构函数能否为虚函数"></a>33 构造函数与析构函数能否为虚函数</h1><p><strong>构造函数</strong>不能是虚函数。而且不能在构造函数中调用虚函数，因为那样实际执行的是父类的对应函数，因为自己还没有构造好。</p><p><strong>析构函数</strong>可以是虚函数，而且，在一个复杂类结构中，这往往是必须的。析构函数也可以是纯虚函数，但纯虚析构函数必须有定义体，因为析构函数的调用是在子类中隐含的。</p><p><strong>注意</strong>：虚函数的动态绑定特性是实现重载的关键技术，动态绑定根据实际的调用情况查询相应类的<br>虚函数表，调用相应的虚函数。</p><h2 id="33-1-构造函数不能为虚函数"><a href="#33-1-构造函数不能为虚函数" class="headerlink" title="33.1 构造函数不能为虚函数"></a>33.1 构造函数不能为虚函数</h2><ol><li><strong>从存储空间理解</strong>：虚函数对应一个 vtable ，而这个 vtable 其实是存储在对象的内存空间的。那么就有问题是：如果构造函数是虚的，就需要通过 vtable 调用，而此时对象还没有实例化，无法找到 vtable ，因此构造函数不能为虚函数 。</li><li><strong>从使用角度理解</strong>：虚函数主要用于在信息不全的情况下，能使重载的函数得到对应的调用。构造函数本身就是要初始化实例的，那么使用虚函数也就没有实际意义，因此构造函数不能为虚函数。**(** 虚函数的作用在于通过父类的指针挥着引用来调用他的时候能够变成调用子类的那个成员函数。而构造函数是在创建对象时自动调用的不可能通过父类指针或者引用去调用，因此构造函数不能为虚函数。**)**</li><li><strong>从实现上理解</strong>：vbtl 在构造函数调用后才建立，因此构造函数不能为虚函数。</li><li>综上所述，构造函数不需要是虚函数，也不允许是虚函数，因为创建一个对象时我们总是要明确指定对象的类型，尽管我们肯能通过基类的指针或者引用去访问它。但是析构却不一定，我们往往通过及尅的指针来销毁对象。这时候如果析构函数不是虚函数，就不能正确识别对象类型而不能正确调用析构函数。</li></ol><h2 id="33-2-析构函数最好是虚函数"><a href="#33-2-析构函数最好是虚函数" class="headerlink" title="33.2 析构函数最好是虚函数"></a>33.2 析构函数最好是虚函数</h2><ol><li><p>当析构一个指向派生类的基类指针时，最好将基类的析构函数声明为虚函数，否则可以存在内存泄露的问题。</p></li><li><p>如果析构函数不被声明成虚函数，则编译器实施静态绑定，在删除指向派生类的基类指针时，只会调用基类的析构函数而不调用派生类析构函数，这样就会造成派生类对象析构不完全。</p></li></ol><hr><h1 id="34-对于面向对象的认识"><a href="#34-对于面向对象的认识" class="headerlink" title="34 对于面向对象的认识"></a>34 对于面向对象的认识</h1><p>面向对象可以理解成对待每一个问题，都是首先要确定这个问题由几个部分组成，而每一个部分其实就是一个对象。然后再分别设计这些对象，最后得到整个程序。传统的程序设计多是基于功能的思想来进行考虑和设计的，而面向对象的程序设计则是基于对象的角度来考虑问题。这样做能够使得程序更加的简洁清晰。</p><p><strong>注意</strong>：编程中接触最多的“面向对象编程技术”仅仅是面向对象技术中的一个组成部分。发挥面向对象技术的优势是一个综合的技术问题，不仅需要面向对象的分析，设计和编程技术，而且需要借助必要的建模和开发工具。</p><hr><h1 id="35-静态绑定和动态绑定的介绍"><a href="#35-静态绑定和动态绑定的介绍" class="headerlink" title="35 静态绑定和动态绑定的介绍"></a>35 静态绑定和动态绑定的介绍</h1><p>静态绑定和动态绑定是C++<strong>多态</strong>的一种特性</p><h2 id="35-1-对象的静态类型和动态类型"><a href="#35-1-对象的静态类型和动态类型" class="headerlink" title="35.1 对象的静态类型和动态类型"></a>35.1 对象的静态类型和动态类型</h2><ul><li><p>静态类型：对象在声明时采用的类型，在编译时确定</p></li><li><p>动态类型：当前对象所指的类型，在运行期决定，对象的动态类型可变，静态类型无法更改</p></li></ul><h2 id="35-2-静态绑定和动态绑定"><a href="#35-2-静态绑定和动态绑定" class="headerlink" title="35.2 静态绑定和动态绑定"></a>35.2 静态绑定和动态绑定</h2><ul><li><p>静态绑定：绑定的是对象的静态类型，函数依赖于对象的静态类型，在编译期确定</p></li><li><p>动态绑定：绑定的是对象的动态类型，函数依赖于对象的动态类型，在运行期确定</p></li></ul><p><strong>注意：</strong>只有虚函数才使用的是动态绑定，其他的全部是静态绑定</p><h2 id="35-3-为什么引用可以实现动态绑定"><a href="#35-3-为什么引用可以实现动态绑定" class="headerlink" title="35.3 为什么引用可以实现动态绑定"></a>35.3 为什么引用可以实现动态绑定</h2><p>因为引用（或指针）既可以指向基类对象也可以指向派生类对象，这一事实是动态绑定的关键。用引用（或指针）调用的虚函数在运行时确定，被调用的函数是引用（或指针）所指的对象的实际类型所定义的。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL2的子系统部署</title>
    <link href="/2022/01/15/Win11%E7%8E%AF%E5%A2%83%E4%B8%8BWSL2%E7%9A%84%E5%AD%90%E7%B3%BB%E7%BB%9F%E9%83%A8%E7%BD%B2/"/>
    <url>/2022/01/15/Win11%E7%8E%AF%E5%A2%83%E4%B8%8BWSL2%E7%9A%84%E5%AD%90%E7%B3%BB%E7%BB%9F%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h1 id="一-WSL2下Linux系统的安装"><a href="#一-WSL2下Linux系统的安装" class="headerlink" title="一.WSL2下Linux系统的安装"></a>一.WSL2下Linux系统的安装</h1><h2 id="1-1-先期工作"><a href="#1-1-先期工作" class="headerlink" title="1.1 先期工作"></a>1.1 先期工作</h2><ol><li>打开控制面板选择程序与功能项</li></ol><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF.png" alt="打开控制面板选择程序与功能"></p><ol start="2"><li>打开</li></ol><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8A%9F%E8%83%BD.png" alt="选择启用或者关闭Windows功能"></p><ol start="3"><li>启用虚拟机服务相关配置项</li></ol><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E5%8B%BE%E9%80%89%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E9%A1%B9.png" alt="启用虚拟机相关服务"></p><h2 id="1-2-检查WSL2"><a href="#1-2-检查WSL2" class="headerlink" title="1.2 检查WSL2"></a>1.2 检查WSL2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --update<br></code></pre></td></tr></table></figure><blockquote><p>出现如下问题的解决方法：</p><p>Error: 0x80d03805</p><p>Error code: Wsl&#x2F;UpdatePackage&#x2F;0x80d03805</p><p>重启系统重新输入命令行发现此问题消失</p></blockquote><h2 id="1-3-设置WSL的默认版本"><a href="#1-3-设置WSL的默认版本" class="headerlink" title="1.3 设置WSL的默认版本"></a>1.3 设置WSL的默认版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --set-default-version 2<br></code></pre></td></tr></table></figure><h2 id="1-4-查看有效分发列表"><a href="#1-4-查看有效分发列表" class="headerlink" title="1.4 查看有效分发列表"></a>1.4 查看有效分发列表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl -l -o<br></code></pre></td></tr></table></figure><h2 id="1-5-安装指定分发版本的Linux系统"><a href="#1-5-安装指定分发版本的Linux系统" class="headerlink" title="1.5 安装指定分发版本的Linux系统"></a>1.5 安装指定分发版本的Linux系统</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl.exe --install &lt;Distribution Name&gt;<br></code></pre></td></tr></table></figure><p>输入安装完毕后会要求输入<strong>用户名</strong>、设置<strong>密码</strong>及确认</p><h2 id="1-6-更换镜像源"><a href="#1-6-更换镜像源" class="headerlink" title="1.6 更换镜像源"></a>1.6 更换镜像源</h2><p>首先访问配置文件并输入ggdg并回车清空文本内容，然后访问并更换为<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">清华源</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /etc/apt/sources.list<br></code></pre></td></tr></table></figure><p>设置清华源时候进行如下设置：</p><ol><li>是否使用HTTPS勾选<strong>是</strong></li><li>是否使用sudo勾选<strong>是</strong></li><li>Ubuntu版本选择安装的版本，如：Ubuntu-22.04 LTS</li><li>启用源码源勾选<strong>是</strong></li><li>启用proposed勾选<strong>否</strong></li><li>启用源码镜像勾选<strong>是</strong></li></ol><p>然后更新源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br></code></pre></td></tr></table></figure><h2 id="1-7-WSL下的Linux卸载"><a href="#1-7-WSL下的Linux卸载" class="headerlink" title="1.7 WSL下的Linux卸载"></a>1.7 WSL下的Linux卸载</h2><p>首先查看WSL下安装的Linux系统版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --list<br></code></pre></td></tr></table></figure><p>然后选择需要删除卸载的Linux系统版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --unregister &lt;Distribution Name&gt;<br></code></pre></td></tr></table></figure><h2 id="1-8-更改WSL默认登录用户"><a href="#1-8-更改WSL默认登录用户" class="headerlink" title="1.8 更改WSL默认登录用户"></a>1.8 更改WSL默认登录用户</h2><ol><li>首先关闭WSL子系统</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --shutdown<br></code></pre></td></tr></table></figure><ol start="2"><li>然后设置登录默认用户</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;Distribution Name&gt; config --default-user &lt;Username&gt; <span class="hljs-comment"># 如Ubuntu2204.exe</span><br><span class="hljs-comment"># Ubuntu2004.exe config --default-user dustwind</span><br></code></pre></td></tr></table></figure><h2 id="1-9-更改WSL子系统安装盘符"><a href="#1-9-更改WSL子系统安装盘符" class="headerlink" title="1.9 更改WSL子系统安装盘符"></a>1.9 更改WSL子系统安装盘符</h2><p>由于WSL子系统默认安装在C盘下，然而受限于C盘本身容量过小或者是C盘安装软件过多，则有将WSL子系统安装到其他盘的需求。</p><ol><li>首先查看WSL分发版本</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl -l --all -v<br></code></pre></td></tr></table></figure><ol start="2"><li>然后将分发版系统打包导出到指定盘</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --<span class="hljs-built_in">export</span> &lt;Distribution Name&gt; &lt;Destination Path&gt;<br><span class="hljs-comment"># 举例如下：</span><br><span class="hljs-comment"># wsl --export Ubuntu-20.04 F:\wsl-ubuntu20.04.tar</span><br></code></pre></td></tr></table></figure><ol start="3"><li>注销当前分发版本</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --unregister &lt;Distribution Name&gt;  <span class="hljs-comment"># 如 Ubuntu-22.04</span><br></code></pre></td></tr></table></figure><ol start="4"><li>在另一个盘重新导入分发版本</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --import &lt;Distribution Name&gt; &lt;Destination Path&gt; &lt;Unzip File&gt; --version 2<br><span class="hljs-comment"># 举例如下：</span><br><span class="hljs-comment"># wsl --import Ubuntu-20.04 F:\wsl-ubuntu20.04 F:\wsl-ubuntu20.04.tar --version 2</span><br></code></pre></td></tr></table></figure><ol start="5"><li><p>设置默认登陆用户为安装时用户名可参考 <strong>1.8</strong> 小节所示</p></li><li><p>删除打包文件</p></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">del &lt;FileName&gt; <span class="hljs-comment"># 可以加入绝对路径</span><br><span class="hljs-comment"># 举例如下：</span><br><span class="hljs-comment"># del F:\wsl-ubuntu22.04.tar</span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong></p><ol><li><p>不知道shell参数可使用 wsl –help 命令查看使用</p></li><li><p>更详细WSL常用命令汇总可参照：<a href="https://blog.csdn.net/penngo/article/details/129951281?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170229523816800225597067%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170229523816800225597067&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-129951281-null-null.142%5Ev96%5Econtrol&utm_term=wsl%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4&spm=1018.2226.3001.4187">WSL 的基本命令</a></p></li></ol></blockquote><h1 id="二-WSL2中安装Linux桌面环境"><a href="#二-WSL2中安装Linux桌面环境" class="headerlink" title="二.WSL2中安装Linux桌面环境"></a>二.WSL2中安装Linux桌面环境</h1><p>桌面安装提供如下两种方式，首选第一个安装方式</p><ol><li><p><a href="https://blog.csdn.net/weixin_44478077/article/details/128723158?spm=1001.2014.3001.5506">WSL2 Ubuntu+gnome图形界面的安装血泪史（亲测有效）</a></p></li><li><p><a href="https://blog.csdn.net/m0_51194302/article/details/127891929?spm=1001.2014.3001.5506">wsl安装ubuntu并设置gnome图形界面详细步骤（win11+ubuntu18）</a></p></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>WSL</tag>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Qt开发『概念理解』</title>
    <link href="/2022/01/13/Qt%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>/2022/01/13/Qt%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><p>本文根据 <a href="https://github.com/0voice/qt_interview_reference">0voice大佬整理汇总</a> 的内容进一步提炼总结而成。感谢 0voice 大佬汇总。</p><h2 id="1-在Qt多线程环境中，如何控制信号槽在哪个线程中执行"><a href="#1-在Qt多线程环境中，如何控制信号槽在哪个线程中执行" class="headerlink" title="1 在Qt多线程环境中，如何控制信号槽在哪个线程中执行"></a>1 在Qt多线程环境中，如何控制信号槽在哪个线程中执行</h2><p>通过connect方法的第五个参数可以控制信号槽执行所在线程。</p><p>connect有三种连接方式，直接连接、队列连接和自动连接</p><ul><li><p>直接连接（Qt::DirectConnection）：信号槽在信号发出者所在的线程中执行</p></li><li><p>队列连接 (Qt::QueuedConnection)：信号在信号发出者所在的线程中执行，槽函数在信号接收者所在的线程中执行</p></li><li><p>自动连接  (Qt::AutoConnection)：多线程时为队列连接函数，单线程时为直接连接函数。</p></li></ul><h2 id="2-UDP协议的通信流程"><a href="#2-UDP协议的通信流程" class="headerlink" title="2 UDP协议的通信流程"></a>2 UDP协议的通信流程</h2><p>在Qt开发中使用QUdpSocket类进行UDP数据报的发送与接收（IP地址和端口绑定）。其通信流程如下：</p><ol><li>创建QUdpSocket套接字对象</li><li>如果需要接收数据，必须绑定端口号</li><li>发送数据使用writeDatagram方法，接收数据使用readDatagram</li></ol><h2 id="3-TCP协议的通信流程"><a href="#3-TCP协议的通信流程" class="headerlink" title="3 TCP协议的通信流程"></a>3 TCP协议的通信流程</h2><p>服务器端的通信流程：</p><ol><li>创建QTcpServer对象</li><li>监听list（IP地址和端口号）</li><li>等待客户端连接成功后发送newConnect信号</li><li>直接在newConnection槽函数当中调用nextPendingConnection函数获取新连接的QTcpSocket对象</li><li>连接QTcpSocket对象的readRead信号</li><li>在readRead信号槽中使用read接收数据</li><li>调用write函数来发送数据</li></ol><p>客户端的通信流程：</p><ol><li>创建QTcpSocket对象</li><li>当对象与服务器连接成功时会发送connected信号</li><li>调用connectToHost函数连接服务器（IP地址和端口号）</li><li>connected信号的槽函数开始发送数据</li><li>使用write发送数据，使用read接收数据</li></ol><h2 id="4-信号与槽机制的优缺点"><a href="#4-信号与槽机制的优缺点" class="headerlink" title="4  信号与槽机制的优缺点"></a>4  信号与槽机制的优缺点</h2><ul><li><p>优点：灵活性、松散耦合、类型比较安全</p></li><li><p>缺点：速度比较慢</p></li></ul><h2 id="5-数据流-QDataStream-与文件流-QTextStream-的区别"><a href="#5-数据流-QDataStream-与文件流-QTextStream-的区别" class="headerlink" title="5 数据流(QDataStream)与文件流(QTextStream)的区别"></a>5 数据流(QDataStream)与文件流(QTextStream)的区别</h2><ul><li><p>数据流：通过数据流可以操作各种数据类型（包括对象、存储到文件中的数据为二进制）</p></li><li><p>文件流：操作轻量级数据，数据写入文本后是以文本的方式存储展现的</p></li></ul><h2 id="6-C-当中拥有的三个智能指针分别是什么"><a href="#6-C-当中拥有的三个智能指针分别是什么" class="headerlink" title="6 C++当中拥有的三个智能指针分别是什么"></a>6 C++当中拥有的三个智能指针分别是什么</h2><ul><li>shared_ptr：共享指针，同一块内存存储空间每多一个指针指向就计数加1，如果计数变为0则释放内存空间</li><li>unique_ptr：计数只能为1，没有拷贝构造函数</li><li>weak_ptr：指向内存存储空间而没有所有权。只有读权限而没有写权限</li></ul><h2 id="7-C-协程"><a href="#7-C-协程" class="headerlink" title="7 C++协程"></a>7 C++协程</h2><p>线程分为内核态线程以及用户态线程。</p><p>协程的本质是处理自身挂起和恢复的用户态线程，协程的切换要比线程的切换速度更快，适合IO密集型任务。</p><p>协程分类：有栈协程（改变函数调用栈。有自己的调用栈，类似于线程的操作）、无栈协程（使用状态机或者闭包进行处理，c++20抛弃此类）</p><h2 id="8-互斥锁、读写锁、自旋锁"><a href="#8-互斥锁、读写锁、自旋锁" class="headerlink" title="8 互斥锁、读写锁、自旋锁"></a>8 互斥锁、读写锁、自旋锁</h2><ul><li><p>互斥锁（mute lock）：是睡眠等待类型的锁。当线程抢占互斥锁失败后，线程则会陷入休眠状态。优点是节省CPU资源，缺点是休眠唤醒需要消耗额外的时间</p></li><li><p>读写锁（read-write lock）：又称为共享-独占锁，对于临界区区分读写，读共享、写独占。使用场景：多读少写。</p></li><li><p>自旋锁（spin lock）：忙等待（本质就是死循环）。不会引起线程休眠</p></li></ul><h2 id="9-Qt当中的智能指针"><a href="#9-Qt当中的智能指针" class="headerlink" title="9 Qt当中的智能指针"></a>9 Qt当中的智能指针</h2><ul><li>QSharedPointer：对拥有的内存资源的引用计数，引用计数下降到0时释放内存资源</li><li>QScopedPointer：内存数据只在一个地方被使用</li><li>QPointer：指向QObject以及派生类的对象。超出作用域的时候并不会释放所指向的内存对象</li></ul><h2 id="10-Qt连接MySQL数据库原理机制以及方法"><a href="#10-Qt连接MySQL数据库原理机制以及方法" class="headerlink" title="10 Qt连接MySQL数据库原理机制以及方法"></a>10 Qt连接MySQL数据库原理机制以及方法</h2><ol><li>直接通过MySQL驱动加载数据库技术</li><li>通过ODBC连接MySQL数据库技术</li></ol><h2 id="11-Qt中多线程使用方法"><a href="#11-Qt中多线程使用方法" class="headerlink" title="11 Qt中多线程使用方法"></a>11 Qt中多线程使用方法</h2><ul><li><p><strong>方法一</strong>：①创建一个类从QThread类派生②在子线程类中重写 run 函数, 将处理操作写入该函数中 ③在主线程中创建子线程对象, 启动子线程, 调用start()函数</p></li><li><p><strong>方法二</strong>：①将业务处理抽象成一个业务类, 在该类中创建一个业务处理函数②在主线程中创建一QThread类对象 ③在主线程中创建一个业务类对象 ④将业务类对象移动到子线程中 ⑤在主线程中启动子线程 ⑥通过信号槽的方式, 执行业务类中的业务处理函数</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++</tag>
      
      <tag>Qt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端简介</title>
    <link href="/2021/12/25/%E5%89%8D%E7%AB%AF%E7%AE%80%E4%BB%8B/"/>
    <url>/2021/12/25/%E5%89%8D%E7%AB%AF%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="一-前端简介"><a href="#一-前端简介" class="headerlink" title="一.前端简介"></a>一.前端简介</h1><h2 id="1-1-软件的分类"><a href="#1-1-软件的分类" class="headerlink" title="1.1 软件的分类"></a>1.1 软件的分类</h2><h3 id="1-1-1-系统软件"><a href="#1-1-1-系统软件" class="headerlink" title="1.1.1 系统软件"></a>1.1.1 系统软件</h3><p>如Windows、Linux、MacOs等</p><h3 id="1-1-2-应用软件"><a href="#1-1-2-应用软件" class="headerlink" title="1.1.2 应用软件"></a>1.1.2 应用软件</h3><p>如Office、QQ等</p><h3 id="1-1-3-游戏软件"><a href="#1-1-3-游戏软件" class="headerlink" title="1.1.3 游戏软件"></a>1.1.3 游戏软件</h3><p>绝地求生、CS:GO等</p><h2 id="1-2-客户端与服务器"><a href="#1-2-客户端与服务器" class="headerlink" title="1.2 客户端与服务器"></a>1.2 客户端与服务器</h2><p>通常情况下现在的软件一般由两个部分组成：</p><ul><li>客户端：用户通过客户端来使用软件</li><li>服务器：服务器负责在远程处理业务逻辑</li></ul><div style="text-align: center;">      <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E5%89%8D%E7%AB%AF/CS%E6%9E%B6%E6%9E%84%E5%9B%BE.png"           alt="C/S架构"/></div><h3 id="1-2-1-客户端"><a href="#1-2-1-客户端" class="headerlink" title="1.2.1 客户端"></a>1.2.1 客户端</h3><p>常见客户端的形式：</p><ul><li>文字客户端：通过Shell命令行来使用软件。</li><li>图形客户端：通过点击拖动等操作来使用软件。Windows、macOs等桌面端以及Android、iOS等移动端系统中的大部分应用。</li><li>网页（B&#x2F;S架构）：通过网页访问来使用软件。所有网站都属于这个范畴。</li></ul><h3 id="1-2-2-服务器"><a href="#1-2-2-服务器" class="headerlink" title="1.2.2 服务器"></a>1.2.2 服务器</h3><p>服务器常用的开发语言：</p><ul><li><strong>Java</strong></li><li>PHP</li><li>C#</li><li>Python</li><li><strong>Node.js</strong></li></ul><h2 id="1-3-网页的特点"><a href="#1-3-网页的特点" class="headerlink" title="1.3 网页的特点"></a>1.3 网页的特点</h2><h3 id="1-3-1-网页的优点"><a href="#1-3-1-网页的优点" class="headerlink" title="1.3.1 网页的优点"></a>1.3.1 网页的优点</h3><p>相较于传统的图形化界面，网页有如下优点：</p><ul><li>无需安装</li><li>无需更新</li><li><strong>跨平台能力强</strong></li></ul><h3 id="1-3-2-网页开发的常见语言"><a href="#1-3-2-网页开发的常见语言" class="headerlink" title="1.3.2 网页开发的常见语言"></a>1.3.2 网页开发的常见语言</h3><ul><li>HTML（超文本标记语言）</li><li>CSS（层叠样式表）</li><li>JavaScript（脚本语言）</li></ul><h1 id="二-网页简史"><a href="#二-网页简史" class="headerlink" title="二.网页简史"></a>二.网页简史</h1><h2 id="2-1-历史"><a href="#2-1-历史" class="headerlink" title="2.1 历史"></a>2.1 历史</h2><ul><li>蒂姆.伯纳斯.李 爵士是万维网的发明人</li><li>1991年8月6日，世界上第一个服务器和第一个网站在欧洲核子研究中心上线</li><li>世界上第一个网站：<a href="http://info.cern.ch/hypertext/WWW/TheProject.html">http://info.cern.ch/hypertext/WWW/TheProject.html</a></li></ul><h2 id="2-2-浏览器和网页"><a href="#2-2-浏览器和网页" class="headerlink" title="2.2 浏览器和网页"></a>2.2 浏览器和网页</h2><ul><li>浏览器负责将网页渲染成我们想要的样子</li><li>前端工程师负责编写网页的源代码</li></ul><h2 id="2-3-浏览器的问题"><a href="#2-3-浏览器的问题" class="headerlink" title="2.3 浏览器的问题"></a>2.3 浏览器的问题</h2><ul><li>市面上存在很多不同的浏览器</li><li>在万维网的初期，网页编写并没有标准</li></ul><h2 id="2-4-W3C的建立"><a href="#2-4-W3C的建立" class="headerlink" title="2.4 W3C的建立"></a>2.4 W3C的建立</h2><ul><li>伯纳斯李1994年建立万维网联盟（W3C）</li><li>W3C的出现为了制订网页开发的标准，以使桶一个网页在不同的浏览器中有相同的效果</li><li>因此，我们需要制订我们编写的网页都需要遵循W3C的规范</li></ul><hr><h1 id="三-网页的结构"><a href="#三-网页的结构" class="headerlink" title="三.网页的结构"></a>三.网页的结构</h1><p>根据W3C标准，一个网页主要由三部分组成：结构、表现和行为。</p><ul><li>结构：HTML用于描述页面的结构</li><li>表现：CSS用于控制页面中元素的样式</li><li>行为：JavaScript用于响应用户操作</li></ul><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E5%89%8D%E7%AB%AF/%E7%BD%91%E9%A1%B5%E7%9A%84%E7%BB%93%E6%9E%84.jpg"         alt="在这里插入图片描述" /></div><h2 id="3-1-HTML"><a href="#3-1-HTML" class="headerlink" title="3.1 HTML"></a>3.1 HTML</h2><p>HTML（英文全称：Hypertext Markup Language），全称为超文本标记语言，是一种标记语言。它负责网页的三个元素中的结构部分。HTML使用标签的形式来标识网页中的不同组成部分。所谓超文本指的是超链接，使用超链接可以让我们从一个页面跳转到另一个页面。HTML文本是由HTML命令组成的描述性文本，HTML命令可以说明文字，图形、动画、声音、表格、链接等。[<a href="https://baike.baidu.com/item/HTML/97049?fr=aladdin">HTML超文本标记语言</a>]</p><h2 id="3-2-CSS"><a href="#3-2-CSS" class="headerlink" title="3.2 CSS"></a>3.2 CSS</h2><p>层叠样式表(英文全称：Cascading Style Sheets)，是一种用来表现HTML（标准通用标记语言的一个应用）或XML（标准通用标记语言的一个子集）等文件样式的计算机语言。CSS不仅可以静态地修饰网页，还可以配合各种脚本语言动态地对网页各元素进行格式化。[<a href="https://baike.baidu.com/item/CSS/5457?fr=aladdin">CSS层叠样式表</a>]</p><h2 id="3-3-JavaScript"><a href="#3-3-JavaScript" class="headerlink" title="3.3 JavaScript"></a>3.3 JavaScript</h2><p>JavaScript（简称“JS”） 是一种具有函数优先的轻量级，解释型或即时编译型的编程语言。虽然它是作为开发Web页面的脚本语言而出名，但是它也被用到了很多非浏览器环境中，JavaScript 基于原型编程、多范式的动态脚本语言，并且支持面向对象、命令式、声明式、函数式编程范式。[<a href="https://baike.baidu.com/item/JavaScript">JavaScript脚本语言</a>]</p><hr><h1 id="四-网页基本内容"><a href="#四-网页基本内容" class="headerlink" title="四.网页基本内容"></a>四.网页基本内容</h1><h2 id="4-1-网页规范演进"><a href="#4-1-网页规范演进" class="headerlink" title="4.1 网页规范演进"></a>4.1 网页规范演进</h2><ul><li>HTML4</li><li>XHTML2.0</li><li>HTML5</li></ul><h2 id="4-2-文档声明"><a href="#4-2-文档声明" class="headerlink" title="4.2 文档声明"></a>4.2 文档声明</h2><p>文档声明本身不属于网页，只是用来告诉浏览器当前网页版本（写在html标签之前）</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- html5的文档声明 --&gt;</span><br><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 或者 --&gt;</span><br><span class="hljs-meta">&lt;!Doctype <span class="hljs-keyword">HTML</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4-3-注释"><a href="#4-3-注释" class="headerlink" title="4.3 注释"></a>4.3 注释</h2><p>用于开发过程工作衔接或者自己编码时注释内容使用。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>注释<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--这是一个注释--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4-4-属性"><a href="#4-4-属性" class="headerlink" title="4.4 属性"></a>4.4 属性</h2><p>可以在开始标签或者自结束标签可以设置属性。</p><ul><li>属性是一个键值对结构（key:value）。有些属性有属性值，有些没有（如果有引号应当用引号引起来）</li><li>属性用来设置标签中的内容如何显示</li><li>属性和标签名或者其他属性应该用空格分隔开</li><li>属性不能瞎写，应当根据文档规范来编写</li></ul><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>标签的属性<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>这是<span class="hljs-tag">&lt;<span class="hljs-name">font</span> <span class="hljs-attr">color</span>=<span class="hljs-string">&quot;yellow&quot;</span> <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;3&quot;</span>&gt;</span>一个<span class="hljs-tag">&lt;/<span class="hljs-name">font</span>&gt;</span>网页<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4-5-进制转换"><a href="#4-5-进制转换" class="headerlink" title="4.5 进制转换"></a>4.5 进制转换</h2><ol><li>二进制（计算机底层数据类型）</li></ol><ul><li>特点：逢二进一</li><li>单位数字：0 1</li><li>计数举例：1 10 111</li></ul><ol start="2"><li>十进制（日常使用）</li></ol><ul><li>特点：逢十进一</li><li>单位数字：（10个）0 1 2 3 4 5 6 7 8 9</li><li>计数举例：9 19</li></ul><ol start="3"><li>八进制（不常用）</li></ol><ul><li>特点：逢八进一</li><li>单位数字：（8个）0 1 2 3 4 5 6 7</li><li>计数举例：17 20</li></ul><ol start="4"><li>十六进制（本质是二进制）</li></ol><ul><li>特点：逢十六进一</li><li>单位数字：（16个）0 1 2 3 4 5 6 7 8 9 A B C D E</li><li>计数举例：9  19 A3</li></ul><h2 id="4-6-字符编码"><a href="#4-6-字符编码" class="headerlink" title="4.6 字符编码"></a>4.6 字符编码</h2><p>字符的编码和解码是一个双向映射过程。</p><ul><li>编码（Encoding）：将字符转换成二进制码的过程称为编码</li><li>解码（Decoding）：将二进制码转换成字符的过程称为解码</li></ul><h3 id="字符集（CharSet）"><a href="#字符集（CharSet）" class="headerlink" title="字符集（CharSet）"></a>字符集（CharSet）</h3><p>编码和解码所采用的规则称之为字符集。若编码和解码采用的字符集不匹配，那将出现乱码问题。<br>常见的编码规则：</p><ul><li>ASCII（美国）</li><li>ISO88591（欧洲）</li><li>GB2312（中国国标）</li><li>GBK（中国国标扩展）</li><li>UTF-8（万国码）</li></ul><p>可以通过meta标签设置网页字符集，避免乱码问题</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="4-7-网页的基本结构"><a href="#4-7-网页的基本结构" class="headerlink" title="4.7 网页的基本结构"></a>4.7 网页的基本结构</h2><p>网页的基本结构如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 文档声明，声明当前网页的版本 --&gt;</span><br><span class="hljs-meta">&lt;!doctype <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-comment">&lt;!-- html的根标签(元素)，网页中的所有内容都要写在根元素里面--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-comment">&lt;!-- head是网页的头部，head中的内容不会在网页中直接出现，主要是用来帮助浏览器或者搜索引擎解析网页 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- meta标签用来设置网页的元数据，这里的meta用来设置网页的字符集避免乱码问题 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;utf-8&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- title中的内容会显示在浏览器的标题栏，搜索引擎根据title中的内容来判断网页的主要内容 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>网页的标题<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- body是html的子元素，是网页的主体，网页中所有的可见内容都应该写在body里面 --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- h1是网页的一级标题 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>一级标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>前端</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C/C++学习路线</title>
    <link href="/2021/07/25/C%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/"/>
    <url>/2021/07/25/C%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="1-C-C-学习概述"><a href="#1-C-C-学习概述" class="headerlink" title="1 C&#x2F;C++学习概述"></a>1 C&#x2F;C++学习概述</h1><h2 id="1-1-C语言的基础知识"><a href="#1-1-C语言的基础知识" class="headerlink" title="1.1 C语言的基础知识"></a>1.1 C语言的基础知识</h2><ul><li>关键字</li><li>数据类型</li><li>输入&#x2F;输出&#x2F;格式化</li><li>运算符</li><li>表达式</li><li>语句</li><li>判断</li><li>循环</li><li>数组</li><li>结构体&#x2F;共同体&#x2F;枚举&#x2F;位操作</li><li>指针</li><li>函数</li><li>内存管理</li></ul><h2 id="1-2-C-的基础知识"><a href="#1-2-C-的基础知识" class="headerlink" title="1.2 C++的基础知识"></a>1.2 C++的基础知识</h2><p>除C语言的部分外，C++还有如下知识点：</p><ul><li>面向对象的特性：抽象、类、封装、继承、多态</li><li>容器</li><li>模板</li><li>泛型</li><li>STL</li><li>RTTI</li><li>元编程</li></ul><p>C&#x2F;C++基础学相关书籍：《C Primer Plus》《C和指针》《C专家编程》</p><hr><h1 id="2-C-C-编程学习四大件"><a href="#2-C-C-编程学习四大件" class="headerlink" title="2 C&#x2F;C++编程学习四大件"></a>2 C&#x2F;C++编程学习四大件</h1><h2 id="2-1-数据结构和算法"><a href="#2-1-数据结构和算法" class="headerlink" title="2.1 数据结构和算法"></a>2.1 数据结构和算法</h2><p>常见数据结构：</p><ul><li>字符串</li><li>数组</li><li>链表</li><li>堆</li><li>栈</li><li>队列</li><li>树</li><li>哈希</li><li>图<br>常见算法：</li><li>排序算法</li><li>查找算法<br>相关学习书籍：《大话数据结构》《剑指offer》</li></ul><h2 id="2-2-操作系统"><a href="#2-2-操作系统" class="headerlink" title="2.2 操作系统"></a>2.2 操作系统</h2><ul><li>内存管理和调度</li><li>多任务：多线程&#x2F;并发&#x2F;锁</li><li>I&#x2F;O管理</li><li>文件管理<br>相关学习书籍：《深入理解操作系统》</li></ul><h2 id="2-3-计算机网络"><a href="#2-3-计算机网络" class="headerlink" title="2.3 计算机网络"></a>2.3 计算机网络</h2><h3 id="2-3-1-计算机网络分层"><a href="#2-3-1-计算机网络分层" class="headerlink" title="2.3.1 计算机网络分层"></a>2.3.1 计算机网络分层</h3><p>ISO七层模型：将计算机网络从上至下划分为应用层（Application Layer）、表示层（Presentation Layer）、会话层（Session Layer）、运输层（Transport Layer）、网络层（Network Layer）、数据链路层（Data Link Layer）、物理层（Physical Layer）。</p><p>TCP&#x2F;IP四层模型：将计算机网络从上至下划分为应用层、运输层、网际层、网络接口层。</p><p>五层模型：将计算机网络从上至下划分为应用层、运输层、网际层、数据链路层、物理层。</p><div style="text-align: center;">      <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E5%89%8D%E7%AB%AF/%E5%88%86%E5%B1%82%E6%A8%A1%E5%9E%8B%E5%AF%B9%E6%AF%94.png" alt="C/S架构"/></div><h3 id="2-3-2-典型协议（以TCP-IP四层模型举例）"><a href="#2-3-2-典型协议（以TCP-IP四层模型举例）" class="headerlink" title="2.3.2 典型协议（以TCP&#x2F;IP四层模型举例）"></a>2.3.2 典型协议（以TCP&#x2F;IP四层模型举例）</h3><ul><li>应用层：DNS协议、HTTP&#x2F;HTTPS协议</li><li>传输层：TCP协议、UDP协议</li><li>网络层：IP协议、ICMP协议</li><li>网络接口层：ARP协议<br>相关学习书籍：《TCP&#x2F;IP详解》</li></ul><h2 id="2-4-设计模式"><a href="#2-4-设计模式" class="headerlink" title="2.4 设计模式"></a>2.4 设计模式</h2><p>相关学习书籍：《大话设计模式》</p><hr><h1 id="3-应用与编程实践"><a href="#3-应用与编程实践" class="headerlink" title="3 应用与编程实践"></a>3 应用与编程实践</h1><h2 id="3-1-Linux操作系统学习"><a href="#3-1-Linux操作系统学习" class="headerlink" title="3.1 Linux操作系统学习"></a>3.1 Linux操作系统学习</h2><p>推荐学习书籍：《Linux就该这么学》</p><h2 id="3-2-Linux平台的编译和调试"><a href="#3-2-Linux平台的编译和调试" class="headerlink" title="3.2 Linux平台的编译和调试"></a>3.2 Linux平台的编译和调试</h2><p>编译：GCC编译<br>调试：GDB调试<br>推荐学习书籍：GNU官网英文文档、《Debugging with gdb 》中文版、《跟我一起写makefile》（陈皓著)</p><h2 id="3-3-Linux环境编程"><a href="#3-3-Linux环境编程" class="headerlink" title="3.3 Linux环境编程"></a>3.3 Linux环境编程</h2><p>推荐学习书籍：《Unix环境高级编程》、《Linux高性能服务器编程》、《Posix多线程程序设计》</p>]]></content>
    
    
    
    <tags>
      
      <tag>C/C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora使用语法格式</title>
    <link href="/2020/07/13/Typora%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/"/>
    <url>/2020/07/13/Typora%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="Typora使用语法格式"><a href="#Typora使用语法格式" class="headerlink" title="Typora使用语法格式"></a>Typora使用语法格式</h1><h2 id="一-标题"><a href="#一-标题" class="headerlink" title="一.标题"></a>一.标题</h2><ul><li>一级标题<strong>格式</strong>：# + 空格 + 一级标题</li><li>二级标题<strong>格式</strong>：## + 空格 + 二级标题</li><li>三级标题<strong>格式</strong>：### + 空格 + 三级标题</li><li>四级标题<strong>格式</strong>：#### + 空格 + 四级标题</li><li>以此类推……</li></ul><h2 id="二-字体"><a href="#二-字体" class="headerlink" title="二.字体"></a>二.字体</h2><ol><li>加粗<strong>格式</strong>：* * + 内容 + * *          <strong>举例</strong>：<strong>加粗</strong></li><li>斜体<strong>格式</strong>：* + 内容 + *               <strong>举例</strong>：<em>斜体</em></li><li>斜体加粗<strong>格式</strong>：* * * + 内容 + * * *     <strong>举例</strong>：<em><strong>斜体加粗</strong></em></li><li>删除线<strong>格式</strong>：~~ 内容 ~~              <strong>举例</strong>：<del>删除线</del></li><li>高亮<strong>格式</strong>：&#x3D;&#x3D; 内容 &#x3D;&#x3D;                 <strong>举例</strong>：&#x3D;&#x3D;高亮&#x3D;&#x3D;</li></ol><h2 id="三-引用"><a href="#三-引用" class="headerlink" title="三.引用"></a>三.引用</h2><p><strong>格式</strong>：&gt; + 引用文字</p><p><strong>举例</strong>：</p><blockquote><p>一级引用</p><blockquote><p>二级引用</p><blockquote><p>三级引用</p></blockquote></blockquote></blockquote><h2 id="四-分割线"><a href="#四-分割线" class="headerlink" title="四.分割线"></a>四.分割线</h2><p><strong>格式</strong>：相连的三个—</p><p><strong>举例</strong>：</p><hr><h2 id="五-图片"><a href="#五-图片" class="headerlink" title="五.图片"></a>五.图片</h2><p><strong>格式</strong>： ![Alt] (Address “Title”)</p><ul><li>Alt：指定图片链接失效时显示的提示文字</li><li>Address：指图片的本地地址或者网络地址</li><li>Title：指图片的标题，当鼠标移到图片上时显示的内容</li></ul><p><strong>举例</strong>：</p><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Typora%E6%8F%92%E5%9B%BE%E4%B8%BE%E4%BE%8B.png" alt="图片已经失效" title="这是Typora插图举例"></p><p><strong>注意</strong>：如果需要更改图片的大小、宽度等属性，可以鼠标右击图片以后然后更改HTML代码以获得更好的体验</p><p><strong>举例</strong>：</p><div style="text-align: center;"><img style="border-radius: 20px;" src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Typora%E6%8F%92%E5%9B%BE%E4%B8%BE%E4%BE%8B.png" alt="图片已经失效" title="这是Typora插图举例" style="zoom: 50%;" width="720" /></div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;text-align: center;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> //<span class="hljs-attr">设置圆角属性</span></span><br><span class="hljs-tag">         <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border-radius: 20px;&quot;</span></span><br><span class="hljs-tag">         //<span class="hljs-attr">指定地址源--可本地</span>，<span class="hljs-attr">也可网络</span></span><br><span class="hljs-tag">         <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Typora%E6%8F%92%E5%9B%BE%E4%B8%BE%E4%BE%8B.png&quot;</span> </span><br><span class="hljs-tag">         //<span class="hljs-attr">指定图片链接失效时显示的提示文字</span></span><br><span class="hljs-tag">         <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;图片已经失效&quot;</span> </span><br><span class="hljs-tag">         //<span class="hljs-attr">图片的标题</span>，<span class="hljs-attr">鼠标置有于上方后呈现</span></span><br><span class="hljs-tag">         <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;这是Typora插图举例&quot;</span> </span><br><span class="hljs-tag">         //<span class="hljs-attr">样式</span></span><br><span class="hljs-tag">         <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;zoom: 50%;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="六-超链接"><a href="#六-超链接" class="headerlink" title="六.超链接"></a>六.超链接</h2><p><strong>格式</strong>：[超链接名字] (超链接地址)</p><p><strong>举例</strong>：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">网络地址：<span class="hljs-selector-attr">[百度]</span>(http://www.baidu.com)<br>本地地址：<span class="hljs-selector-attr">[Typora插图举例]</span>(./Typora插图举例.png)<br></code></pre></td></tr></table></figure><ul><li>网络地址：<a href="http://www.baidu.com/">百度</a></li><li>本地地址：<a href="./Typora%E6%8F%92%E5%9B%BE%E4%B8%BE%E4%BE%8B.png">Typora插图举例</a></li></ul><h2 id="七-列表"><a href="#七-列表" class="headerlink" title="七.列表"></a>七.列表</h2><h3 id="1-无序列表"><a href="#1-无序列表" class="headerlink" title="1.无序列表"></a>1.无序列表</h3><p><strong>格式</strong>：- + 空格 + 内容</p><p><strong>举例</strong>：</p><ul><li>无序列表</li></ul><h3 id="2-有序列表"><a href="#2-有序列表" class="headerlink" title="2.有序列表"></a>2.有序列表</h3><p><strong>格式</strong>：数字序号 + . + 空格 + 内容</p><p><strong>举例</strong>：</p><ol><li>有序列表</li></ol><h3 id="3-子列表"><a href="#3-子列表" class="headerlink" title="3.子列表"></a>3.子列表</h3><p><strong>格式</strong>：在子列表前按下tab键即可构成子列表</p><p><strong>举例</strong>：</p><ul><li>根列表<ul><li>子列表1<ul><li>子列表2</li></ul></li></ul></li></ul><ol><li>根列表<ol><li>字列表1<ol><li>子列表2</li></ol></li></ol></li></ol><h2 id="八-表格"><a href="#八-表格" class="headerlink" title="八.表格"></a>八.表格</h2><p><strong>格式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 格式">|左对齐|居中对齐|右对齐|<br>|:----|:----:|---:|<br>|左|中|右|<br><br>注意：第二行分割表头和内容，并声明内容的对齐格式<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">左对齐</th><th align="center">居中对齐</th><th align="right">右对齐</th></tr></thead><tbody><tr><td align="left">左</td><td align="center">中</td><td align="right">右</td></tr></tbody></table><h2 id="九-代码"><a href="#九-代码" class="headerlink" title="九.代码"></a>九.代码</h2><h3 id="1-行内代码"><a href="#1-行内代码" class="headerlink" title="1.行内代码"></a>1.行内代码</h3><p><strong>格式</strong>： </p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-string">`代码内容`</span><br></code></pre></td></tr></table></figure><p>举例：</p><p><code>行内代码</code></p><h3 id="2-多行代码"><a href="#2-多行代码" class="headerlink" title="2.多行代码"></a>2.多行代码</h3><p><strong>格式</strong>： </p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-string">``</span><span class="hljs-string">`编程语言</span><br><span class="hljs-string">代码内容</span><br><span class="hljs-string">`</span><span class="hljs-string">``</span><br></code></pre></td></tr></table></figure><p>举例：</p><p><code>cpp 多行代码1 多行代码2 </code></p><h2 id="十-高级技巧"><a href="#十-高级技巧" class="headerlink" title="十.高级技巧"></a>十.高级技巧</h2><h3 id="1-转义"><a href="#1-转义" class="headerlink" title="1.转义"></a>1.转义</h3><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">\   反斜线<br>`   反引号<br><span class="hljs-bullet">*</span>   星号<br>_   下划线<br>&#123;&#125;  花括号<br>[]  方括号<br>()  小括号<br><span class="hljs-section">#   井字号</span><br><span class="hljs-bullet">+</span>   加号<br><span class="hljs-bullet">-</span>   减号<br>.   英文句点<br>!   感叹号<br></code></pre></td></tr></table></figure><h3 id="2-公式"><a href="#2-公式" class="headerlink" title="2.公式"></a>2.公式</h3><ol><li>行内</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>f(x)=x<br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>$$<br>f(x)&#x3D;x<br>$$</p><ol start="2"><li>段落</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>s=\sum_1^n&#123;n_i&#125;<br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>$$<br>s&#x3D;\sum_1^n{n_i}<br>$$</p><ol start="3"><li>上标</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>x^<span class="hljs-number">2</span><br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>$$<br>x^2<br>$$</p><ol start="4"><li>下标</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>x_2<br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>$$<br>x_2<br>$$</p><ol start="5"><li>括号</li></ol><p>大括号：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span> <br>\lbrace a+x \rbrace<br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>$$<br>\lbrace a+x \rbrace<br>$$</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs llvm">$$<br>f(<span class="hljs-keyword">x</span>)<span class="hljs-operator">=</span>\<span class="hljs-keyword">begin</span>&#123;cases&#125; <br><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> &amp; <span class="hljs-keyword">x</span>&gt;<span class="hljs-number">0</span>\\ <br><span class="hljs-number">0</span><span class="hljs-punctuation">,</span> &amp; <span class="hljs-keyword">x</span><span class="hljs-operator">=</span><span class="hljs-number">0</span>\\<br><span class="hljs-number">-1</span><span class="hljs-punctuation">,</span> &amp; <span class="hljs-keyword">x</span>&lt;<span class="hljs-number">0</span><br>\<span class="hljs-keyword">end</span>&#123;cases&#125;<br>$$<br></code></pre></td></tr></table></figure><p>$$<br>f(x)&#x3D;\begin{cases}<br>        1, &amp; x&gt;0\<br>        0, &amp; x&#x3D;0\<br>        -1, &amp; x&lt;0<br>\end{cases}<br>$$</p><p>尖括号：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>\langle x \rangle<br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>$$<br>\langle x \rangle<br>$$</p><ol start="6"><li>上取整</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>\lceil \<span class="hljs-built_in">frac</span>&#123;x&#125;&#123;<span class="hljs-number">2</span>&#125; \rceil<br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>$$<br>\lceil \frac{x}{2} \rceil<br>$$</p><ol start="7"><li>下取整</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>\lfloor x \rfloor<br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>$$<br>\lfloor x \rfloor<br>$$</p><ol start="8"><li>求和</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>\sum_i^n<br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>$$<br>\sum_i^n<br>$$</p><ol start="9"><li>积分</li></ol><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">$$</span><br><span class="language-xml">\int_</span><span class="hljs-template-variable">&#123;1&#125;</span><span class="language-xml">^</span><span class="hljs-template-variable">&#123;\infty&#125;</span><span class="language-xml">\\</span><br><span class="language-xml">\prod_</span><span class="hljs-template-variable">&#123;1&#125;</span><span class="language-xml">^</span><span class="hljs-template-variable">&#123;n&#125;</span><span class="language-xml"> \\</span><br><span class="language-xml">\bigcup_</span><span class="hljs-template-variable">&#123;1&#125;</span><span class="language-xml">^</span><span class="hljs-template-variable">&#123;n&#125;</span><span class="language-xml"> \\</span><br><span class="language-xml">\iint_</span><span class="hljs-template-variable">&#123;1&#125;</span><span class="language-xml">^</span><span class="hljs-template-variable">&#123;n&#125;</span><span class="language-xml"></span><br><span class="language-xml">$$</span><br></code></pre></td></tr></table></figure><p>$$<br>\int_{1}^{\infty}\<br>\prod_{1}^{n} \<br>\bigcup_{1}^{n} \<br>\iint_{1}^{n}<br>$$</p><ol start="10"><li>分式</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>\<span class="hljs-built_in">frac</span> ab \\<br>\<span class="hljs-built_in">frac</span>&#123;<span class="hljs-number">1</span>&#125;&#123;<span class="hljs-number">2</span>&#125;\\<br>&#123;a+<span class="hljs-number">1</span> \over b+<span class="hljs-number">1</span>&#125;<br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>$$<br>\frac ab \<br>\frac{1}{2}\<br>{a+1 \over b+1}<br>$$</p><ol start="11"><li>根式</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>\<span class="hljs-built_in">sqrt</span>[x+<span class="hljs-number">1</span>]&#123;x^<span class="hljs-number">2</span>&#125;<br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>$$<br>\sqrt[x+1]{x^2}<br>$$</p><ol start="12"><li>字体&#x2F;编号</li></ol><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\mathbb</span><br><span class="hljs-string">\tag&#123;3&#125;</span><br></code></pre></td></tr></table></figure><ol start="13"><li>特殊函数与符号</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span><span class="hljs-variable">$</span>\sum_&#123;i=<span class="hljs-number">0</span>&#125;^&#123;n&#125;<span class="hljs-variable">$</span><span class="hljs-variable">$</span><br><span class="hljs-variable">$</span><span class="hljs-variable">$</span>\prod<span class="hljs-variable">$</span><span class="hljs-variable">$</span><br><span class="hljs-variable">$</span><span class="hljs-variable">$</span>\lim_&#123;x\to +\infty&#125;<span class="hljs-variable">$</span><span class="hljs-variable">$</span><br><span class="hljs-variable">$</span><span class="hljs-variable">$x_n</span>\stackrel&#123;p&#125;\longrightarrow0<span class="hljs-variable">$</span><span class="hljs-variable">$</span><br><span class="hljs-variable">$</span><span class="hljs-variable">$</span>\vec&#123;a&#125;<span class="hljs-variable">$</span><span class="hljs-variable">$</span><br><span class="hljs-variable">$</span><span class="hljs-variable">$</span>\overrightarrow&#123;a&#125; <span class="hljs-variable">$</span><span class="hljs-variable">$</span><br><span class="hljs-variable">$</span><span class="hljs-variable">$</span>\hat y=a\hat x+b<span class="hljs-variable">$</span><span class="hljs-variable">$</span><br><span class="hljs-variable">$</span><span class="hljs-variable">$</span>\mathtt&#123;X&#125;<span class="hljs-string">&#x27;$$</span><br><span class="hljs-string">⨁ $\bigoplus$</span><br></code></pre></td></tr></table></figure><ol start="14"><li>矩阵</li></ol><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">$$<br> \left[<br> \begin&#123;matrix&#125;<br>  <span class="hljs-number"> 1 </span>&amp;<span class="hljs-number"> 2 </span>&amp;<span class="hljs-number"> 3 </span>\\<br>  <span class="hljs-number"> 4 </span>&amp;<span class="hljs-number"> 5 </span>&amp;<span class="hljs-number"> 6 </span>\\<br>  <span class="hljs-number"> 7 </span>&amp;<span class="hljs-number"> 8 </span>&amp; 9<br>  \end&#123;matrix&#125;<br>  \right]<br>$$<br></code></pre></td></tr></table></figure><p>$$<br>\left[<br> \begin{matrix}<br>   1 &amp; 2 &amp; 3 \<br>   4 &amp; 5 &amp; 6 \<br>   7 &amp; 8 &amp; 9<br>  \end{matrix}<br>  \right]<br>$$</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livescript">$$<br><span class="hljs-string">\left[</span><br><span class="hljs-string">\begin&#123;matrix&#125;</span><br> <span class="hljs-number">1</span>      &amp; <span class="hljs-number">2</span>      &amp; <span class="hljs-string">\cdots</span> &amp; <span class="hljs-number">4</span>      <span class="hljs-string">\\</span><br> <span class="hljs-number">7</span>      &amp; <span class="hljs-number">6</span>      &amp; <span class="hljs-string">\cdots</span> &amp; <span class="hljs-number">5</span>      <span class="hljs-string">\\</span><br> <span class="hljs-string">\vdots</span> &amp; <span class="hljs-string">\vdots</span> &amp; <span class="hljs-string">\ddots</span> &amp; <span class="hljs-string">\vdots</span> <span class="hljs-string">\\</span><br> <span class="hljs-number">8</span>      &amp; <span class="hljs-number">9</span>      &amp; <span class="hljs-string">\cdots</span> &amp; <span class="hljs-number">0</span>      <span class="hljs-string">\\</span><br><span class="hljs-string">\end&#123;matrix&#125;</span><br><span class="hljs-string">\right]</span><br>$$<br></code></pre></td></tr></table></figure><p>$$<br>\left[<br>\begin{matrix}<br> 1      &amp; 2      &amp; \cdots &amp; 4      \<br> 7      &amp; 6      &amp; \cdots &amp; 5      \<br> \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br> 8      &amp; 9      &amp; \cdots &amp; 0      \<br>\end{matrix}<br>\right]<br>$$</p><ol start="15"><li>公式对齐</li></ol><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$$</span><br>\<span class="hljs-keyword">begin</span>&#123;aligned&#125;<br>a &amp;= b + c\\<br>  &amp;= d + e + f<br>\<span class="hljs-keyword">end</span>&#123;aligned&#125; \tag&#123;<span class="hljs-number">3</span>&#125;<br><span class="hljs-variable">$$</span><br></code></pre></td></tr></table></figure><p>$$<br>\begin{aligned}<br>a &amp;&#x3D; b + c\<br>  &amp;&#x3D; d + e + f<br>\end{aligned}<br>$$</p>]]></content>
    
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建自己的Hexo博客</title>
    <link href="/2020/04/10/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/04/10/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84Hexo%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="1-Hexo简介"><a href="#1-Hexo简介" class="headerlink" title="1 Hexo简介"></a>1 Hexo简介</h1><p>Hexo基于Node.js的博客部署框架，Hexo能使用Markdown或者其他渲染格式解析文章，安装Hexo只需几分钟时间。<br>Hexo博客部署框架有如下特点：</p><ul><li>快速性</li><li>简洁性</li><li>高效性</li></ul><hr><h1 id="2-环境准备"><a href="#2-环境准备" class="headerlink" title="2 环境准备"></a>2 环境准备</h1><h2 id="2-1-安装Node-js"><a href="#2-1-安装Node-js" class="headerlink" title="2.1 安装Node.js"></a>2.1 安装Node.js</h2><p>首先访问Node.js的官网获取最新LTS安装包：<a href="https://nodejs.org/en/">Node.js官网</a></p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/1.%E8%AE%BF%E9%97%AENode.js%E5%AE%98%E7%BD%91.jpg" alt="下载Node.js"  /></div><p>然后打开下载的Node.js安装包点击安装（安装时全程Default即可）</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/2.%E5%AE%89%E8%A3%85Node.js.jpg"  /></div><p>Win+R打开“运行”并输入cmd打开命令窗口，输入如下代码验证安装完整性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">node -v<br>npm -v<br></code></pre></td></tr></table></figure><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/3.%E9%AA%8C%E8%AF%81Node.js%E5%AE%8C%E6%95%B4%E6%80%A7.jpg" alt="Node.js版本"  /></div><h2 id="2-2-安装Git"><a href="#2-2-安装Git" class="headerlink" title="2.2 安装Git"></a>2.2 安装Git</h2><p>首先访问Git的官网获取最新的Git安装包：<a href="https://git-scm.com/">Git官网</a></p><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/4.%E4%BB%8EGit%E5%AE%98%E7%BD%91%E8%8E%B7%E5%8F%96Git%E5%AE%89%E8%A3%85%E5%8C%85.jpg" alt="获取Git安装包"  /></div><p>然后打开下载的Git安装包点击安装（安装时全程Default即可）</p><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/5.%E5%AE%89%E8%A3%85Git.jpg" alt="安装Git"  /></div><p>Win+R打开“运行”并输入cmd打开命令窗口，输入如下代码验证安装完整性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git --version<br></code></pre></td></tr></table></figure><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/6.%E9%AA%8C%E8%AF%81Git%E5%AE%8C%E6%95%B4%E6%80%A7.jpg" alt="Git版本"  /></div><hr><h1 id="3-Hexo部署"><a href="#3-Hexo部署" class="headerlink" title="3 Hexo部署"></a>3 Hexo部署</h1><h2 id="3-1-安装Hexo框架"><a href="#3-1-安装Hexo框架" class="headerlink" title="3.1 安装Hexo框架"></a>3.1 安装Hexo框架</h2><p>通过npm install -g hexo-cli命令部署hexo框架</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/7.Hexo%E6%A1%86%E6%9E%B6%E5%AE%89%E8%A3%85.jpg" alt="安装Hexo框架"  /></div><h2 id="3-2-Hexo初始化"><a href="#3-2-Hexo初始化" class="headerlink" title="3.2 Hexo初始化"></a>3.2 Hexo初始化</h2><p>通过hexo init命令初始化博客</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init<br></code></pre></td></tr></table></figure><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/hexo%20init.jpg" alt="Init"  /></div><h2 id="3-3-Hexo生成"><a href="#3-3-Hexo生成" class="headerlink" title="3.3 Hexo生成"></a>3.3 Hexo生成</h2><p>通过hexo generate命令生成博客</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate<br></code></pre></td></tr></table></figure><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/hexo%20generate.jpg" alt="Generate"  /></div><h2 id="3-4-Hexo启动"><a href="#3-4-Hexo启动" class="headerlink" title="3.4 Hexo启动"></a>3.4 Hexo启动</h2><p>通过hexo server命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo server<br></code></pre></td></tr></table></figure><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/hexo%20server.jpg" alt="Server"  /></div><p>再通过 <a href="http://localhost:4000/">http://localhost:4000/</a> 即可本地访问博客主页</p><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E8%AE%BF%E9%97%AE.jpg" alt="本地访问"  /></div><h2 id="3-5-Hexo部署"><a href="#3-5-Hexo部署" class="headerlink" title="3.5 Hexo部署"></a>3.5 Hexo部署</h2><p>通过hexo deploy命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo deploy<br></code></pre></td></tr></table></figure><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/hexo%20deploy.jpg" alt="Deploy"  /></div><h2 id="3-6-Hexo清除"><a href="#3-6-Hexo清除" class="headerlink" title="3.6 Hexo清除"></a>3.6 Hexo清除</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br></code></pre></td></tr></table></figure><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/hexo%20clean.jpg" alt="Clean"  /></div><h2 id="3-7-添加文章"><a href="#3-7-添加文章" class="headerlink" title="3.7 添加文章"></a>3.7 添加文章</h2><p>在博客文件夹下的 &#x2F;source&#x2F;_post 文件夹下面创建需更新的博客，完成后便可将其部署到GitHub服务器上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new post &lt;新建的Markdown文件名&gt;<br></code></pre></td></tr></table></figure><hr><h1 id="4-将Hexo博客部署到GitHub上托管"><a href="#4-将Hexo博客部署到GitHub上托管" class="headerlink" title="4 将Hexo博客部署到GitHub上托管"></a>4 将Hexo博客部署到GitHub上托管</h1><h2 id="4-1-新建GitHub仓库"><a href="#4-1-新建GitHub仓库" class="headerlink" title="4.1 新建GitHub仓库"></a>4.1 新建GitHub仓库</h2><p><strong>第一步</strong>：在GitHub本人主页上点击加号（+）选择new repository创建新仓库</p><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/%E6%96%B0%E5%BB%BA%E4%BB%93%E5%BA%931.jpg" alt="新建仓库"  /></div><p><strong>第二步</strong>：在新建仓库的页面键入本人的Repository name（注意一定要以.github.io结尾）</p><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/%E6%96%B0%E5%BB%BA%E4%BB%93%E5%BA%932.jpg" alt="输入仓库名称"  /></div><p><strong>第三步</strong>：生成以后的仓库中红框部分是后面将Hexo博客部署到GitHub上所需的链接</p><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/%E6%96%B0%E5%BB%BA%E4%BB%93%E5%BA%933.jpg" alt="仓库链接"  /></div><h2 id="4-2-将Hexo博客部署到GitHub服务器上"><a href="#4-2-将Hexo博客部署到GitHub服务器上" class="headerlink" title="4.2 将Hexo博客部署到GitHub服务器上"></a>4.2 将Hexo博客部署到GitHub服务器上</h2><p>将博客根目录下的_config.yml配置文件进行如下更改：</p><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/config%E7%9A%84%E9%83%A8%E7%BD%B2%E6%A0%8F%E6%9B%B4%E6%94%B9.jpg" alt="部署博客到Git上"  /></div><p>完成操作之后重新部署生效到GitHub上</p><hr><h1 id="5-更改Hexo博客主题"><a href="#5-更改Hexo博客主题" class="headerlink" title="5 更改Hexo博客主题"></a>5 更改Hexo博客主题</h1><h2 id="5-1-获取主题"><a href="#5-1-获取主题" class="headerlink" title="5.1 获取主题"></a>5.1 获取主题</h2><p>使用如下命令克隆GitHub仓库中的主题到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia<br></code></pre></td></tr></table></figure><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/%E8%8E%B7%E5%8F%96%E4%B8%BB%E9%A2%98%E5%88%B0%E6%9C%AC%E5%9C%B0.jpg" alt="获取主题"  /></div><h2 id="5-2-更改配置文件"><a href="#5-2-更改配置文件" class="headerlink" title="5.2 更改配置文件"></a>5.2 更改配置文件</h2><p>将本地博客所下载的主题根目录的_config.yml文件进行如下更改：</p><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/%E6%9B%B4%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84theme%E9%A1%B9.jpg" alt="修改主题的Config配置文件"  /></div><h2 id="5-3-重新部署到服务器"><a href="#5-3-重新部署到服务器" class="headerlink" title="5.3 重新部署到服务器"></a>5.3 重新部署到服务器</h2><p>后续执行以下操作部署到GitHub上即可完成主题更换操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo generate<br>hexo deploy<br></code></pre></td></tr></table></figure><h2 id="5-4-绑定个人域名"><a href="#5-4-绑定个人域名" class="headerlink" title="5.4 绑定个人域名"></a>5.4 绑定个人域名</h2><p>绑定个人域名参照: <a href="https://blog.csdn.net/heimu24/article/details/81159099?spm=1001.2014.3001.5506">Github个人博客：绑定域名</a></p><hr><h1 id="6-Hexo博客搭建常见问题"><a href="#6-Hexo博客搭建常见问题" class="headerlink" title="6 Hexo博客搭建常见问题"></a>6 Hexo博客搭建常见问题</h1><h2 id="6-1-无法远程访问GitHub仓库"><a href="#6-1-无法远程访问GitHub仓库" class="headerlink" title="6.1 无法远程访问GitHub仓库"></a>6.1 无法远程访问GitHub仓库</h2><p>第一次部署时候可能出现无法无法访问GitHub仓库的情况，考虑可能是SSH配置错误，只需正确配置SSH key即可，详细可参见如下链接的解决方法：<a href="https://blog.csdn.net/weixin_30940783/article/details/99581061">正确配置SSH key并远程访问GitHub</a></p><h2 id="6-2-DNS域名解析异常"><a href="#6-2-DNS域名解析异常" class="headerlink" title="6.2 DNS域名解析异常"></a>6.2 DNS域名解析异常</h2><p>在部署过程中可能遇到无法将博客部署到GitHub上的情况，通过Windows控制的ping命令无法ping通GitHub官网网址，则是出现了DNS域名解析异常。<br><strong>解决方法一</strong>：</p><ol><li>在Windows系统中，访问 C:\Windows\System32\drivers\etc\hosts 文件并在末尾添加如下命令</li><li>在Linux系统中，访问 &#x2F;etc&#x2F;hosts 文件并在末尾添加如下命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#前者为GitHub的网址IP，后者为GitHub网址的域名</span><br>140.82.112.4        github.com<br></code></pre></td></tr></table></figure><p><strong>解决方法二</strong>：更改为国内的Gitee码云，部署方法与GitHub类似</p><h2 id="6-3-部署失败"><a href="#6-3-部署失败" class="headerlink" title="6.3 部署失败"></a>6.3 部署失败</h2><ol><li>在执行hexo deploy命令时出现 ERROR Deployer not found: git 的错误<br>解决方法是执行如下代码然后再重新部署</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-deployer-git<br></code></pre></td></tr></table></figure><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/hexo%E5%AE%89%E8%A3%85git%E7%BB%84%E4%BB%B6.jpg" alt="Hexo安装git组件"  /></div><ol start="2"><li>出现403错误可以将 _config.yml 配置文件中 repo 字段的 https 地址更改为 SSH 地址。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/03/11/hello-world/"/>
    <url>/2019/03/11/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hello World</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>

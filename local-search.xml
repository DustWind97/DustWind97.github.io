<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/11/06/Docker%20%E9%85%8D%E7%BD%AE%20Redis%20%E5%92%8C%20MySQL/"/>
    <url>/2025/11/06/Docker%20%E9%85%8D%E7%BD%AE%20Redis%20%E5%92%8C%20MySQL/</url>
    
    <content type="html"><![CDATA[<h1 id="一-配置-Docker"><a href="#一-配置-Docker" class="headerlink" title="一.配置 Docker"></a>一.配置 Docker</h1><h2 id="1-1-安装-Docker"><a href="#1-1-安装-Docker" class="headerlink" title="1.1 安装 Docker"></a>1.1 安装 Docker</h2><p>在 ArchLinux 系统中，直接使用 <code>yay</code> 命令从 AUR 中安装 Docker</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">安装 docker</span><br>yay -S docker<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询 docker 版本得到回复即为成功</span><br>docker --version<br></code></pre></td></tr></table></figure><h2 id="1-2-配置国内镜像源以及代理"><a href="#1-2-配置国内镜像源以及代理" class="headerlink" title="1.2 配置国内镜像源以及代理"></a>1.2 配置国内镜像源以及代理</h2><ol><li><p>配置国内镜像源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">换国内镜像源（此处为中科大的 docker 源），位置在 /etc/docker/daemon.json, 没有则创建</span><br>&#123;<br>  &quot;registry-mirrors&quot;: [<br>    &quot;https://docker.mirrors.ustc.edu.cn&quot;,<br>    &quot;https://hub-mirror.c.163.com&quot;,<br>    &quot;https://registry.docker-cn.com&quot;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>配置代理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">代理设置, 位置在 /etc/systemd/system/docker.service.d/http-proxy.conf, 没有则创建</span><br>[Service]<br>Environment=&quot;HTTP_PROXY=http://proxy_ip:port&quot;<br>Environment=&quot;HTTPS_PROXY=http://proxy_ip:port&quot;<br>Environment=&quot;NO_PROXY=localhost,127.0.0.1,.example.com&quot; # 此行可以不用<br></code></pre></td></tr></table></figure></li></ol><h1 id="二-配置-Redis"><a href="#二-配置-Redis" class="headerlink" title="二.配置 Redis"></a>二.配置 Redis</h1><p>从 docker 中拉取国内 Redis 镜像源，同时指定特定版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo docker pull redis:5.0.14<br></code></pre></td></tr></table></figure><p>在指定位置创建几个目录用来将容器数据映射到 Linux 本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /home/dustwind/redis/conf<br>mkdir -p /home/dustwind/redis/data<br>mkdir -p /home/dustwind/redis/log<br></code></pre></td></tr></table></figure><p>然后运行 Redis 的 Docker 镜像源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo docker run --name dustwind-redis \<br>--restart always \<br>-p 6380:6379  \<br>-v /home/dustwind/redis/data:/data \<br>-v /home/dustwind/redis/conf/redis.conf:/etc/redis/redis.conf \<br>-d redis:5.0.14 redis-server /etc/redis/redis.conf<br></code></pre></td></tr></table></figure><blockquote><p>[!提示]</p><ol><li>由于本机系统代理问题，可能存在 redis-cli 命令行中能连接 Redis 服务器，而 Redis Desktop Manager 客户端中却无法连接 Redis 服务器的情况。</li><li>如果开放了 Redis 远程访问权限仍然无法通过远程工具连接 Redis，则考虑是云服务器防火墙和阿里云安全策略导致访问被拦截。</li></ol></blockquote><h1 id="三-配置-MySQL"><a href="#三-配置-MySQL" class="headerlink" title="三.配置 MySQL"></a>三.配置 MySQL</h1><p>从 docker 中拉取国内 MySQL 镜像源，同时指定特定版本：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo docker pull mysql:8.0.41<br></code></pre></td></tr></table></figure><p>在指定位置创建几个目录用来将容器数据映射到 Linux 本地</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir -p /home/dustwind/mysql/config<br>mkdir -p /home/dustwind/mysql/data<br>mkdir -p /home/dustwind/mysql/logs<br></code></pre></td></tr></table></figure><p>然后运行 MySQL 的 Docker 镜像源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo docker run --name dustwind-mysql \<br>--restart=on-failure:3 \<br>-p 3308:3306  \<br>-v /home/dustwind/mysql/config/my.cnf:/etc/mysql/my.cnf \<br>-v /home/dustwind/mysql/data:/var/lib/mysql \<br>-v /home/dustwind/mysql/logs:/logs \<br>-e MYSQL_ROOT_PASSWORD=123456 \<br>-d mysql:8.0.41<br></code></pre></td></tr></table></figure><p>穿透 docker 中，对 MySQL 进行更多配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">先进入 bash 环境，然后运行 MySQL</span><br>docker exec -it dustwind-mysql bash<br>mysql -uroot -p&quot;123456&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">直接一步到位进入 MySQL 容器</span><br>docker exec -it dustwind-mysql mysql -uroot -p&quot;123456&quot; <br></code></pre></td></tr></table></figure><p>开放 MySQL 的远程访问权限：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">use mysql<br>ALTER USER &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;123456&#x27;;<br>flush privileges;<br></code></pre></td></tr></table></figure><blockquote><p>[!重要]<br>如果开放了 MySQL 远程访问权限仍然无法通过 Navicat 等远程工具连接 MySQL，则考虑是云服务器防火墙和阿里云安全策略导致访问被拦截。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/11/06/%E9%85%8D%E7%BD%AE%20VS2022%20%E4%BB%A5%E5%8F%8A%20Qt%20%E7%8E%AF%E5%A2%83/"/>
    <url>/2025/11/06/%E9%85%8D%E7%BD%AE%20VS2022%20%E4%BB%A5%E5%8F%8A%20Qt%20%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p>项目采用 <strong>Visual Studio 2022</strong> 和 <strong>Qt 6.7.3</strong>  作为开发环境，主要阐述 <code>Windows</code> 环境下的配置，<code>Linux</code> 环境下的有时间再配置</p><h1 id="一-Visual-Studio-2022"><a href="#一-Visual-Studio-2022" class="headerlink" title="一.Visual Studio 2022"></a>一.Visual Studio 2022</h1><ol><li>从 <code>Visual Studio</code> 官网下载最新社区版</li></ol><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/VS%E5%AE%98%E7%BD%91.png" alt="VS官网.png"></p><ol start="2"><li><p>打开安装器，在工作负荷栏目选择 【使用C++的桌面开发】和【Visual Studio扩展开发】两项进行安装。前者是 Qt 开发环境需要，后者是 Qt 扩展需要。</p></li><li><p>在安装器中单个组件栏目选择合适的 MSVC 工具链版本，此处的工具链版本要保持 Qt 和 Visual Studio 一致（即 Qt 使用的版本是 MSVC_2022_x64，那么Visual Studio 也要保证版本为 MSVC_2022_x64）。</p></li></ol><h1 id="二-Qt-6-7-3-安装"><a href="#二-Qt-6-7-3-安装" class="headerlink" title="二.Qt 6.7.3 安装"></a>二.Qt 6.7.3 安装</h1><ol><li>访问清华源或者其他镜像源，找到 <code>online_installers</code> 目录，然后下载对应版本下载器即可。<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">这里附上清华源qt安装器地址</span><br>https://mirrors.tuna.tsinghua.edu.cn/qt/official_releases/online_installers/<br></code></pre></td></tr></table></figure></li><li>在下载安装器目录下打开 <code>PowerShell</code> 或者 cmd 命令行，然后执行如下命令临时更换在线安装器镜像进行安装：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">.\qt-online-installer-windows-x64-online.exe --mirror https://mirrors.ustc.edu.cn/qtproject/<br></code></pre></td></tr></table></figure></li></ol><table><thead><tr><th align="center">镜像源提供商</th><th align="center">Qt 镜像地址</th></tr></thead><tbody><tr><td align="center">清华大学</td><td align="center"><code>https://mirrors.tuna.tsinghua.edu.cn/qt/</code></td></tr><tr><td align="center">中国科学技术大学</td><td align="center"><code>https://mirrors.ustc.edu.cn/qtproject/</code></td></tr><tr><td align="center">北京外国语大学</td><td align="center"><code>https://mirrors.bfsu.edu.cn/qt/</code></td></tr></tbody></table><blockquote><p><strong>PS</strong>：<br>推荐使用中科大源进行下载，速度快。</p></blockquote><ol start="3"><li>打开在线安装器后，根据提示登录 Qt 账号，然后选择<strong>安装位置</strong>，<strong>Qt 版本</strong>，<strong>Qt Creator 版本</strong>，<strong>工具链（MSVC，MinGW）</strong> 并安装。</li></ol><blockquote><p><strong>PS</strong>：<br>后续如果想继续安装 Qt 组件，可使用 <code>Qt Maintenance Tool</code> 软件进行。</p></blockquote><h1 id="三-Visual-Studio-Qt-环境配置"><a href="#三-Visual-Studio-Qt-环境配置" class="headerlink" title="三.Visual Studio+Qt 环境配置"></a>三.Visual Studio+Qt 环境配置</h1><ol><li><p>将 Qt 的 MSVC 配置到系统环境变量中，将 Qt 的 QtCreator 配置到系统环境变量中（确保ui文件打开不崩溃，当然还有一种方式可以见下面小节 [[#Visual Studio+Qt 环境配置#Visual Studio 配置 ui 打开方式]]）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">MSVC路径</span><br>D:\SoftWare\DeveloperTools\Qt\Qt6.7.3\6.7.3\msvc2022_64\bin<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">QtCreator路径</span><br>D:\SoftWare\DeveloperTools\Qt\Qt6.7.3\Tools\QtCreator\bin<br></code></pre></td></tr></table></figure></li><li><p>在 Visual Studio 中安装扩展 <code>Qt Visual Studio Tools</code> </p></li><li><p>在 Visual Studio 的 <code>Qt VS Tools</code> 扩展中添加上述系统变量相同的 MSVC 版本</p></li></ol><h2 id="Visual-Studio-配置-ui-打开方式"><a href="#Visual-Studio-配置-ui-打开方式" class="headerlink" title="Visual Studio 配置 ui 打开方式"></a>Visual Studio 配置 ui 打开方式</h2><ol><li>选择项目中 ui 文件，右键点击打开方式</li></ol><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E6%89%93%E5%BC%80%E6%96%B9%E5%BC%8F.png" alt="打开方式.png"></p><ol start="2"><li>选择Qt Widgets Designer，然后点击添加按钮</li></ol><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E6%B7%BB%E5%8A%A0.png" alt="添加.png"></p><ol start="3"><li>在添加选项中添加 MinGW 中的 Qt Designer 程序</li></ol><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E6%B7%BB%E5%8A%A0Deigner.png" alt="添加Deigner.png"></p><p>具体路径可参考：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">Qt Designer 路径</span><br>D:\SoftWare\DeveloperTools\Qt\Qt6.7.3\6.7.3\mingw_64\bin<br></code></pre></td></tr></table></figure><p>配置完成即可正常打开 ui 文件而不导致崩溃了。</p><p>参考文章：</p><p><a href="https://mingshiqiang.blog.csdn.net/article/details/108015209">1.VS2019 Qt开发环境搭建与配置</a></p><p><a href="https://blog.csdn.net/ZJQSDSA/article/details/140844731?spm=1001.2014.3001.5506">2.Visual Studio 2022 + QT6.9</a></p><p><a href="https://blog.csdn.net/zhouxingwei88/article/details/141194829">3.VS2022无法登录微软账号问题</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/11/06/%E9%85%8D%E7%BD%AE%20Redis/"/>
    <url>/2025/11/06/%E9%85%8D%E7%BD%AE%20Redis/</url>
    
    <content type="html"><![CDATA[<h1 id="一-Windows-环境下安装-MySQL"><a href="#一-Windows-环境下安装-MySQL" class="headerlink" title="一.Windows 环境下安装 MySQL"></a>一.Windows 环境下安装 MySQL</h1><p>在 Windows 环境下安装 Redis 主要是借助 Visual Studio 的 MSVC 工具集进行开发。后续当然还是将工程迁移到 Linux 系统上最好。</p><h2 id="下载安装包"><a href="#下载安装包" class="headerlink" title="下载安装包"></a>下载安装包</h2><h2 id="编译安装"><a href="#编译安装" class="headerlink" title="编译安装"></a>编译安装</h2><h1 id="二-Linux-环境下安装-Redis"><a href="#二-Linux-环境下安装-Redis" class="headerlink" title="二.Linux 环境下安装 Redis"></a>二.Linux 环境下安装 Redis</h1><h2 id="2-1-安装服务端和客户端"><a href="#2-1-安装服务端和客户端" class="headerlink" title="2.1 安装服务端和客户端"></a>2.1 安装服务端和客户端</h2><p>Linux的 Redis 库直接编译安装即可。ArchLinux 系统中安装 Redis 即可。</p><ol><li><p>首先安装 <code>redis</code> 服务端库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S redis<br></code></pre></td></tr></table></figure></li><li><p>然后启动服务并设置为开机自启</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">立即启动服务</span><br>sudo systemctl start redis<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置开机自启动</span><br>sudo systemctl enable redis<br></code></pre></td></tr></table></figure></li><li><p>安装 <code>hiredis</code> 客户端库:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S hiredis<br></code></pre></td></tr></table></figure></li></ol><h2 id="2-2-测试与编译"><a href="#2-2-测试与编译" class="headerlink" title="2.2 测试与编译"></a>2.2 测试与编译</h2><h3 id="测试代码"><a href="#测试代码" class="headerlink" title="测试代码"></a>测试代码</h3><ol><li><p>首先编写一段简单的测试代码，在合适的位置创建一个 <code>test_redis.cpp</code> 文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">创建测试文件</span><br>sudo touch test_redis.cpp<br><span class="hljs-meta prompt_"># </span><span class="language-bash">打开并编辑测试文件</span><br>sudo vim test_redis.cpp<br></code></pre></td></tr></table></figure></li><li><p>然后将下面代码粘贴进去：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;hiredis/hiredis.h&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 连接Redis服务器</span><br>    redisContext *c = <span class="hljs-built_in">redisConnect</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">6379</span>);<br>    <span class="hljs-keyword">if</span> (c == <span class="hljs-literal">NULL</span> || c-&gt;err) &#123;<br>        <span class="hljs-keyword">if</span> (c) &#123;<br>            std::cerr &lt;&lt; <span class="hljs-string">&quot;连接错误: &quot;</span> &lt;&lt; c-&gt;errstr &lt;&lt; std::endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            std::cerr &lt;&lt; <span class="hljs-string">&quot;无法分配redisContext。&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;成功连接到Redis服务器&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 执行SET命令</span><br>    redisReply *reply = (redisReply *)<span class="hljs-built_in">redisCommand</span>(c, <span class="hljs-string">&quot;SET %s %s&quot;</span>, <span class="hljs-string">&quot;my_key&quot;</span>, <span class="hljs-string">&quot;Hello from C++!&quot;</span>);<br>    <span class="hljs-keyword">if</span> (reply == <span class="hljs-literal">NULL</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;执行SET命令失败。&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-built_in">redisFree</span>(c);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-built_in">freeReplyObject</span>(reply);<br><br>    <span class="hljs-comment">// 执行GET命令</span><br>    reply = (redisReply *)<span class="hljs-built_in">redisCommand</span>(c, <span class="hljs-string">&quot;GET %s&quot;</span>, <span class="hljs-string">&quot;my_key&quot;</span>);<br>    <span class="hljs-keyword">if</span> (reply == <span class="hljs-literal">NULL</span>) &#123;<br>        std::cerr &lt;&lt; <span class="hljs-string">&quot;执行GET命令失败。&quot;</span> &lt;&lt; std::endl;<br>        <span class="hljs-built_in">redisFree</span>(c);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    &#125;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;获取到的值: &quot;</span> &lt;&lt; reply-&gt;str &lt;&lt; std::endl;<br>    <span class="hljs-built_in">freeReplyObject</span>(reply);<br><br>    <span class="hljs-comment">// 断开连接</span><br>    <span class="hljs-built_in">redisFree</span>(c);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>最后保存退出。</p></li></ol><h3 id="编译运行"><a href="#编译运行" class="headerlink" title="编译运行"></a>编译运行</h3><p>在终端中编译并运行此测试示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">编译</span><br>g++ -o test_redis test_redis.cpp -lhiredis<br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行</span><br>./test_redis<br></code></pre></td></tr></table></figure><p>示例结果如下所示：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">成功连接到Redis服务器 <br>获取到的值: Hello <span class="hljs-keyword">from</span> C++!<br></code></pre></td></tr></table></figure><h2 id="2-3-更多配置"><a href="#2-3-更多配置" class="headerlink" title="2.3 更多配置"></a>2.3 更多配置</h2><p>将远程连接，持久化，认证密码等配置写入配置文件。在 <code>/etc/redis.conf</code> 中即可配置相关项</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs config"># 1.远程连接，允许远程连接<br>bind 0.0.0.0<br># 开启保护模式，默认是yes（限制为本地访问），【这样做会降低安全性，请确保你的防火墙已正确配置】<br>protected-mode no<br><br># 2.持久化，开启之后Redis不会每次重启自动清空<br>appendonly yes<br><br># 3.认证密码，为Redis设置访问密码<br>requirepass ~K^S0Y^E+ijGkp_^<br></code></pre></td></tr></table></figure><h1 id="三-Docker-环境下安装-Redis"><a href="#三-Docker-环境下安装-Redis" class="headerlink" title="三.Docker 环境下安装 Redis"></a>三.Docker 环境下安装 Redis</h1><p>将 Redis 部署到 Docker 环境中可以有效隔绝外部攻击，通过设置不同策略实现安全访问 Redis 服务。笔者在云服务器 Linux 系统上部署 Docker 环境，并在 Docker 环境中部署 Redis 实现远程访问 Redis 服务。</p><p>具体安装流程可以参看 [[Docker 配置 Redis 和 MySQL]]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2025/11/06/%E9%85%8D%E7%BD%AE%20MySQL/"/>
    <url>/2025/11/06/%E9%85%8D%E7%BD%AE%20MySQL/</url>
    
    <content type="html"><![CDATA[<h1 id="一-Windows-环境下安装-MySQL"><a href="#一-Windows-环境下安装-MySQL" class="headerlink" title="一.Windows 环境下安装 MySQL"></a>一.Windows 环境下安装 MySQL</h1><p>在 Windows 环境下安装 MySQL 主要是借助 Visual Studio 的 MSVC 工具集进行开发。后续当然还是将工程迁移到 Linux 系统上最好。</p><p>在 MySQL 官网（<a href="https://dev.mysql.com/downloads/mysql/">MySQL官网</a>)）可以看到三种方式：安装器，压缩包，调试测试版本。</p><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E7%89%88%E6%9C%AC%E9%80%89%E6%8B%A9.png" alt="版本选择.png"></p><p>对于开发和运维而言，前面两种是最常用的。通过安装器安装直接通过 MySQL Installer 可执行文件运行即可。下面详细阐述<code>通过压缩包安装</code></p><h2 id="1-1-下载并安装-MySQL-服务"><a href="#1-1-下载并安装-MySQL-服务" class="headerlink" title="1.1 下载并安装 MySQL 服务"></a>1.1 下载并安装 MySQL 服务</h2><p>此方法通过下载压缩包然后自己解压配置 MySQL 环境。</p><ol><li>首先，选择开发需要的稳定版本压缩包并下载。笔者这里选择 <code>8.0.41</code> 版本安装。</li><li>然后，将对应版本 MySQL 压缩包解压到想要安装的位置笔者安装到下面的路径。</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">D</span>:\SoftWare\DeveloperEnv\MySQL\mysql-<span class="hljs-number">8</span>.<span class="hljs-number">0</span>.<span class="hljs-number">41</span><br></code></pre></td></tr></table></figure><ol start="3"><li>在解压完的 MySQL 目录创建一个 <code>my.ini</code> 文件并填入如下内容</li></ol><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-section">[mysqld]</span><br><span class="hljs-comment"># 设置3308端口</span><br><span class="hljs-attr">port</span>=<span class="hljs-number">3308</span><br><span class="hljs-comment"># 设置 MySQL 安装目录</span><br><span class="hljs-attr">basedir</span>=D:\SoftWare\DeveloperEnv\MySQL\mysql-<span class="hljs-number">8.0</span>.<span class="hljs-number">41</span><br><span class="hljs-comment"># 设置 MySQL 数据库数据存放目录（此处可能需要自己在bin的同级目录创建data文件夹）</span><br><span class="hljs-attr">datadir</span>=D:\SoftWare\DeveloperEnv\MySQL\mysql-<span class="hljs-number">8.0</span>.<span class="hljs-number">41</span>\data<br><span class="hljs-comment"># 允许最大连接数</span><br><span class="hljs-attr">max_connections</span>=<span class="hljs-number">200</span><br><span class="hljs-comment"># 允许连接失败的次数。</span><br><span class="hljs-attr">max_connect_errors</span>=<span class="hljs-number">10</span><br><span class="hljs-comment"># 服务端使用的字符集默认为 utf8</span><br><span class="hljs-attr">character-set-server</span>=utf8<br><span class="hljs-comment"># 创建新表时将使用的默认存储引擎</span><br><span class="hljs-attr">default-storage-engine</span>=INNODB<br><span class="hljs-comment"># 默认使用“mysql_native_password”插件认证</span><br><span class="hljs-comment">#mysql_native_password</span><br><span class="hljs-attr">default_authentication_plugin</span>=mysql_native_password<br><span class="hljs-section">[mysql]</span><br><span class="hljs-comment"># 设置 MySQL 客户端默认字符集</span><br><span class="hljs-attr">default-character-set</span>=utf8<br><span class="hljs-section">[client]</span><br><span class="hljs-comment"># 设置 MySQL 客户端连接服务端时默认使用的端口</span><br><span class="hljs-attr">port</span>=<span class="hljs-number">3308</span><br><span class="hljs-attr">default-character-set</span>=utf8<br></code></pre></td></tr></table></figure><ol start="4"><li>在 MySQL 安装目录的 bin 目录下打开终端并输入如下命令初始化 MySQL 数据库</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">初始化 MySQL 生成一个随机密码</span><br>.\mysqld.exe --initialize --console<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">此次生成的随机密码为： yjIW7:p*Pn,j</span><br></code></pre></td></tr></table></figure><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E5%88%9D%E5%A7%8B%E5%8C%96MySQL.png" alt="初始化MySQL.png"></p><ol start="5"><li>在 MySQL 安装目录的 bin 目录下以管理员身份打开终端并输入如下命令安装并运行 MySQL 服务</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash"><span class="hljs-comment"># 安装 MySQL 服务并运行</span></span>  <br>.\mysqld.exe --install mysql<br></code></pre></td></tr></table></figure><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E5%AE%89%E8%A3%85MySQL%E6%9C%8D%E5%8A%A1.png" alt="安装MySQL服务.png"></p><h2 id="1-2-修改-MySQL-密码"><a href="#1-2-修改-MySQL-密码" class="headerlink" title="1.2 修改 MySQL 密码"></a>1.2 修改 MySQL 密码</h2><ol><li><code>Win+R</code> 输入 <code>services.msc</code> 找到名为 <code>mysql</code> 的服务项并设置为自动启动，这样系统每次开机会自动启动 MySQL 服务。</li></ol><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E8%87%AA%E5%8A%A8%E5%90%AF%E5%8A%A8.png" alt="自动启动.png"></p><ol start="2"><li>依然是在 MySQL 安装目录的 bin 目录下打开终端并输入如下命令安装并运行 MySQL</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">.\mysql.exe -uroot -p<br></code></pre></td></tr></table></figure><p>第一次运行，此处输入的密码为之前初始化生成的随机密码</p><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E7%AC%AC%E4%B8%80%E6%AC%A1%E8%BF%90%E8%A1%8CMySQL.png" alt="第一次运行MySQL.png"></p><ol start="3"><li>进入 MySQL 终端命令行后将密码更改为自己记住的密码</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">修改密码为123456</span><br>ALTER USER &#x27;root&#x27;@&#x27;localhost&#x27; IDENTIFIED BY &#x27;123456&#x27;;<br></code></pre></td></tr></table></figure><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E6%9B%B4%E6%94%B9%E5%AF%86%E7%A0%81.png" alt="更改密码.png"></p><p>成功之后下一次登录 MySQL 时用最新的密码即可。</p><h2 id="1-3-配置环境变量"><a href="#1-3-配置环境变量" class="headerlink" title="1.3 配置环境变量"></a>1.3 配置环境变量</h2><p>由于 MySQL 解压缩到一个不知名路径下，每次只能在 MySQL 安装目录下的 bin 目录中调用终端运行 MySQL 命令行，系统无法找到此程序的路径，因此需要配置系统环境变量。</p><ol><li>打开系统环境变量然后创建一个 <code>MySQL_HOME</code> 然后将 <code>MySQL_HOME</code> 添加到 <code>path</code> 变量中。</li></ol><p>添加  <code>MySQL_HOME</code> 结果：<br><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E6%96%B0%E5%BB%BAMySQL_HOME.png" alt="新建MySQL_HOME.png"></p><p>添加 <code>path</code> 变量结果：<br><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E6%B7%BB%E5%8A%A0path%E5%8F%98%E9%87%8F.png" alt="添加path变量.png"></p><p>添加环境变量后运行 MySQL 结果：<br><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E6%B7%BB%E5%8A%A0%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E5%90%8E%E8%AE%BF%E9%97%AE.png" alt="添加环境变量后访问.png"></p><h2 id="1-4-JDBC-风格接口"><a href="#1-4-JDBC-风格接口" class="headerlink" title="1.4 JDBC 风格接口"></a>1.4 JDBC 风格接口</h2><h3 id="下载-Mysql-Connector-C-库"><a href="#下载-Mysql-Connector-C-库" class="headerlink" title="下载 Mysql Connector C++ 库"></a>下载 Mysql Connector C++ 库</h3><p>标准 MySQL 服务提供的数据库访问接口是基于 <strong>C 语言</strong>风格的，为适应<strong>面向对象编程设计</strong>，改用 <code>Mysql Connector C++</code> 库提供的接口访问 MySQL。</p><blockquote><p>[!tip]<br><code>Mysql Connector C++</code> 版本要与开发环境相对应，如果开发环境为 <code>debug</code> 版本，那么<code>Mysql Connector C++</code> 也需要下载 <code>debug</code> 版本；反之，如果开发环境为 <code>release</code> 版本，那么<code>Mysql Connector C++</code> 也需要下载 <code>release</code> 版本。否则会报 <code>terminate called after throwing an instance of &#39;std::bad_alloc&#39;</code> 错误.</p></blockquote><p>在 MySQL 官网（<a href="https://dev.mysql.com/downloads/connector/cpp/">Mysql Connector C++</a>）下载对应版本，由于在此 Windows 环境下为 <code>debug</code> 版本，因此 <code>Mysql Connector C++</code> 也下载 <code>debug</code> 版本。笔者这里选择 <code>8.3.0</code> 版本安装。</p><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/debug%E7%89%88%E6%9C%AC.png" alt="debug版本.png"></p><h3 id="VS-工程配置-Mysql-Connector-C"><a href="#VS-工程配置-Mysql-Connector-C" class="headerlink" title="VS 工程配置 Mysql Connector C++"></a>VS 工程配置 Mysql Connector C++</h3><ol><li>将下载的压缩包解压到安装目录，这里笔者将其放置在 MySQL 同一路径下统一管理。</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">D</span>:\SoftWare\DeveloperEnv\MySQL\mysql-<span class="hljs-number">8</span>.<span class="hljs-number">0</span>.<span class="hljs-number">41</span><br></code></pre></td></tr></table></figure><ol start="2"><li>在 Visual Studio 工程中配置如下项：</li></ol><p>在 <code>VC++ 目录</code> 的 <code>包含目录项</code> 添加如下路径：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">D</span>:\SoftWare\DeveloperEnv\MySQL\mysql-connector-c++-<span class="hljs-number">8</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span>\include<br><br></code></pre></td></tr></table></figure><p>在 <code>VC++ 目录</code> 的 <code>库目录项</code> 添加如下路径：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">D</span>:\SoftWare\DeveloperEnv\MySQL\mysql-connector-c++-<span class="hljs-number">8</span>.<span class="hljs-number">3</span>.<span class="hljs-number">0</span>\lib64\vs14<br></code></pre></td></tr></table></figure><p>将 <code>D:\SoftWare\DeveloperEnv\MySQL\mysql-connector-c++-8.3.0\lib64\debug</code>  目录下的 <code>mysqlcppconn8-2-vs14.dll</code> 和<code>mysqlcppconn9-vs14.dll</code> 两文件拷贝到项目根目录下。</p><p>同时为了编译后程序能正常运行，需要将这两文件拷贝到 debug 环境中，因此可以通过在 <code>生成事件-&gt;生成后事件</code> 中添加如下代码自动复制这两个动态库文件。</p><figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nsis">xcopy <span class="hljs-string">&quot;<span class="hljs-variable">$(ProjectDir)</span>config.ini&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$(SolutionDir)</span><span class="hljs-variable">$(Platform)</span>\<span class="hljs-variable">$(Configuration)</span>\&quot;</span> /y <br>xcopy <span class="hljs-string">&quot;<span class="hljs-variable">$(ProjectDir)</span>*.dll&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$(SolutionDir)</span><span class="hljs-variable">$(Platform)</span>\<span class="hljs-variable">$(Configuration)</span>\&quot;</span> /y<br></code></pre></td></tr></table></figure><h1 id="二-Linux-环境下安装-MySQL"><a href="#二-Linux-环境下安装-MySQL" class="headerlink" title="二.Linux 环境下安装 MySQL"></a>二.Linux 环境下安装 MySQL</h1><p>Linux的 MySQL 库直接编译安装即可。ArchLinux 系统中安装 MySQL 即可。</p><h2 id="2-1-安装"><a href="#2-1-安装" class="headerlink" title="2.1 安装"></a>2.1 安装</h2><p>直接在官方仓库获取 MySQL 包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S mysql<br></code></pre></td></tr></table></figure><blockquote><p>[!tip]<br>在 ArchLinux 的软件仓库中，<code>mysql</code> 这个包实际提供的是 <strong>MariaDB</strong>（一个广泛兼容的 MySQL 分支）。对于大多数情况，它们的使用方式是一致的。如果要安装 Oracle 官方的 MySQL，可能需要添加其他第三方源，但 MariaDB 通常是推荐且更易于维护的选择。</p></blockquote><h2 id="2-2-初始化"><a href="#2-2-初始化" class="headerlink" title="2.2 初始化"></a>2.2 初始化</h2><p>使用如下命令进行 MySQL 数据库初始化，初始化会生成系统数据库表和 root 用户临时密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">初始化 MySQL 生成一个随机密码</span><br>sudo mysqld --initialize --user=mysql --basedir=/usr --datadir=/var/lib/mysql<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">此次生成的随机密码为： hf2jsTeO5t,&gt;</span><br></code></pre></td></tr></table></figure><p>初始化结果示例如下图：</p><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E5%88%9D%E5%A7%8B%E5%8C%96.png" alt="初始化.png"></p><blockquote><p>[!tip]<br><code>/var/lib/mysql</code>目录非空导致初始化失败，需要先清理该目录（<strong>注意：这会删除所有现有MySQL数据</strong>），然后再重新执行初始化</p></blockquote><h2 id="2-3-基本配置"><a href="#2-3-基本配置" class="headerlink" title="2.3 基本配置"></a>2.3 基本配置</h2><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p>初始化成功就可以启动 MySQL 服务器端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">立即启动服务</span><br>sudo systemctl start mysqld  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置开机自启动</span>   <br>sudo systemctl enable mysqld   <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看状态mysqld</span><br>sudo systemctl status mysqld<br></code></pre></td></tr></table></figure><h3 id="登录服务"><a href="#登录服务" class="headerlink" title="登录服务"></a>登录服务</h3><p>然后登录到 MySQL 命令行，此处登录的密码为初始化时生成的随机密码</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mysql -u root -p<br></code></pre></td></tr></table></figure><h3 id="修改密码"><a href="#修改密码" class="headerlink" title="修改密码"></a>修改密码</h3><p>为方便下次登录，可更改密码：</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs pgsql"># 修改密码为<span class="hljs-number">123456</span><br><span class="hljs-keyword">ALTER</span> <span class="hljs-keyword">USER</span> <span class="hljs-string">&#x27;root&#x27;</span>@<span class="hljs-string">&#x27;localhost&#x27;</span> IDENTIFIED <span class="hljs-keyword">BY</span> <span class="hljs-string">&#x27;123456&#x27;</span>;<br></code></pre></td></tr></table></figure><p>更改成功后，下次登录使用新的密码</p><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>为了方便地在任何路径下直接使用 <code>mysql</code>等命令，你可以将 MySQL 的可执行文件路径添加到系统的环境变量 <code>PATH</code>中。</p><ol><li><p>编辑配置文件 <code>/etc/profile</code>：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim /etc/profile<br></code></pre></td></tr></table></figure></li><li><p>在文件末尾添加以下行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">export MYSQL_HOME=/usr <br>export PATH=$PATH:$MYSQL_HOME/bin<br></code></pre></td></tr></table></figure></li></ol><blockquote><p>[!tip]<br>MySQL 的默认安装路径可能在 <code>/usr/bin</code>，该路径通常已在 <code>PATH</code>中，如需指定 <code>MYSQL_HOME</code>可参考此步骤</p></blockquote><ol start="3"><li>保存文件后，使用 <code>source</code>命令使更改立即生效：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">source /etc/profile<br></code></pre></td></tr></table></figure></li></ol><h3 id="图形化管理"><a href="#图形化管理" class="headerlink" title="图形化管理"></a>图形化管理</h3><p>在 Linux 系统上可以安装图形化数据库管理工具，例如 <strong>DBeaver</strong>。使用 pacman 安装 DBeaver，也可以在 AUR 仓库中获取 Navicat：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S dbeaver<br></code></pre></td></tr></table></figure><blockquote><p>[!tip]<br>DBeaver 和 DataGrip 是同种类型风格的数据库管理软件，而 Navicat 风格稍有区别</p></blockquote><h2 id="2-4-JDBC-风格接口"><a href="#2-4-JDBC-风格接口" class="headerlink" title="2.4 JDBC 风格接口"></a>2.4 JDBC 风格接口</h2><p>采用 JDBC 封装接口依然需要 MySQL 的配置环境，它与 <strong>C 封装接口</strong>区别在于 <strong>JDBC 封装接口</strong>更适应<strong>面向对象编程设计</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">安装 MySQL 开发包（用于 C API），同时也是 MySQL Connector/C++ 所依赖环境<br>sudo pacman -S mysql <br></code></pre></td></tr></table></figure><p>手动源码安装 MySQL Connector&#x2F;C++</p><ol><li>安装依赖：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S base-devel cmake gcc openssl boost<br></code></pre></td></tr></table></figure></li></ol><p><strong>【待更新】</strong></p><h3 id="从官方源下载最新版本"><a href="#从官方源下载最新版本" class="headerlink" title="从官方源下载最新版本"></a>从官方源下载最新版本</h3><p>访问 MySQL Connector&#x2F;C++ 下载页面获取最新下载链接（当前最新版本为 8.1.0）。</p><p><strong>【待更新】</strong></p><h2 id="2-5-测试与编译"><a href="#2-5-测试与编译" class="headerlink" title="2.5 测试与编译"></a>2.5 测试与编译</h2><p>C 封装接口就不做过多测试，实际开发过程更多是使用 C++，因此只设计针对 JDBC 封装接口的测试用例</p><h1 id="三-Docker-环境下安装-MySQL"><a href="#三-Docker-环境下安装-MySQL" class="headerlink" title="三.Docker 环境下安装 MySQL"></a>三.Docker 环境下安装 MySQL</h1><p>将 MySQL 部署到 Docker 环境中可以有效隔绝外部攻击，通过设置不同策略实现安全访问 MySQL 服务。笔者在云服务器 Linux 系统上部署 Docker 环境，并在 Docker 环境中部署 MySQL 实现远程访问 MySQL 服务。</p><p>具体安装流程可以参看 [[Docker 配置 Redis 和 MySQL]]</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Obsidian UML 图插件</title>
    <link href="/2025/11/06/Obsidian%20UML%20%E5%9B%BE%E6%8F%92%E4%BB%B6/"/>
    <url>/2025/11/06/Obsidian%20UML%20%E5%9B%BE%E6%8F%92%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="一-Mermaid-插件"><a href="#一-Mermaid-插件" class="headerlink" title="一.Mermaid 插件"></a>一.Mermaid 插件</h1><h2 id="1-基本语法"><a href="#1-基本语法" class="headerlink" title="1.基本语法"></a>1.基本语法</h2><p>在 Obsidian 中创建一个代码块，将语言设置为 <code>mermaid</code>，然后在代码块中编写你的类图语法。举例如下</p><pre><code class=" mermaid">---title: Animal example---classDiagram    note &quot;From Duck till Zebra&quot;    Animal &lt;|-- Duck    note for Duck &quot;can fly\ncan swim\ncan dive\ncan help in debugging&quot;    Animal &lt;|-- Fish    Animal &lt;|-- Zebra    Animal : +int age    Animal : +String gender    Animal: +isMammal()    Animal: +mate()    class Duck&#123;        +String beakColor        +swim()        +quack()    &#125;    class Fish&#123;        -int sizeInFeet        -canEat()    &#125;    class Zebra&#123;        +bool is_wild        +run()    &#125;</code></pre><h2 id="2-详细语法"><a href="#2-详细语法" class="headerlink" title="2.详细语法"></a>2.详细语法</h2><h3 id="定义类与成员"><a href="#定义类与成员" class="headerlink" title="定义类与成员"></a>定义类与成员</h3><ul><li><strong>定义区域</strong>：使用 <code>classDiagram</code> 标定绘制类图的区域。</li><li><strong>定义类</strong>：使用 <code>class ClassName &#123;&#125;</code> 格式标定类，成员写在花括号内。</li><li><strong>成员可见性</strong>：使用 <code>+</code>（公共）、<code>-</code>（私有）、<code>#</code>（保护）、<code>~</code>（包&#x2F;内部）来修饰成员</li><li><strong>区分方法与属性</strong>：名称后带括号 <code>()</code>的被视为方法，否则为属性</li></ul><h3 id="定义类关系"><a href="#定义类关系" class="headerlink" title="定义类关系"></a>定义类关系</h3><p>类图的核心在于表达类之间的关系，Mermaid 支持多种关系类型：</p><table><thead><tr><th align="center">关系</th><th align="center">符号</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">继承(泛化)(Inheritance)</td><td align="center">&lt;|–</td><td align="center"></td></tr><tr><td align="center">组合(Composition)</td><td align="center">*–</td><td align="center"></td></tr><tr><td align="center">聚合(Aggregation)</td><td align="center">o–</td><td align="center">表示强的”拥有”关系，部分与整体同生共死。</td></tr><tr><td align="center">关联(Association)</td><td align="center">- - &gt;</td><td align="center">符号间无空格。表示弱的”拥有”关系，部分可以独立于整体。</td></tr><tr><td align="center">实线连接(Link-Solid)</td><td align="center">–</td><td align="center">表示类之间的已知联系，如单向关联。</td></tr><tr><td align="center">依赖(Dependency)</td><td align="center">..&gt;</td><td align="center">表示一个类的变化会影响另一个类（如使用局部变量）。</td></tr><tr><td align="center">实现(Realization)</td><td align="center">..|&gt;</td><td align="center"></td></tr><tr><td align="center">虚线连接(Link-Dashed)</td><td align="center">..</td><td align="center"></td></tr></tbody></table><p>具体举例如下：</p><pre><code class=" mermaid">classDiagramclassA --|&gt; classB : InheritanceclassC --* classD : CompositionclassE --o classF : AggregationclassG --&gt; classH : AssociationclassI -- classJ : Link(Solid)classK ..&gt; classL : DependencyclassM ..|&gt; classN : RealizationclassO .. classP : Link(Dashed)</code></pre><blockquote><p>[!注意]</p><ul><li>**继承 (Inheritance)**： 描述的是 **“是不是” (is-a)**的关系。继承是类与类的直接关系。比如，狗是一种动物。</li><li>**实现 (Realization)**： 描述的是 **“有没有能力” (can-do)**的关系。实现是类与接口的关系。比如，飞机有能力飞行。</li></ul></blockquote><p>更多更详细语法可以参见 <a href="https://mermaid.js.org/syntax/classDiagram.html">Class diagrams</a></p><h1 id="二-PlantUML-插件"><a href="#二-PlantUML-插件" class="headerlink" title="二.PlantUML 插件"></a>二.PlantUML 插件</h1><h2 id="1-配置使用"><a href="#1-配置使用" class="headerlink" title="1.配置使用"></a>1.配置使用</h2><p>首先安装在 Obsidian 第三方插件中搜索并安装 PlantUML 插件。然后是选择合适的渲染方式：在线服务器渲染，本地渲染（进阶用户）。</p><h3 id="在线服务器渲染"><a href="#在线服务器渲染" class="headerlink" title="在线服务器渲染"></a>在线服务器渲染</h3><p>此种方法的核心是将代码发送至 PlantUML 服务器然后生成图片，通常无需额外配置即可使用默认的在线服务器。。它明确需要足够稳定的网络，如果网络卡顿将极大影响生成时间。</p><blockquote><p>[!注意]<br>如果遇到中文显示为乱码（方框），一个有效的解决方法是进入插件设置，将渲染格式切换到 <strong>SVG</strong>，因为 SVG 是矢量格式，对中文支持更好</p></blockquote><h3 id="本地渲染"><a href="#本地渲染" class="headerlink" title="本地渲染"></a>本地渲染</h3><h4 id="文件下载与配置"><a href="#文件下载与配置" class="headerlink" title="文件下载与配置"></a>文件下载与配置</h4><ol><li><p>首先需要配置 <strong>Java</strong> 环境，详细可以参见 [[学习&#x2F;Java&#x2F;Java 环境配置]]</p></li><li><p>然后是需要配置 <strong>Graphviz</strong> 环境，这是用于绘制布局的软件，PlantUML 依赖它来渲染许多类型的图表（如类图、状态图等）</p></li></ol><blockquote><p>[!注意]<br>从 Graphviz 官网（<a href="https://www.graphviz.org/download/">下载页</a>）下载并安装。对于 Windows 系统，安装后可能需要将安装路径（包含 <code>dot.exe</code>的目录）添加到系统的环境变量 <code>PATH</code>中，或者直接在 PlantUML 插件设置中指定该路径</p></blockquote><p>在命令行输入如下代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dot -v<br></code></pre></td></tr></table></figure><p>得到如下输出则为成功：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">dot - graphviz version 14.0.2 (20251019.1705)<br></code></pre></td></tr></table></figure><ol start="3"><li>最后是下载最新的 <code>plantuml.jar</code>文件。可以从 PlantUML 的官方网站（<a href="https://plantuml.com.cn/">官网首页</a>）下载。然后将其放置在一个可用位置方便管理。使用类似如下命令可以检验安装是否正确：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar D:\SoftWare\PlantUML\plantuml-1.2025.7.jar -tpng demo.puml<br></code></pre></td></tr></table></figure></li></ol><h2 id="2-基本语法"><a href="#2-基本语法" class="headerlink" title="2.基本语法"></a>2.基本语法</h2><p>创建一个代码块，将语言设置为 <code>plantuml</code>。PlantUML 的类图语法非常标准。举例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs plantuml">@startuml<br>class Animal &#123;<br>        +int age<br>        +String gender<br>        +isMammal() bool<br>        +mate()<br>    &#125;<br>    <br>    class Duck &#123;<br>        +String beakColor<br>        +swim()<br>        +quack()<br>    &#125;<br>    <br>    class Dog&#123;<br>    + Color ：String <br>    + bark()<br>    + running()<br>    &#125;<br><br>Animal &lt;|-- Duck<br>Animal &lt;|-- Dog<br>@enduml<br></code></pre></td></tr></table></figure><h2 id="3-详细语法"><a href="#3-详细语法" class="headerlink" title="3.详细语法"></a>3.详细语法</h2><p>更多详细语法可以参见 <a href="https://plantuml.com/zh/">PlantUML 一览</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Obsidian</tag>
      
      <tag>UML</tag>
      
      <tag>classDiagram</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java 环境配置</title>
    <link href="/2025/11/06/Java%20%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2025/11/06/Java%20%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<p>JDK（Java Development Kit）是Java的开发工具包，包含了运行和编写Java程序所需的所有工具。</p><h1 id="Windows-环境"><a href="#Windows-环境" class="headerlink" title="Windows 环境"></a>Windows 环境</h1><h2 id="1-选择-JDK-版本与发行版"><a href="#1-选择-JDK-版本与发行版" class="headerlink" title="1. 选择 JDK 版本与发行版"></a>1. 选择 JDK 版本与发行版</h2><ol><li><strong>版本选择</strong>：对于新项目，建议选择<strong>长期支持（LTS）版本</strong>，如 <strong>JDK 17</strong>或 <strong>JDK 21</strong>。它们能获得更长时间的安全更新和维护，更适合企业级开发和初学者学习</li><li><strong>发行版选择</strong>：主要有两大来源：<ul><li><strong>Oracle JDK</strong>：从 Oracle 官网下载，需注意其针对商业使用的许可政策</li><li><strong>OpenJDK</strong>：开源免费，是大多数开发者的首选。你可以从诸如 Eclipse Temurin (Adoptium) 等网站获取预构建的 OpenJDK 版本</li></ul></li></ol><h2 id="2-安装-JDK"><a href="#2-安装-JDK" class="headerlink" title="2.安装 JDK"></a>2.安装 JDK</h2><ul><li>从官网下载适合你操作系统（Windows, macOS, Linux）的安装程序</li><li>运行安装程序，只需按照向导提示操作即可。安装时注意：<ul><li>建议使用默认安装路径，通常路径类似 <code>C:\Program Files\Java\jdk-17</code>（Windows）</li><li>为确保稳定，安装路径中请避免使用中文或空格</li></ul></li></ul><h3 id="下载-JDK"><a href="#下载-JDK" class="headerlink" title="下载 JDK"></a>下载 JDK</h3><p>从官网（<a href="https://www.oracle.com/cn/java/technologies/downloads/#jdk21-windows">JDK 下载页</a>）选择合适的系统和版本下载安装程序。</p><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/jdk%E5%AE%98%E6%96%B9%E4%B8%8B%E8%BD%BD%E9%A1%B5.png" alt="jdk官方下载页.png"></p><blockquote><p>[!注意]<br>注意区别几个版本安装器的区别：</p></blockquote><table><thead><tr><th align="center">特性</th><th align="center">x64 Compressed Archive</th><th align="center">x64 Installer</th><th align="center">x64 MSI Installer</th></tr></thead><tbody><tr><td align="center"><strong>格式本质</strong></td><td align="center">绿色压缩包</td><td align="center">图形界面安装程序</td><td align="center">Windows安装程序包</td></tr><tr><td align="center"><strong>安装方式</strong></td><td align="center"><strong>手动解压</strong>并配置环境变量</td><td align="center">图形向导，<strong>下一步式安装</strong></td><td align="center">支持<strong>静默安装</strong>，适合批量部署</td></tr><tr><td align="center"><strong>用户体验</strong></td><td align="center">灵活，但步骤繁琐</td><td align="center"><strong>对个人用户最友好</strong></td><td align="center">对企业IT管理员最友好</td></tr><tr><td align="center"><strong>环境变量</strong></td><td align="center">通常<strong>需要手动配置</strong></td><td align="center">安装程序<strong>可能自动配置</strong></td><td align="center">取决于MSI包的设计</td></tr><tr><td align="center"><strong>适用场景</strong></td><td align="center">高级用户、特定路径需求、自动化脚本</td><td align="center"><strong>个人学习或开发者的首选</strong></td><td align="center">企业统一部署、CI&#x2F;CD流程</td></tr></tbody></table><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><ol><li>安装好JDK后，需要配置系统环境变量，这样你才能在任何位置通过命令行使用Java命令。</li></ol><table><thead><tr><th>环境变量</th><th>作用</th><th>设置方法</th></tr></thead><tbody><tr><td>JAVA_HOME</td><td>指明JDK的安装根目录，许多 Java 相关工具依赖此变量。</td><td>新建一个系统变量，变量名为 <code>JAVA_HOME</code>，变量值为你的JDK安装路径（例如 <code>C:\Program Files\Java\jdk-25</code>）</td></tr><tr><td>Path</td><td>告诉操作系统在哪里查找可执行文件（如<code>java</code>, <code>javac</code>）。</td><td>在现有的<code>Path</code>变量中，<strong>新建</strong>两条记录：<code>%JAVA_HOME%\bin</code>和 <code>%JAVA_HOME%\jre\bin</code><br>这使得系统能在JDK的<code>bin</code>目录下找到Java</td></tr></tbody></table><ol start="2"><li>配置完成后，在命令行输入如下命令查看是否配置成功：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -version<br>javac -version<br></code></pre></td></tr></table></figure><ol start="3"><li>看到类似下图的版本信息，则表明 Java 运行环境和编译器都已就绪：</li></ol><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/javac-version.png" alt="javac-version.png"></p><h3 id="编写示例程序"><a href="#编写示例程序" class="headerlink" title="编写示例程序"></a>编写示例程序</h3><ol><li>新建一个<code>helloworld.java</code> 文件并写入如下内容：</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloWorld</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello, Java新手们！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>然后在命令行中输入如下命令运行此 Java 程序：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java helloworld.java<br></code></pre></td></tr></table></figure><ol start="3"><li>输出如下示例则表示成功：</li></ol><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E7%A4%BA%E4%BE%8B%E7%A8%8B%E5%BA%8F%E8%BF%90%E8%A1%8C.png" alt="示例程序运行.png"></p>]]></content>
    
    
    
    <tags>
      
      <tag>Java</tag>
      
      <tag>JDK</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Ela项目学习</title>
    <link href="/2025/08/31/ElaWidgetTools%20%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/08/31/ElaWidgetTools%20%E9%A1%B9%E7%9B%AE%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>根据作者 Github 上描述，此项目是 FluentUI 风格的 Qt-Widget 组件库。可根据自己需要在 Qt-Widget 项目中集成此风格控件。特此学习此项目并分享自己的学习心得。</p><h1 id="一-ElaWidgetToolsExample-编译"><a href="#一-ElaWidgetToolsExample-编译" class="headerlink" title="一.ElaWidgetToolsExample 编译"></a>一.ElaWidgetToolsExample 编译</h1><h2 id="1-1-项目下载"><a href="#1-1-项目下载" class="headerlink" title="1.1 项目下载"></a>1.1 项目下载</h2><p>进入 <code>Github</code> 找到 <code>LiniYous</code> 大佬的 <code>ElaWidgetTools</code> 项目下载到本地</p><blockquote><p>PS：<br>项目地址：<a href="https://github.com/Liniyous">Liniyous</a><a href="https://github.com/Liniyous/ElaWidgetTools">ElaWidgetTools</a></p></blockquote><p>进入本地创建一个文件夹克隆工程到本地：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/Liniyous/ElaWidgetTools.git<br></code></pre></td></tr></table></figure><h2 id="1-2-编译例程"><a href="#1-2-编译例程" class="headerlink" title="1.2 编译例程"></a>1.2 编译例程</h2><ol><li>在 <code>ElaWidgetTools</code>中创建 build 目录。然后打开 <code>CMake(cmake-gui)</code> 导入 <code>CMakeLists.txt</code> ，然后设定输出目录为刚刚创建的 build 目录。</li></ol><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/ElaWidgetTools%E5%B7%A5%E7%A8%8B%E7%BC%96%E8%AF%91/CMake%E9%85%8D%E7%BD%AE%E5%B7%A5%E7%A8%8B%E8%B7%AF%E5%BE%84%E5%92%8C%E7%94%9F%E6%88%90%E8%B7%AF%E5%BE%84.png" alt="CMake配置工程路径和生成路径"></p><blockquote><p>PS:<br>注意修改 <code>ElaWidgetTools</code> 目录下 CMakeLists.txt 下 QT_SDK_DIR 变量目录</p></blockquote><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/ElaWidgetTools%E5%B7%A5%E7%A8%8B%E7%BC%96%E8%AF%91/QT_SDK_DIR%E8%AE%BE%E7%BD%AE.png" alt="修改QT_SDK_DIR路径"></p><ol start="2"><li>导入之后点击 configure 按钮配置 VS 工具集版本和系统位数</li></ol><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/ElaWidgetTools%E5%B7%A5%E7%A8%8B%E7%BC%96%E8%AF%91/CMake%E9%85%8D%E7%BD%AEVS%E7%89%88%E6%9C%AC%E5%92%8C%E7%B3%BB%E7%BB%9F%E4%BD%8D%E6%95%B0.png" alt="CMake配置VS工具集和系统位数"></p><ol start="3"><li>配置完成后提示成功就可以继续点击 generate 在 build 目录生成 VS 解决方案，然后打开工程编译生成 <code>ElaWidgetTools</code> 和 <code>ElaWidgetToolsExample</code> 项目：</li></ol><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/ElaWidgetTools%E5%B7%A5%E7%A8%8B%E7%BC%96%E8%AF%91/VS%E7%BC%96%E8%AF%91%E5%B7%A5%E7%A8%8B.png" alt="VS编译工程"></p><ol start="4"><li>拷贝必要的动态库：</li></ol><p>从 build 目录的 <code>ElaWidgeTools</code> 项目的 debug 目录复制生成的 <code>ElaWidgetToolsd.dll</code> 文件到 build 目录 <code>ElaWidgetToolsExample</code> 项目的 debug 目录中。</p><p>在终端中打开 Qt 6.7.3 (MSVC 2022 64-bit) 控制台，然后输入如下命令拷贝程序部署所需动态库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">windeployqt --debug [build目录的ElaWidgetToolsExample工程的debug目录]<br></code></pre></td></tr></table></figure><p>然后就可以打开运行展示例程了。</p><h1 id="二-各控件学习笔记"><a href="#二-各控件学习笔记" class="headerlink" title="二.各控件学习笔记"></a>二.各控件学习笔记</h1>]]></content>
    
    
    
    <tags>
      
      <tag>Qt</tag>
      
      <tag>CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ArchLinux + GNOME 安装教程</title>
    <link href="/2025/04/06/ArchLinux+GNOME%20%E5%AE%89%E8%A3%85/"/>
    <url>/2025/04/06/ArchLinux+GNOME%20%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本安装教程是根据 <a href="https://wiki.archlinuxcn.org/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97">ArchWiki—安装指南 </a> 、 <a href="https://www.cnblogs.com/vconlln/articles/17065410.html">Archlinux安装与美化全流程</a>  以及笔者多次试验总结而成。如有遗漏或者错误请多指正。</p><h1 id="一-准备工作"><a href="#一-准备工作" class="headerlink" title="一.准备工作"></a>一.准备工作</h1><h2 id="1-1-写入软件"><a href="#1-1-写入软件" class="headerlink" title="1.1 写入软件"></a>1.1 写入软件</h2><p>当前市面上有许多U盘烧录工具，如Rufus、USBWriter、Ventoy等。笔者在这里强烈建议使用 Ventoy ，它是由国人制作的一款完全免费的开源工具，可以非常简单地部署启动镜像。在此贴上链接：<a href="https://www.ventoy.net/cn/">Ventoy官网</a> 。   </p><h2 id="1-2-镜像文件"><a href="#1-2-镜像文件" class="headerlink" title="1.2 镜像文件"></a>1.2 镜像文件</h2><p>当今网络非常发达，想要获取资源也有多个途径。简单给出镜像获取的两种途径：</p><ol><li><p>Arch Linux 官方网站下载 ISO 文件：<a href="https://archlinux.org/download/">Arch Linux Downloads</a></p></li><li><p>国内镜像仓库下载系统 ISO 文件：<a href="https://mirrors.tuna.tsinghua.edu.cn/archlinux/iso/">清华源</a>、<a href="https://mirrors.aliyun.com/archlinux/iso/?spm=a2c6h.25603864.0.0.281a7b8755JtRB">阿里云源</a></p></li></ol><blockquote><p><strong>注</strong>：</p><p>由于 Arch Linux 系统采用的是滚动更新模式，因此在安装系统时更推荐选取最新的系统镜像。</p></blockquote><h2 id="1-3-镜像烧录"><a href="#1-3-镜像烧录" class="headerlink" title="1.3 镜像烧录"></a>1.3 镜像烧录</h2><p>笔者使用 Ventoy 软件进行烧录。具体步骤如下：</p><ol><li>在 Windows 系统环境下打开 Ventoy 软件，将分区类型选择为 GPT 格式</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Arch%20Linux%20Install/%E9%95%9C%E5%83%8F%E5%86%99%E5%85%A5%E8%BD%AF%E4%BB%B6Ventoy/1.%E5%90%AF%E5%8A%A8%E7%9B%98%E5%88%86%E5%8C%BA%E9%80%89%E6%8B%A9.png" alt="选择GPT分区格式"  /></div><ol start="2"><li>将 Ventoy 软件安装到 U 盘中</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Arch%20Linux%20Install/%E9%95%9C%E5%83%8F%E5%86%99%E5%85%A5%E8%BD%AF%E4%BB%B6Ventoy/2.%E5%B0%86Ventoy%E5%AE%89%E8%A3%85%E5%88%B0U%E7%9B%98%E9%87%8C.png" alt="安装Ventoy驱动到U盘"  /></div><ol start="3"><li>根据下图可以看到安装 Ventoy 到 U 盘中后界面显示设备内部 Ventoy 软件版本</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Arch%20Linux%20Install/%E9%95%9C%E5%83%8F%E5%86%99%E5%85%A5%E8%BD%AF%E4%BB%B6Ventoy/3.%E6%88%90%E5%8A%9F%E5%B0%86Ventoy%E5%AE%89%E8%A3%85%E5%88%B0U%E7%9B%98%E4%B8%AD.png" alt="Ventoy安装后"  /></div><ol start="4"><li>安装了 Ventoy ，以后想部署任何系统可直接将对应的 ISO 镜像拷贝到 U 盘中即可，然后开机选择对应镜像即可进入。</li></ol><h1 id="二-安装系统"><a href="#二-安装系统" class="headerlink" title="二.安装系统"></a>二.安装系统</h1><p>将写入系统镜像的U盘插到待安装系统的电脑上，开机选择U盘启动项即可开始安装。</p><blockquote><p><strong>注</strong>：</p><p>不少主板有类似于 Secure Boot 的安全选项，如果开启可能导致已经安装 Windows 为第一系统的情况下安装 Linux系统失败，因此这一项应当 Disable 掉。</p></blockquote><h2 id="2-1-检查-UEFI-启动"><a href="#2-1-检查-UEFI-启动" class="headerlink" title="2.1 检查 UEFI 启动"></a>2.1 检查 UEFI 启动</h2><p>首先应当明确一点就是，此主板是支持 BIOS 启动还是 UEFI 启动。因此可以通过如下命令查看详情：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ls /sys/firmware/efi/efivars<br></code></pre></td></tr></table></figure><p>如果此命令显示一大堆文件夹，那么此主板的引导方式就是 UEFI ，否则便是 BIOS 。</p><h2 id="2-2-联网"><a href="#2-2-联网" class="headerlink" title="2.2 联网"></a>2.2 联网</h2><p>由于 Arch Linux 的安装是在线安装模式，网络状况将直接决定安装是否顺利。因此在正式安装前应当配置好网络。</p><h3 id="2-2-1-启用网卡"><a href="#2-2-1-启用网卡" class="headerlink" title="2.2.1 启用网卡"></a>2.2.1 启用网卡</h3><p>如果不确定网卡是否启用，可以通过 <code>rfkill</code> 命令查看网卡状态</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">获取网卡列表及各网卡的状态</span><br>rfkill list<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启用所有网卡</span><br>rfkill unblock all<br></code></pre></td></tr></table></figure><h3 id="2-2-2-有线网络"><a href="#2-2-2-有线网络" class="headerlink" title="2.2.2 有线网络"></a>2.2.2 有线网络</h3><p>针对有线网络。可以直接使用 <code>dhcpcd</code> 命令获取路由器分配的 IP 上网。</p><h3 id="2-2-3-无线网络"><a href="#2-2-3-无线网络" class="headerlink" title="2.2.3 无线网络"></a>2.2.3 无线网络</h3><p>无线网络的配置稍显麻烦一点，可通过 <code>iwctl</code> 命令配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入配置界面</span><br>iwctl<br><span class="hljs-meta prompt_"># </span><span class="language-bash">获取网络设备列表</span><br>device list<br><span class="hljs-meta prompt_"># </span><span class="language-bash">扫描网络设备</span><br>station &lt;device_name&gt; scan  # 如 wlan0<br><span class="hljs-meta prompt_"># </span><span class="language-bash">获取局域网 WiFi 列表</span><br>station &lt;device_name&gt; get-networks<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将对应网络设备连接到指定 WiFi</span><br>station &lt;device_name&gt; connect &lt;WiFi Name&gt; <br></code></pre></td></tr></table></figure><h3 id="2-2-4-验证网络连通性"><a href="#2-2-4-验证网络连通性" class="headerlink" title="2.2.4 验证网络连通性"></a>2.2.4 验证网络连通性</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ping baidu.com<br></code></pre></td></tr></table></figure><p>如果收到网络 icmp 回包则网络配置正确。</p><h2 id="2-3-时间同步"><a href="#2-3-时间同步" class="headerlink" title="2.3 时间同步"></a>2.3 时间同步</h2><p>在正式安装之前也应当配置时间同步，否则可能由于时间验证失败而导致下载安装包失败。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看时间日期状态</span><br>timedatectl status<br><span class="hljs-meta prompt_"># </span><span class="language-bash">启用网络时间同步（NTP ）</span><br>timedatectl set-ntp true<br></code></pre></td></tr></table></figure><h2 id="2-4-更换镜像源"><a href="#2-4-更换镜像源" class="headerlink" title="2.4 更换镜像源"></a>2.4 更换镜像源</h2><p>由于国内访问国外网站可能会很慢或者失败的情况，因此更换国内镜像源显得尤为重要。可通过更改 <code>/etc/pacman.d/mirrorlist</code> 配置文件换源。</p><ol><li>打开配置文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">打开镜像配置文件</span><br>nano /etc/pacman.d/mirrorlist<br></code></pre></td></tr></table></figure><ol start="2"><li>找到第一个 Server 关键字，并在前方添加需要的镜像站链接</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加开源镜像站链接</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">中国科学技术大学</span><br>Server = https://mirrors.ustc.edu.cn/archlinux/$repo/os/$arch <br><span class="hljs-meta prompt_"># </span><span class="language-bash">重庆邮电大学</span><br>Server = https://mirrors.cqupt.edu.cn/archlinux/$repo/os/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重庆大学</span><br>Server = https://mirrors.cqu.edu.cn/archlinux/$repo/os/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">南方科技大学</span><br>Server = https://mirrors.sustech.edu.cn/archlinux/$repo/os/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">华中科技大学</span><br>Server = https://mirrors.hust.edu.cn/archlinux/$repo/os/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">北京外国语大学</span><br>Server = https://mirrors.bfsu.edu.cn/archlinux/$repo/os/$arch<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">华为开源镜像站</span><br>Server = https://mirrors.huaweicloud.com/archlinux/$repo/os/$arch<br><span class="hljs-meta prompt_">#</span><span class="language-bash">Server = https://repo.huaweicloud.com/archlinux/<span class="hljs-variable">$repo</span>/os/<span class="hljs-variable">$arch</span></span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">阿里云镜像站</span><br>Server = http://mirrors.aliyun.com/archlinux/$repo/os/$arch<br></code></pre></td></tr></table></figure><ol start="3"><li>执行如下命令更新同步数据库</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacman -Sy<br></code></pre></td></tr></table></figure><h2 id="2-5-硬盘分区"><a href="#2-5-硬盘分区" class="headerlink" title="2.5 硬盘分区"></a>2.5 硬盘分区</h2><p>对硬盘进行分区是安装 Linux 系统最重要的一步，如有不注意可能导致该盘数据丢失，因此这一步需要格外小心谨慎地操作。可通过 Windows 系统上的 DiskGenius 软件划出一块空闲的硬盘空间，然后进入 Arch Linux 的 LiveCD 之后使用 <code>cfdisk</code> 命令分区完成，举例得到如下几个分区表：</p><table><thead><tr><th align="center">大小</th><th align="center">分区</th><th align="center">分区类型</th><th align="center">挂载点</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">512M</td><td align="center">&#x2F;dev&#x2F;sdb1</td><td align="center">EFI System</td><td align="center">&#x2F;mnt&#x2F;boot</td><td align="center">引导分区</td></tr><tr><td align="center">8G</td><td align="center">&#x2F;dev&#x2F;sdb4</td><td align="center">Linux swap</td><td align="center">—</td><td align="center">交换分区</td></tr><tr><td align="center">100G</td><td align="center">&#x2F;dev&#x2F;sdb5</td><td align="center">Linux root (x86-64)</td><td align="center">&#x2F;mnt</td><td align="center">根分区</td></tr><tr><td align="center">100G</td><td align="center">&#x2F;dev&#x2F;sdb6</td><td align="center">Linux filesystem 或 Linux home</td><td align="center">&#x2F;mnt&#x2F;home</td><td align="center">主目录</td></tr></tbody></table><blockquote><p>注：</p><ol><li><p>交换分区无需分配挂载点，只需分区之后开启或者关闭即可</p></li><li><p>笔者有一个三星 SSD 硬盘以及一个西数的机械硬盘，因此会有两个编号：</p><ol><li>三星 SSD 硬盘编号：<code>/sda</code></li><li>西数 机械 硬盘编号：<code>/sdb</code></li></ol></li><li><p>有的 LiveCD 系统镜像没有 <code>Linux home</code>分区类型，则可以使用 <code>Linux filesystem</code>分区类型</p></li><li><p><code>Legacy</code> 引导方式无需创建 boot 分区，<code>UEFI</code> 引导方式则需要创建 boot 分区。</p></li></ol></blockquote><h3 id="2-5-1-格式化分区"><a href="#2-5-1-格式化分区" class="headerlink" title="2.5.1 格式化分区"></a>2.5.1 格式化分区</h3><p>在使用之前应当要格式化分区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看需要分区列表确定需要格式化的分区</span><br>lsblk -T<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">格式化引导分区</span><br>mkfs.fat -F 32 /dev/sdb1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">格式化交换分区</span><br>mkswap /dev/sdb4<br><span class="hljs-meta prompt_"># </span><span class="language-bash">格式化根分区</span><br>mkfs.ext4 /dev/sdb5<br><span class="hljs-meta prompt_"># </span><span class="language-bash">格式化主目录分区</span><br>mkfs.ext4 /dev/sdb6<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><h3 id="2-5-2-挂载分区"><a href="#2-5-2-挂载分区" class="headerlink" title="2.5.2 挂载分区"></a>2.5.2 挂载分区</h3><p>挂载分区的思路是先创建挂载点，然后将指定目录挂载</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看需要分区列表确定需要挂载的分区</span><br>lsblk -T<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">挂载引导分区</span><br>mount --mkdir /dev/sdb1 /mnt/boot<br><span class="hljs-meta prompt_"># </span><span class="language-bash">开启交换分区</span><br>swapon /dev/sdb4<br><span class="hljs-meta prompt_"># </span><span class="language-bash">挂载根分区</span><br>mount /dev/sdb5 /mnt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">挂载主目录分区</span><br>mount --mkdir /dev/sdb6 /mnt/home<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><p>分区挂载完一定要查看是否挂载成功，否则后续装入系统可能会出现各种问题</p></blockquote><h2 id="2-6-安装基础系统"><a href="#2-6-安装基础系统" class="headerlink" title="2.6 安装基础系统"></a>2.6 安装基础系统</h2><p>使用 <code>pacstrap</code>命令可以安装 Arch Linux 的基本系统</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacstrap -K /mnt base base-devel linux linux-firmware linux-headers<br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><ul><li><p>base 包：基础包</p></li><li><p>base-devel 包：如使用 yay 需要安装此包</p></li><li><p>linux 包：linux 内核包，尽量安装阶段不动，也可替换为 <a href="https://wiki.archlinuxcn.org/wiki/%E5%86%85%E6%A0%B8">Wiki内核页面</a>介绍的如 linux-lts 的其他内核软件包</p></li><li><p>linux-firmware 包：linux 内核固件包</p></li><li><p>linux-headers 包：linux 内核头文件包</p></li></ul><p>PS: base base-devel linux linux-firmware 为最基础的四个包</p></blockquote><h2 id="2-7-安装系统常用软件"><a href="#2-7-安装系统常用软件" class="headerlink" title="2.7 安装系统常用软件"></a>2.7 安装系统常用软件</h2><p>使用 <code>pacstrap</code>命令安装 Arch Linux 系统的常用软件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pacstrap -K /mnt networkmanager dhcpcd openssh iwd  vim nano neofetch sudo ntfs-3g<br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><ul><li><p>networkmanager 包：网络管理软件</p></li><li><p>dhcpcd 包：DHCP 协议 IP 分发客户端</p></li><li><p>openssh 包：远程终端登陆软件</p></li><li><p>iwd 包：提供了客户端程序 <code>iwctl</code>、守护程序 <code>iwd</code> 和 WiFi 监控工具 <code>iwmon</code></p></li><li><p>vim、nano 包：编辑器</p></li><li><p>neofetch 包：查看系统信息软件</p></li><li><p>sudo 包：超级用户权限管理软件</p></li><li><p>ntfs-3g 包：提供 ntfs 文件系统的支持</p></li></ul></blockquote><h2 id="2-8-生成文件系统表"><a href="#2-8-生成文件系统表" class="headerlink" title="2.8 生成文件系统表"></a>2.8 生成文件系统表</h2><p>通常情况下，UEFI 引导搭配的是 GPT 分区格式，而早前的 BIOS 引导则是搭配的 MBR 分区格式。因此，在生成文件系统表时会根据不同搭配使用不同命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">生成文件系统表</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. UEFI + GPT</span><br>genfstab -U /mnt &gt;&gt; /mnt/etc/fstab<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. BIOS + MBR</span><br>genfstab -p /mnt &gt;&gt; /mnt/etc/fstab<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看文件系统表是否生成</span><br>cat /mnt/etc/fstab<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><p>在生成文件系统分区表后一定要查看是否生成，否则万一 boot 分区表没有写入 fstab 文件的话后续配置 Grub 可能会失败</p></blockquote><h1 id="三-配置系统"><a href="#三-配置系统" class="headerlink" title="三.配置系统"></a>三.配置系统</h1><p>第二章节的操作保证了 Arch Linux 基本系统的安装，我们还需要进入新安装的系统内部进行一些更细致的配置。通过 <code>arch-chroot</code> 进入新系统：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">arch-chroot /mnt<br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><p>chroot 的意思就是 change root 的含义，arch-chroot 这条指令的意思就是将操作权从 LiveCD 的启动系统转交给新安装的系统，方便在新系统内部进行更多的配置。</p></blockquote><h2 id="3-1-开机自启服务"><a href="#3-1-开机自启服务" class="headerlink" title="3.1 开机自启服务"></a>3.1 开机自启服务</h2><p>在 <code>第二章第七节</code> 安装了许多除系统基础软件包之外的额外软件包，而有的软件服务是需要开机自启的。下面的命令便是启动开机服务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">systemctl 几个参数的含义</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. <span class="hljs-built_in">enable</span>：设置开机自启，反之为 <span class="hljs-built_in">disable</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. start：设置本次启动，反之为 stop</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3. status：查看服务状态</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">开启网络服务</span><br>systemctl enable NetworkManager.service<br>systemctl start NetworkManager.service<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">开启 dhcpcd 服务</span><br>systemctl enable dhcpcd.service<br>systemctl start dhcpcd.service<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br>开启 ssh 服务<br>systemctl enable sshd.service<br>systemctl start sshd.service<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><h2 id="3-2-设置时区"><a href="#3-2-设置时区" class="headerlink" title="3.2 设置时区"></a>3.2 设置时区</h2><p>使用如下指令设置时区</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -sf /usr/share/zoneinfo/Region地区名/City城市名 /etc/localtime<br><span class="hljs-meta prompt_"># </span><span class="language-bash">举例如下所示</span><br>ln -sf /usr/share/zoneinfo/Asia/Shanghai /etc/localtime<br></code></pre></td></tr></table></figure><p>然后使用 <code>hwclock</code> 命令生成 <code>/etc/adjtime</code> 同步时间配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">hwclock --systohc<br></code></pre></td></tr></table></figure><h2 id="3-3-本地化"><a href="#3-3-本地化" class="headerlink" title="3.3 本地化"></a>3.3 本地化</h2><p>完成本地化需要对两个文件进行处理： <code>locale.gen</code> 文件以及 <code>locale.conf</code> 文件</p><ol><li>编辑 <code>/etc/locale.gen</code> 文件去掉两项内容注释：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">en_US.UTF-8 UTF-8</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">zh_CN.UTF-8 UTF-8</span><br></code></pre></td></tr></table></figure><p>然后使用 <code>locale-gen</code> 命令生成 Locale。</p><ol start="2"><li>编辑 <code>/etc/locale.conf</code> 文件，更改为如下内容</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_">#</span><span class="language-bash">LANG=en_US.UTF-8</span><br>LANG=zh_CN.UTF-8<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br>LC_CTYPE=zh_CN.UTF-8            # 字符输入<br>LC_NUMERIC=zh_CN.UTF-8          # 数字<br>LC_TIME=zh_CN.UTF-8# 时间显示格式<br>LC_COLLATE=zh_CN.UTF-8          # 比较和排序习惯<br>LC_MONETARY=zh_CN.UTF-8         # 货币单位<br>LC_MESSAGES=zh_CN.UTF-8         # 信息<br>LC_PAPER=zh_CN.UTF-8        # 默认纸张尺寸方式<br>LC_NAME=zh_CN.UTF-8        # 姓名书写方式<br>LC_ADDRESS=zh_CN.UTF-8          # 地址书写方式<br>LC_TELEPHONE=zh_CN.UTF-8        # 电话号码书写方式<br>LC_MEASUREMENT=zh_CN.UTF-8      # 度量衡表达方式<br>LC_IDENTIFICATION=zh_CN.UTF-8   # 对 locale 自身包含信息概述<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">LC_ALL=zh_CN.UTF-8</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><p>LC_ALL、LC_* 和 LANG 优先级的关系：LC_ALL &gt; LC_* &gt; LANG</p></blockquote><h2 id="3-4-配置-hostname-和-hosts-文件"><a href="#3-4-配置-hostname-和-hosts-文件" class="headerlink" title="3.4 配置 hostname 和 hosts 文件"></a>3.4 配置 hostname 和 hosts 文件</h2><ol><li>配置 hostname 文件</li></ol><p>通过编辑 <code>/etc/hostname</code> 文件配置主机名，如果没有该文件则创建该文件。然后在该文件中按需写入主机名。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">例如创建名为 ArchLinux 的主机</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过 vim 编辑器编辑 hostname 文件</span><br>vim /etc/hostname<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">写入主机名</span><br>ArchLinux<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><ol start="2"><li>配置 hosts 文件</li></ol><p>通过编辑 <code>/etc/hosts</code> 文件编辑 hosts，如果没有该文件则创建该文件。然后在该文件中写入如下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span>  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过 vim 编辑器编辑 hosts 文件</span><br>vim /etc/hosts<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">写入如下内容</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">Standard host addresses</span><br>127.0.0.1localhost<br>::1      localhost<br><span class="hljs-meta prompt_"># </span><span class="language-bash">This host address</span><br>127.0.1.1            ArchLinux.localdomainArchLinux<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><h2 id="3-5-新建用户"><a href="#3-5-新建用户" class="headerlink" title="3.5 新建用户"></a>3.5 新建用户</h2><p>使用系统前端时，开机会有一个用户登陆界面，默认只有一个 root 用户，在使用 root 用户登陆之后可以添加一个新用户。</p><blockquote><p><strong>注</strong>：</p><p>在新建用户并重启系统之前一定要更改 root 用户的密码，具体操作命令为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash"><span class="hljs-comment"># 使用该命令修改密码</span></span><br><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">passwd root</span><br></code></pre></td></tr></table></figure><p>然后需要重复输入密码，修改成功会有提示。</p></blockquote><ol><li>添加新用户的具体操作如下：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加新用户</span><br>useradd -m -G wheel &lt;username&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">为新用户修改密码</span><br>passwd &lt;username&gt;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><p>上述命令中各个参数的含义：</p><ol><li><code>-m</code> ：创建新用户的同时创建其对应的家目录</li><li><code>-G</code> ：指定附加组（wheel 附加组可以进行 sudo 提权操作）</li><li><code>&lt;username&gt;</code> ：新建用户名，注意区分大小写</li></ol></blockquote><ol start="2"><li>修改 <code>/etc/sudoer</code> 配置文件</li></ol><p>访问 <code>/etc/sudoer</code> 并取消 <code># %wheel ALL=(ALL) ALL</code> 这一行注释。</p><blockquote><p><strong>注</strong>：</p><p><code>%wheel</code> 的百分号表示用户组前缀；第一个 <code>ALL</code> 表示任意主机名；第二个 <code>ALL</code> 表示任意用户名；第三个 <code>ALL</code> 表示可执行任意命令。</p></blockquote><h2 id="3-6-安装引导"><a href="#3-6-安装引导" class="headerlink" title="3.6 安装引导"></a>3.6 安装引导</h2><h3 id="3-6-1-平台驱动安装"><a href="#3-6-1-平台驱动安装" class="headerlink" title="3.6.1 平台驱动安装"></a>3.6.1 平台驱动安装</h3><p>针对 Intel 平台和 AMD 平台的 CPU 开机引导加载驱动程序会有所不同，因此要按需安装对应驱动程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看本机 CPU 型号</span><br>cat /proc/cpuinfo<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. Intel CPU 安装</span><br>pacman -S intel-ucode<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. AMD CPU 安装</span><br>pacman -S amd-ucode<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><h3 id="3-6-2-Grub-配置"><a href="#3-6-2-Grub-配置" class="headerlink" title="3.6.2 Grub 配置"></a>3.6.2 Grub 配置</h3><p>在配置 Grub 之前还应当安装对应的软件包，同样的 Grub 也是分不同的引导方式。</p><ol><li>安装 Grub 相关软件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. UEFI + GPT</span><br>pacman -S grub efibootmgr efivar os-prober<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. BIOS + MBR</span><br>pacman -S grub efivar os-prober<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><ol><li><code>os-prober</code> 的作用在于能发现 Windows 系统的引导</li><li>在最新版本的 Grub2 引导方式中，<code>os-prober</code> 默认被关闭，想要启用此功能需要在 <code>/etc/default/grub</code> 配置文件中将 <code># GRUB_DISABLE_OS_PROBER=false</code> 字段取消注释。</li></ol></blockquote><ol start="2"><li>配置 Grub 启动引导</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1. UEFI + GPT</span><br>grub-install --target=x86_64-efi --efi-directory=&lt;EFI Dir&gt; --bootloader-id=Arch --removable<br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;EFI Dir&gt; 通常情况下为 /boot 分区</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2. BIOS + MBR</span><br>grub-install --target=i386-pc &lt;Dir&gt; --removable --force<br><span class="hljs-meta prompt_"># </span><span class="language-bash">&lt;Dir&gt; 为指定的一个分区</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><ol start="3"><li>生成 Grub 引导配置文件</li></ol><p>这一步是通过下面指令实现的，这一配置文件的修改都是通过 <code>/etc/default/grub</code> 修改并 <code>grub-mkconfig</code> 生成到此配置文件的。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">grub-mkconfig -o /boot/grub/grub.cfg<br></code></pre></td></tr></table></figure><h2 id="3-7-重启系统"><a href="#3-7-重启系统" class="headerlink" title="3.7 重启系统"></a>3.7 重启系统</h2><p>至此 ArchLinux 的命令行安装方式到此结束。先退出 <code>arch-chroot</code> （exit 或者 quit 都可以），然后卸载挂载点。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">卸载引导分区</span><br>umount /dev/sdb1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">关闭交换分区</span><br>swapoff /dev/sdb4<br><span class="hljs-meta prompt_"># </span><span class="language-bash">卸载根分区</span><br>umount /dev/sdb5<br><span class="hljs-meta prompt_"># </span><span class="language-bash">挂载主目录分区</span><br>umount /dev/sdb6<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看需要分区列表确定需要挂载的分区</span><br>lsblk -T<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><p>在确认卸载挂载点完毕之后便可重新启动系统，注意重启屏幕点亮之前一定要拔掉 U 盘。</p><h1 id="四-GNOME-桌面环境安装"><a href="#四-GNOME-桌面环境安装" class="headerlink" title="四.GNOME 桌面环境安装"></a>四.GNOME 桌面环境安装</h1><h2 id="4-1-Xorg-服务安装"><a href="#4-1-Xorg-服务安装" class="headerlink" title="4.1 Xorg 服务安装"></a>4.1 Xorg 服务安装</h2><p>由于 GNOME 桌面环境默认使用了 Wayland 的显示服务器协议。Wayland 采用了 Xwayland 子协议以兼容 X 协议。由于 Wayland 现阶段的兼容性问题，笔者还是采用了更传统的基于 X 协议的 Xorg 服务。具体安装也非常简单，仅需如下命令安装 Xorg 服务器端程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S xorg-server<br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><p>Xorg 程序是对于 X11（也叫X Window 或 X）协议的实现</p></blockquote><p>想要正常使用 Xorg 服务，还需要对 <code>~/.xinitrc</code> 文件进行一些配置：</p><ol><li>如果是 GNOME on Xorg ，需要在上述文件中添加如下内容：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">export XDG_SESSION_TYPE=x11<br>export GDK_BACKEND=x11<br>exec gnome-session<br></code></pre></td></tr></table></figure><ol start="2"><li>如果是 GNOME Classic ，需要在上述文件中添加如下内容：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">export XDG_CURRENT_DESKTOP=GNOME-Classic:GNOME<br>export GNOME_SHELL_SESSION_MODE=classic<br>exec gnome-session<br></code></pre></td></tr></table></figure><h2 id="4-2-gnome-包安装"><a href="#4-2-gnome-包安装" class="headerlink" title="4.2 gnome 包安装"></a>4.2 gnome 包安装</h2><p>要想使用 GNOME 桌面环境，安装对应的软件包如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S gnome gnome-tweaks gnome-terminal dconf-editor<br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><ol><li><p>GDM 是包含在 gnome 基础包里面的</p></li><li><p>下面是在 gnome-extra 包中较常用到的包：</p><ul><li><a href="https://archlinux.org/packages/extra/any/gnome-tweaks/"> gnome-tweaks</a> gnome 主题相关配置</li><li><a href="https://archlinux.org/packages/extra/x86_64/gnome-terminal/"> gnome-terminal</a> gnome 自带终端</li><li><a href="https://archlinux.org/packages/extra/x86_64/dconf-editor/"> dconf-editor</a> dconf 系统配置的 GUI 界面</li></ul></li></ol></blockquote><p>为保证 GNOME 桌面环境正常使用，需要开机启动 GDM 服务。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">开机自启 GDM 服务</span><br>systemctl enable gdm.service<br><span class="hljs-meta prompt_"># </span><span class="language-bash">本次启动 GDM 服务</span><br>systemctl start gdm.service<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看 GDM 服务状态</span><br>systemctl status gdm.service<br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><p><a href="https://aur.archlinux.org/pkgbase/gdm-settings">gdm-settings</a> gdm 的部分设置 GUI 界面</p></blockquote>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Arch</tag>
      
      <tag>GNOME</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Manjaro/Linux使用常见问题</title>
    <link href="/2025/01/31/Manjaro%20%E4%BD%BF%E7%94%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
    <url>/2025/01/31/Manjaro%20%E4%BD%BF%E7%94%A8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="一-双系统时区问题"><a href="#一-双系统时区问题" class="headerlink" title="一.双系统时区问题"></a>一.双系统时区问题</h1><h2 id="1-1-问题描述"><a href="#1-1-问题描述" class="headerlink" title="1.1 问题描述"></a>1.1 问题描述</h2><p>当安装了 Windows 和 Manjaro 双系统后，发现出现了 Windows 系统时间比 Manjaro 系统时间慢 8 小时的情况。</p><h2 id="1-2-问题分析"><a href="#1-2-问题分析" class="headerlink" title="1.2 问题分析"></a>1.2 问题分析</h2><p>在电脑中会有两个时间，一个是硬件时间，一个是系统时间。</p><ol><li>硬件时间：这个时间信息存储在电脑主板中，因此没有夏令时以及时区等概念。</li><li>系统时间：这个时间信息由系统管理，通常是通过网络时间同步（Network Time Synchronization，NTS），有夏令时以及时区等概念。</li></ol><blockquote><p><strong>注</strong>：</p><p>系统时间提供了两种管理思路：</p><ul><li>localtime：本地时间，Windows 系统采用此种方法。</li><li>UTC：世界标准时间，在众多 Linux 系统中广泛使用。这种方法只需将 UTC 时间加减时区便得到本地时间。</li></ul></blockquote><p>Linux 认为硬件时间是 UTC 标准时间，Linux 时间同步后会把“正确”的时间做减 8 操作作为标准 UTC 标准时间写入主板。</p><p>Windows 系统会认为硬件时间就是本地时间，所以直接把主板中的时间信息拿来当做当前的时间。设置或同步时间后也会把“正确”时间写入主板。</p><p>这样操作就会出现双系统时间不同步的情况。</p><h2 id="1-3-解决方法"><a href="#1-3-解决方法" class="headerlink" title="1.3 解决方法"></a>1.3 解决方法</h2><p>解决的思路就是让 Manjaro 系统使用 localtime 或者让 Windows 系统使用 UTC 时间。具体操作是：</p><ol><li>在 Manjaro 系统中设置本地时间</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">使用timedatectl可以查询时间信息，通过如下方式设置 Manjaro 本地时间</span><br>sudo timedatectl set-local-rtc true<br></code></pre></td></tr></table></figure><ol start="2"><li>在 Windows 系统中使用 UTC 时间</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">以管理员身份使用运行</span><br>reg add &quot;HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\TimeZoneInformation&quot; /v RealTimeIsUniversal /d 1 /t REG_DWORD /f<br><span class="hljs-meta prompt_"># </span><span class="language-bash">使用以上方法无效或系统为64位：</span><br>reg add &quot;HKEY_LOCAL_MACHINE\System\CurrentControlSet\Control\TimeZoneInformation&quot; /v RealTimeIsUniversal /d 1 /t REG_QWORD /f<br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><p>本问题参照 ArchLinux Wiki 关于时间问题的处理：<a href="https://wiki.archlinux.org/title/System_time">ArchLinux Wiki —- Time</a></p></blockquote><h1 id="二-GitHub-443错误"><a href="#二-GitHub-443错误" class="headerlink" title="二.GitHub 443错误"></a>二.GitHub 443错误</h1><h2 id="2-1问题描述"><a href="#2-1问题描述" class="headerlink" title="2.1问题描述"></a>2.1问题描述</h2><p>当从Git远程仓库 pull、push 或者 clone 时会出现如下错误：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">Failed to connect to github.com port 443: Connection refused<br></code></pre></td></tr></table></figure><h2 id="2-2-解决方法"><a href="#2-2-解决方法" class="headerlink" title="2.2 解决方法"></a>2.2 解决方法</h2><h3 id="2-2-1-由代理引起"><a href="#2-2-1-由代理引起" class="headerlink" title="2.2.1 由代理引起"></a>2.2.1 由代理引起</h3><ol><li>若是由于<strong>代理</strong>引起的，则使用如下命令关闭代理：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git config --global --unset http.proxy<br>git config --global --unset https.proxy<br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><p>重新开启 git 全局代理的方法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">添加全局代理：<br>git config --global http.proxy<br>git config --global https.proxy<br></code></pre></td></tr></table></figure></blockquote><h3 id="2-2-2-由-DNS-解析异常导致"><a href="#2-2-2-由-DNS-解析异常导致" class="headerlink" title="2.2.2 由 DNS 解析异常导致"></a>2.2.2 由 DNS 解析异常导致</h3><p>若是由于 <strong>DNS 解析</strong>异常导致的，则使用如下方式解决：</p><ul><li>首先在 <a href="https://www.ipaddress.com/">ipaddress.com</a> 网站搜索获取 GitHub 域名对应的 IP 地址。</li></ul><blockquote><p><strong>注</strong>：</p><ol><li>修改hosts文件,就修改了IP 地址和域名之间的映射关系。修改 hosts 文件域名解析就会访问 hosts 文件中的 IP和域名的映射关系以访问指定网站。</li><li>如果想要更加完整的 GitHub DNS 解析列表可在 Gitee 上查询相关仓库并将其更新到本地的 Hosts 文件当中。</li></ol></blockquote><ul><li>然后将 IP 地址和域名的映射关系写入系统的 hosts 文件中。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">在 Windows 系统中修改如下路径的 hosts 文件</span><br>C:\Windows\System32\drivers\etc\hosts<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在 Linux 系统中修改 hosts 文件</span><br>sudo vim /etc/hosts<br></code></pre></td></tr></table></figure><h1 id="三-签名更新出错"><a href="#三-签名更新出错" class="headerlink" title="三.签名更新出错"></a>三.签名更新出错</h1><h2 id="3-1-问题描述"><a href="#3-1-问题描述" class="headerlink" title="3.1 问题描述"></a>3.1 问题描述</h2><p> 当 Manjaro 更新系统时，会出现如下签名失败的情况并导致软件更新失败</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">错误：archlinux-keyring: 来自 &quot;Christian Hesse &lt;eworm@archlinux.org&gt;&quot; 的签名是未知信任的<br>:: 文件 /var/cache/pacman/pkg/archlinux-keyring-20221220-1-any.pkg.tar.zst 已损坏 (无效或已损坏的软件包 (PGP 签名)).<br>打算删除吗？ [Y/n]<br></code></pre></td></tr></table></figure><h2 id="3-2-解决方法"><a href="#3-2-解决方法" class="headerlink" title="3.2 解决方法"></a>3.2 解决方法</h2><p>这儿可能会有两种情况出现</p><ol><li>第一种原因呢，是 <code>archlinux-keyring</code> 滚不动了。根本原因呢就是升级到了 <code>gnupg-2.1</code>，pacman 上游更新了密钥环的格式，这使得本地的主密钥无法签署其它密钥。。解决的思路是初始化 keyring 亦或者是将其更换为 <code>archlinuxcn-keyring</code>。本节参考的如下链接：<a href="https://www.archlinuxcn.org/gnupg-2-1-and-the-pacman-keyring/">GnuPG-2.1 与 pacman 密钥环</a></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1,移除旧的 keys</span><br>sudo rm -rf /etc/pacman.d/gnupg<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2,初始化 pacman 的keys</span><br>sudo pacman-key --init<br><span class="hljs-meta prompt_"># </span><span class="language-bash">3,加载签名的keys</span><br>sudo pacman-key --populate<br><span class="hljs-meta prompt_"># </span><span class="language-bash">4,刷新升级已经签名的keys,这一步可以选择跳过</span><br>sudo pacman-key --refresh-keys<br><span class="hljs-meta prompt_"># </span><span class="language-bash">5,清空并且下载新数据</span><br>sudo pacman -Sc<br><span class="hljs-meta prompt_"># </span><span class="language-bash">6,安装archlinuxcn-keyring</span><br>sudo pacman -S archlinuxcn-keyring<br></code></pre></td></tr></table></figure><p>然后再更新系统和软件，发现问题解决。</p><ol start="2"><li>第二种情况呢，是 archlinuxcn 社区源的 keyring 包 archlinuxcn-keyring 由 <code>farseerfc</code> 的 key 签署验证，而 Arch Linux 官方 keyring 中包含了 <code>farseerfc</code> 的 key 。解决思路呢就是使用如下命令在本地信任 <code>farseerfc</code> 的 key。本节参照的如下链接：<a href="https://www.archlinuxcn.org/archlinuxcn-keyring-manually-trust-farseerfc-key/">手动信任 farseerfc 的 key</a></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">此 key 已随 archlinux-keyring 安装在系统中，只是缺乏信任</span><br>sudo pacman-key --lsign-key &quot;farseerfc@archlinux.org&quot;<br></code></pre></td></tr></table></figure><p>然后再更新系统和软件，发现问题解决。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Manjaro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Manjaro的软件安装方式</title>
    <link href="/2025/01/31/Manjaro%20%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F/"/>
    <url>/2025/01/31/Manjaro%20%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>Linux 系统有着众多特点，而灵活性便是其中之一。而这一灵活性的具体体现就是软件的安装是可以通过多种方法途径来实现的。因此，掌握多种 Linux 系统上软件安装方法便是一个开发者以及爱好者的必备技能。本文以下部分将阐述笔者所了解掌握的几种 Linux 系统安装软件的方法。当然，这几种方法主要是 Arch 系发行版的 Linux 系统。</p><h1 id="一-通过-pacman-命令安装"><a href="#一-通过-pacman-命令安装" class="headerlink" title="一.通过 pacman 命令安装"></a>一.通过 pacman 命令安装</h1><p><code>pacman</code> 软件包管理器是 Arch Linux 的一大亮点。它将一个简单的 <code>二进制包格式</code>和易用的 <code>构建系统</code> 结合了起来。<code>pacman</code> 的目标是简化对软件包的管理，无论软件包是来自 <code>官方软件仓库</code> 还是 <code>用户自己创建</code>的软件包。</p><p>关于 <code>pacman</code> 命令的部分用法将在下面几节详细介绍。如果想查看更加完整的技术文档，可参考：<a href="https://man.archlinux.org/man/pacman.8">ArchWiki—Pacman（英文完整版）</a>  ， <a href="https://wiki.archlinuxcn.org/wiki/Pacman#%E5%AE%89%E8%A3%85%E8%BD%AF%E4%BB%B6%E5%8C%85">ArchWiki—Pacman（中文）</a>。</p><blockquote><p><strong>注</strong>：</p><p>pacman 软件包管理器拥有很强的管理能力。使用软件包而不是自己编译和安装程序有很多好处：</p><ul><li>轻松升级：pacman 会在更新可用时立即更新已安装的软件包</li><li>依赖检查：pacman 会为你处理依赖问题，只需要指明程序（名），<em>pacman</em> 就会将它和它所需的所有其他程序都一起安装。</li><li>干净卸载：pacman 持有软件包包含的所有文件的列表。这样一来，当你决定移除软件包时，不会无意留下任何文件。</li></ul></blockquote><h2 id="1-1-安装软件包"><a href="#1-1-安装软件包" class="headerlink" title="1.1 安装软件包"></a>1.1 安装软件包</h2><p>一个软件包就是一个归档包，其中包含：</p><ul><li>该软件所有（编译好的）文件，并按照每个文件的安装位置储存在一个与根目录结构相同的目录中；</li><li>该软件的元数据，如软件名称、版本和依赖等；</li><li>供 pacman 使用的其它描述性文件；</li><li>（可选）在安装、升级、卸载时执行的安装脚本。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载软件包但不安装</span><br>pacman -Sw &lt;包名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装「单个」或者「一系列」软件包（含依赖）</span><br>pacman -S &lt;包名&gt;# 安装单个软件包<br>pacman -S &lt;包名1 包名2 ...&gt; # 安装一系列软件包<br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过正则表达式安装「一系列」软件包</span><br>pacman -S $(pacman -Ssq 包正则表达式)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">存放在不同仓库的多版本软件需要在软件包前指定仓库名</span><br>pacman -S &lt;仓库名/包名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装多个相似名称的软件包，用花括号扩展，举例：</span><br>pacman -S plasma-&#123;desktop,mediacenter,nm&#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">多个相似名称的软件包可以多层扩展，举例：</span><br>pacman -S plasma-&#123;workspace&#123;,-wallpapers&#125;,pa&#125;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装包组，会提示选择安装包组中需要安装的包</span><br>pacman -S &lt;包组名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询安包组内的包含的具体软件名</span><br>pacman -Sg &lt;包组名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">从本地安装软件包（不从源中获取）</span><br>pacman -U /path/to/package/package_name-version.pkg.tar.zst<br><span class="hljs-meta prompt_"># </span><span class="language-bash">从远程安装软件包（从源或者指定链接中获取）</span><br>pacman -U http://www.example.com/repo/example.pkg.tar.zst<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将本地包保存至缓存</span><br>pacman -U file:///path/to/package/package_name-version.pkg.tar.zst<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><h2 id="1-2-删除软件包"><a href="#1-2-删除软件包" class="headerlink" title="1.2 删除软件包"></a>1.2 删除软件包</h2><p><code>pacman</code> 命令的删除指令如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除单个软件包</span><br>pacman -R &lt;包名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除指定软件包，并删除未被其他已安装软件包使用的依赖</span><br>pacman -Rs &lt;包名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-Rs命令在移除包含其他所需包的组时有时候会拒绝运行，可采用如下指令</span><br>pacman -Rsu &lt;包名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除软件包和依赖这个软件包的所有程序，「递归操作，谨慎使用」</span><br>pacman -Rsc &lt;包名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除被其他软件包依赖的软件包，但是不删除依赖这个软件包的其他软件包：</span><br>pacman -Rdd &lt;包名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><h2 id="1-3-查询包数据库"><a href="#1-3-查询包数据库" class="headerlink" title="1.3 查询包数据库"></a>1.3 查询包数据库</h2><p>在 <code>pacman</code> 中，可使用 <code>-Q</code> 参数查询本地软件包数据库， <code>-S</code> 查询同步数据库，以及 <code>-F</code>查询文件数据库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">显示软件包的依赖树，「这一命令依赖于 pacman-contrib 包」</span><br>pactree &lt;package_name&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br>pacman -Q --help#本地软件包数据库的帮助文档<br>pacman -S --help#同步数据库的帮助文档<br>pacman -F --help#文件数据库的帮助文档<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1.本地软件包数据库</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在本地软件包数据库中查询匹配「单个」或者「多个」字符串的软件包</span><br>pacman -Qs &lt;string&gt; # 匹配单个字符串<br>pacman -Qs &lt;string1 string2 ...&gt;# 匹配多个字符串<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在本地软件包数据库中查询指定软件包的详细信息</span><br>pacman -Qi &lt;package_name&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在本地软件包数据库中查询指定软件包所包含文件的列表</span><br>pacman -Ql &lt;package_name&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.同步数据库</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在同步数据库中查询匹配「单个」或者「多个」字符串的软件包</span><br>pacman -Ss &lt;string&gt; # 匹配单个字符串<br>pacman -Ss &lt;string1 string2 ...&gt;# 匹配多个字符串<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在同步数据库中获取指定软件的详细信息</span><br>pacman -Si &lt;package_name&gt;       <br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3.文件数据库</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在文件数据库中按文件名查找「单个」或者「一系列」文件</span><br>pacman -F &lt;string&gt; # 单个文件<br>pacman -F &lt;string1 string2 ...&gt;# 一系列文件<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询远程库中软件包包含的文件</span><br>pacman -Fl &lt;package_name&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><h2 id="1-4-清除包缓存"><a href="#1-4-清除包缓存" class="headerlink" title="1.4 清除包缓存"></a>1.4 清除包缓存</h2><p><code>pacman</code> 命令下载的软件包保存在 <code>/var/cache/pacman/pkg/</code> 路径中，并且它不会自动移除旧的和未安装版本的软件包。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">启用 和 启动 paccache.timer 每周删除不使用的包</span><br>paccache -r<br><span class="hljs-meta prompt_"># </span><span class="language-bash">设置保留最近几个版本的软件数量</span><br>paccache -rk1<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除目前没有安装的所有缓存的包，和没有被使用的同步数据库</span><br>pacman -Sc<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除缓存中的全部文件（两个c强制删除）</span><br>pacman -Scc<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><h2 id="1-5-其他命令"><a href="#1-5-其他命令" class="headerlink" title="1.5 其他命令"></a>1.5 其他命令</h2><p>除了上面几节介绍的命令之外，还有一些 <code>pacman</code> 相关的零碎指令如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">升级整个系统，y 是更新数据库，yy 是强制更新数据库，u 是升级软件</span><br>pacman -Syyu<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">升级系统时安装「单个」或者「一系列」软件包</span><br>pacman -Syu &lt;包名&gt;#「单个」软件包<br>pacman -Syu &lt;包名1 包名2 ...&gt; #「一系列」软件包<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><h1 id="二-通过-yay-命令安装"><a href="#二-通过-yay-命令安装" class="headerlink" title="二.通过 yay 命令安装"></a>二.通过 yay 命令安装</h1><p>yay 命令是一个 Arch Linux 系统的命令行软件。在使用此命令安装软件时需要确保在 <code>/etc/pacman.conf</code> 文件中正确配置了 Arch 源。yay 是 AUR 助手的其中一种，与其他的 AUR 助手的对比可以参考：<a href="https://wiki.archlinuxcn.org/wiki/AUR_%E5%8A%A9%E6%89%8B">ArchWiki—AUR 助手</a></p><p>使用 yay 这类 AUR 助手的好处是：</p><ol><li>自动解决软件<strong>包间依赖关系</strong>；</li><li>动态地<strong>搜索</strong>、<strong>编译</strong>和<strong>构建</strong>包；</li><li>安装与管理 AUR 中的包。</li></ol><blockquote><p><strong>注</strong>：</p><ol><li>要想使用 yay 命令行软件，需要确保安装了 <code>base-devel</code> 包和 <code>git</code> 包，然后再安装 yay 命令。如果没有安装，可参考如下命令安装：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">加入 `--needed` 参数不会重新安装已经安装的软件包</span><br>sudo pacman -S --needed base-devel git<br></code></pre></td></tr></table></figure><ol start="2"><li>值得注意的是， <code>yay</code> 命令可以从 AUR 上获取软件并安装，也可以从官方源获取软件包再安装。</li></ol></blockquote><p><code>yay</code> 使用与 <code>pacman</code> 相类似的命令结构。因此本节下面部分将展示 yay 的部分指令用法，更加详细的可参阅：<a href="https://wiki.archlinuxcn.org/wiki/Yay">ArchWiki—Yay</a>。</p><h2 id="2-1-安装软件包"><a href="#2-1-安装软件包" class="headerlink" title="2.1 安装软件包"></a>2.1 安装软件包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在 AUR 上搜索包名</span><br>yay &lt;AUR包名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">下载软件包但不安装</span><br>yay -G &lt;AUR包名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装「单个」或者「一系列」软件包（含依赖）</span><br>yay -S &lt;AUR包名&gt;       # 安装单个软件包<br>yay -S &lt;AUR包名1 AUR包名2 ...&gt;# 安装一系列软件包<br><span class="hljs-meta prompt_"># </span><span class="language-bash">通过正则表达式安装「一系列」软件包</span><br>yay -S $(pacman -Ssq AUR包正则表达式)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">存放在不同仓库的多版本软件需要在软件包前指定仓库名</span><br>yay -S &lt;仓库名/AUR包名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">安装包组，会提示选择安装包组中需要安装的包</span><br>yay -S &lt;包组名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询安装包组内包含的具体软件名</span><br>yay -Sg &lt;包组名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><h2 id="2-2-删除软件包"><a href="#2-2-删除软件包" class="headerlink" title="2.2 删除软件包"></a>2.2 删除软件包</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除软件包</span><br>yay -R &lt;AUR包名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除指定软件包，并删除未被其他已安装软件包使用的依赖</span><br>yay -Rs &lt;AUR包名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">-Rs命令在移除包含其他所需包的组时有时候会拒绝运行，可采用如下指令</span><br>yay -Rsu &lt;AUR包名&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除包及其依赖项</span><br>yay -Rns &lt;AUR包名&gt;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除软件包和依赖这个软件包的所有程序，「递归操作，谨慎使用」</span><br>yay -Rsc &lt;AUR包名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除被其他软件包依赖的软件包，但是不删除依赖这个软件包的其他软件包：</span><br>yay -Rdd &lt;AUR包名&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><h2 id="2-3-查询包数据库"><a href="#2-3-查询包数据库" class="headerlink" title="2.3 查询包数据库"></a>2.3 查询包数据库</h2><p>在 <code>yay</code> 中，可使用 <code>-Q</code> 参数查询本地软件包数据库， <code>-S</code> 查询同步数据库，以及 <code>-F</code>查询文件数据库。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">1.本地软件包数据库</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在本地软件包数据库中查询匹配「单个」或者「多个」字符串的软件包</span><br>yay -Qs &lt;string&gt;        # 匹配单个字符串<br>yay -Qs &lt;string1 string2 ...&gt;# 匹配多个字符串<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在本地软件包数据库中查询指定软件包的详细信息</span><br>yay -Qi &lt;package_name&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在本地软件包数据库中查询指定软件包所包含文件的列表</span><br>yay -Ql &lt;package_name&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.同步数据库</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在同步数据库中查询匹配「单个」或者「多个」字符串的软件包</span><br>yay -Ss &lt;string&gt; # 匹配单个字符串<br>yay -Ss &lt;string1 string2 ...&gt;# 匹配多个字符串<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在同步数据库中获取指定软件的详细信息</span><br>yay -Si &lt;package_name&gt;       <br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">3.文件数据库</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">在文件数据库中按文件名查找「单个」或者「一系列」文件</span><br>yay -F &lt;string&gt; # 单个文件<br>yay -F &lt;string1 string2 ...&gt;# 一系列文件<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查询远程库中软件包包含的文件</span><br>yay -Fl &lt;package_name&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><h2 id="2-4-清除包缓存"><a href="#2-4-清除包缓存" class="headerlink" title="2.4 清除包缓存"></a>2.4 清除包缓存</h2><p><code>yay</code> 常用的清除缓存指令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除目前没有安装的所有缓存的包，和没有被使用的同步数据库</span><br>yay -Sc<br><span class="hljs-meta prompt_"># </span><span class="language-bash">删除缓存中的全部文件（两个c强制删除）</span><br>yay -Scc<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><h2 id="2-5-其他命令"><a href="#2-5-其他命令" class="headerlink" title="2.5 其他命令"></a>2.5 其他命令</h2><p>除了上面几节介绍的命令之外，还有一些 <code>yay</code> 相关的零碎指令如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">其他命令</span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">升级整个系统，y 是更新数据库，yy 是强制更新数据库，u 是升级软件</span><br>yay -Syyu# 仅输入 yay 则等效于 yay -Syu<br><span class="hljs-meta prompt_"># </span><span class="language-bash">仅升级 AUR 包</span><br>yay -Sua<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span><br></code></pre></td></tr></table></figure><h2 id="2-6-常用指令汇总"><a href="#2-6-常用指令汇总" class="headerlink" title="2.6 常用指令汇总"></a>2.6 常用指令汇总</h2><p>更加详细的指令信息如下图所示：</p><table><thead><tr><th align="center">命令</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">yay</td><td align="center">升级系统，相当于 yay -Syu</td></tr><tr><td align="center">yay <Search Term></td><td align="center">显示包安装选择菜单</td></tr><tr><td align="center">yay -Bi <folder></td><td align="center">安装依赖并构建本地 PKGBUILD</td></tr><tr><td align="center">yay -G <AUR Package></td><td align="center">从 ABS 或 AUR 下载 PKGBUILD (yay v12.0以上版本)</td></tr><tr><td align="center">yay -Gp <AUR Package></td><td align="center">打印 ABS 或 AUR 的 PKGBUILD 到 stdout</td></tr><tr><td align="center">yay -Ps</td><td align="center">打印系统统计信息</td></tr><tr><td align="center">yay -Syu –devel</td><td align="center">执行系统升级，但同时检查开发包的更新</td></tr><tr><td align="center">yay -Syu –timeupdate</td><td align="center">执行系统升级并使用PKGBUILD修改时间（不是版本号）来确定更新</td></tr><tr><td align="center">yay -Wu <AUR Package Name></td><td align="center">取消对包的投票 (需要设置 AUR_USERNAME 和 AUR_PASSWORD 环境变量) (yay v11.3以上版本)</td></tr><tr><td align="center">yay -Wv <AUR Package Name></td><td align="center">投票支持包 (需要设置 AUR_USERNAME 和 AUR_PASSWORD 环境变量) (yay v11.3以上版本)</td></tr><tr><td align="center">yay -Y –combinedupgrade –save</td><td align="center">使组合升级成为默认模式</td></tr><tr><td align="center">yay -Y –gendb</td><td align="center">生成用于开发更新的开发包数据库</td></tr><tr><td align="center">yay -Yc</td><td align="center">清理不需要的依赖</td></tr></tbody></table><blockquote><p><strong>注</strong>：</p><p>如果方便，也可在命令行中键入 <code>yay --help</code> 或者是 <code>yay -h</code> 指令查看 yay 命令的用法。</p></blockquote><h1 id="三-通过-AUR-安装"><a href="#三-通过-AUR-安装" class="headerlink" title="三.通过 AUR 安装"></a>三.通过 AUR 安装</h1><p>AUR 全称 Archlinux User-community Repository，即 Archlinux 用户社区的软件库。具体的介绍可以参考：<a href="https://wiki.archlinuxcn.org/wiki/Arch_%E7%94%A8%E6%88%B7%E8%BD%AF%E4%BB%B6%E4%BB%93%E5%BA%93_(AUR)">ArchWiki—AUR</a> 。AUR 是为用户而建，并由用户主导的 Arch 软件仓库。AUR 中的软件包以软件包生成脚本（PKGBUILD）的形式提供，用户自己通过 makepkg 生成软件包，再由 pacman 安装软件包。</p><p>Archlinux 的灵魂是 PKGBUILD、 <a href="https://wiki.archlinuxcn.org/wiki/Arch_%E7%94%A8%E6%88%B7%E8%BD%AF%E4%BB%B6%E4%BB%93%E5%BA%93_(AUR)">AUR</a>  和 <a href="https://wiki.archlinuxcn.org/wiki/Arch_%E6%9E%84%E5%BB%BA%E7%B3%BB%E7%BB%9F">ABS</a>  ，在 AUR 仓库能查到的软件包，都可以使用上述的方法进行安装。为了演示这一方法的可行性，这里以 <code>WingIDE</code> 软件的安装为例演示安装流程：</p><ol><li>首先，去到 <a href="https://aur.archlinux.org/">AUR</a> 官方网站并在 <code>Package Search</code> 栏目搜索软件包（WingIDE）</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/3.1AUR%E5%AE%98%E7%BD%91.png" alt="AUR官方网站"  /></div><ol start="2"><li>搜索软件包会跳转到搜索结果页，在这一页面可能会有许多相关的软件，选择自己需要的软件点击查看详情即可</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/3.2.%E5%9C%A8AUR%E4%B8%AD%E6%90%9C%E7%B4%A2%E8%BD%AF%E4%BB%B6%E5%8C%85.png" alt="在AUR中搜索软件包"  /></div><ol start="3"><li>进入软件详情页会有许多具体信息，通过 AUR 社区安装软件需要复制对应软件的 <code>Git Clone URL</code></li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/3.3.AUR%E6%A3%80%E7%B4%A2%E8%BD%AF%E4%BB%B6%E7%9A%84%E8%AF%A6%E7%BB%86%E4%BF%A1%E6%81%AF.png" alt="检索软件包详细信息"  /></div><ol start="4"><li>获取到软件的 <code>Git Clone URL</code> 后在终端中输入 <code>git clone &lt;Git Clone URL&gt;</code> 将软件包克隆至本地</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/3.4.%E5%88%A9%E7%94%A8git%E5%85%8B%E9%9A%86%E8%87%B3%E6%9C%AC%E5%9C%B0.png" alt="git克隆软件包"  /></div><ol start="5"><li>紧接着，进入到克隆下来的软件包文件夹，使用 <code>makepkg -s</code> 指令构建软件包</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/3.5.%E6%9E%84%E5%BB%BA%E8%BD%AF%E4%BB%B6%E5%8C%85.png" alt="构建软件包"  /></div><ol start="6"><li>最后通过 <code>pacman</code> 命令的本地安装功能进行文件夹中的 <code>.pkg.tar.zst</code> 软件包安装</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/3.6.%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85.png" alt="本地安装"  /></div><p>至此，通过 AUR 安装软件的介绍到此结束。</p><blockquote><p><strong>注</strong>：</p><ol><li>如果仅使用 <code>makepkg</code> 指令，可能会因为依赖包问题而报错，因此最好是使用 <code>makepkg -s</code>。</li><li>使用 <code>makepkg -s</code>命令会构建好软件包，但是安装还需要调用 <code>pacman -U &lt;Packge Name&gt;</code> 指令进行本地安装，因此可以换做 <code>makepkg -si</code> 指令在构建完后自动安装软件包。</li></ol></blockquote><h1 id="四-通过转换-deb-包安装"><a href="#四-通过转换-deb-包安装" class="headerlink" title="四.通过转换 deb 包安装"></a>四.通过转换 deb 包安装</h1><p>AUR 上储备了相当数量的软件，在上面能获取到日常使用的大部分软件。它虽然很好用了，但是一些无法编译的包（闭源代码软件包），或是在 AUR 上生成报错的软件包则还是需要另外的途径编译构建新的包。此时便可以通过本文所述的这一粗糙的方法将 deb 包转换成 archlinux 包。</p><h2 id="4-1-debtap-软件部署"><a href="#4-1-debtap-软件部署" class="headerlink" title="4.1 debtap 软件部署"></a>4.1 debtap 软件部署</h2><h3 id="4-1-1-安装-debtap"><a href="#4-1-1-安装-debtap" class="headerlink" title="4.1.1 安装 debtap"></a>4.1.1 安装 debtap</h3><ol><li>想要在 Manjaro 系统上转换 deb 格式的包，需要的就是先安装 debtap 软件。可使用如下命令安装 debtap 软件：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S debtap<br></code></pre></td></tr></table></figure><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/4.1.%E5%AE%89%E8%A3%85debtap%E8%BD%AF%E4%BB%B6%EF%BC%88%E5%BC%80%E5%A7%8B%EF%BC%89.png" alt="安装debtap"  /></div><ol start="2"><li>在安装完 debtap 软件之后，这里相当建议更新一次 debtap 的源以创建或者更新 pkgfile 和 debtap 数据库。这里可以通过如下命令更新 debtap 的源：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo debtap -u<br></code></pre></td></tr></table></figure><p>示例结果如下图所示：</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/4.2.%E6%9B%B4%E6%96%B0debtap%E6%BA%90.png" alt="更新debtap源"  /></div><blockquote><p><strong>注</strong>：</p><p>这条指令在安装完 debtap 软件之后至少需要运行一次，否则调用 debtap 软件时可能会报错。</p></blockquote><h3 id="4-1-2-debtap-换源"><a href="#4-1-2-debtap-换源" class="headerlink" title="4.1.2 debtap 换源"></a>4.1.2 debtap 换源</h3><p>值得注意的是 debtap 默认的官方源在大陆地区访问很卡，因此需要给 debtap 更换本地的镜像源。换源的方式也很简单，那就是修改 <code> /usr/bin/debtap</code> 配置文件。修改配置文件可以通过如下两种方式进行：</p><ol><li>一种是利用 vim 命令访问该配置文件，然后更改文件中的这两项内容：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo vim /usr/bin/debtap<br><span class="hljs-meta prompt_"># </span><span class="language-bash">替换 http://ftp.debian.org/debian/dists 为 https://mirrors.ustc.edu.cn/debian/dists</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">替换 http://archive.ubuntu.com/ubuntu/dists 为 https://mirrors.ustc.edu.cn/ubuntu/dists/</span><br></code></pre></td></tr></table></figure><ol start="2"><li>另外一种便更加简单粗暴，就是在命令行中直接将指定信息写入该配置文件。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo sed -i &quot;s|http://ftp.debian.org/debian/dists|https://mirrors.ustc.edu.cn/debian/dists|g&quot; /usr/bin/debtap<br>sudo sed -i &quot;s|http://archive.ubuntu.com/ubuntu/dists|https://mirrors.ustc.edu.cn/ubuntu/dists|g&quot; /usr/bin/debtap<br></code></pre></td></tr></table></figure><h2 id="4-2-安装-deb-包格式的软件"><a href="#4-2-安装-deb-包格式的软件" class="headerlink" title="4.2 安装 deb 包格式的软件"></a>4.2 安装 deb 包格式的软件</h2><p>在如下的示例中笔者都以 Typora 软件安装参考。debtap 命令的使用很简单</p><h3 id="4-2-1-转换格式"><a href="#4-2-1-转换格式" class="headerlink" title="4.2.1 转换格式"></a>4.2.1 转换格式</h3><p>直接对下载的 deb 软件包使用 debtap 命令即可转换包格式</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">debtap &lt;Deb Package Name&gt;<br></code></pre></td></tr></table></figure><p>转换包格式的参考示例执行结果如下图所示：</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/4.3.%E8%BD%AC%E6%8D%A2Typora%E8%BD%AF%E4%BB%B6%E7%9A%84deb%E5%8C%85%E6%A0%BC%E5%BC%8F.png" alt="deb包格式转换"  /></div><p>在图中可以看到笔者有多个版本的 Typora 软件，这里转换格式的是 <code>1.8.9</code> 版本的 Typora 软件。同时上图也展示出出了转换后软件包格式类型为： <code>.pkg.tar.zst</code>。</p><blockquote><p><strong>注</strong>：</p><ol><li>在包转化的过程中，你不想回答任何问题，使用 <code>-q</code> 略过除了编辑元数据之外的所有问题。当然，也可使用 <code>-Q</code> 略过所有问题。命令的格式如下所示：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">略过除了编辑元数据之外的所有问题</span><br>debtap -q &lt;Deb Package Name&gt;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">略过所有问题</span><br>debtap -Q &lt;Deb Package Name&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li>如果想要查看 debtap 的帮助文档，可执行如下命令获取：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">debtap -h<br></code></pre></td></tr></table></figure><p>运行的参考示例如下图所示：</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/4.4.%E6%9F%A5%E7%9C%8Bdebtap%E5%91%BD%E4%BB%A4%E5%8F%82%E8%80%83%E6%96%87%E6%A1%A3.png" alt="查看debtap的帮助文档"  /></div></blockquote><h3 id="4-2-2-本地安装"><a href="#4-2-2-本地安装" class="headerlink" title="4.2.2 本地安装"></a>4.2.2 本地安装</h3><p>将 deb 包转换成 ArchLinux 系统格式的软件包后便可以本地安装了。可以通过如下命令安装</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -U &lt;Packge Name&gt;<br></code></pre></td></tr></table></figure><p>安装软件的参考示例执行结果如下图所示：</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/4.5.%E6%9C%AC%E5%9C%B0%E5%AE%89%E8%A3%85%E8%BD%AC%E6%8D%A2%E5%90%8E%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%8C%85.png" alt="本地安装软件包"  /></div><p>笔者之前已经安装过 Typora 软件，因此看到上面提示重新安装。至此，已成功本地安装转换后的软件包。</p><h1 id="五-通过-AppImage-包安装"><a href="#五-通过-AppImage-包安装" class="headerlink" title="五.通过 AppImage 包安装"></a>五.通过 AppImage 包安装</h1><p>这种方式是在打包程序时就将所需的库以及依赖通过打包到 AppImage 文件中再发布，此种方式的好处是这种安装包可以在任意发行版 Linux 系统中运行而无需另外安装应用。更具体内容可参照 <a href="https://appimage.org/">AppImage官网</a> 描述。</p><h2 id="5-1-技术特点"><a href="#5-1-技术特点" class="headerlink" title="5.1 技术特点"></a>5.1 技术特点</h2><ol><li><strong>简单</strong>：AppImage 核心思想即：<code>一个文件就是一个应用程序</code>，就是说每个 AppImage 文件都包含应用程序以及应用程序运行所需的所有文件。换言之，除了操作系统本身的基础组件，Appimage不需要依赖包即可运行</li><li><strong>可靠</strong>：AppImage 格式是<code>上游应用打包</code>的理想选择，这意味着可以直接从开发者那里获取软件，而不需要任何中间步骤。</li><li><strong>快速</strong>：AppImage应用可以直接下载并且运行，无需安装，并且不需要root权限。</li></ol><h2 id="5-2-命令行实现"><a href="#5-2-命令行实现" class="headerlink" title="5.2 命令行实现"></a>5.2 命令行实现</h2><p>运行 AppImage 文件非常简单，下载后，通过以下步骤即可运行程序：</p><ol><li>下载需要的 AppImage 软件到运行文件夹，例如：<code>/path/to/AppImage</code></li><li>打开当前发行版 Linux 系统终端（Terminal）</li><li>进入 AppImage 文件所在目录，例如：<code>cd /path/to/AppImage</code></li><li>给需要运行的 AppImage 文件赋予相应的权限，例如：<code>sudo chmod a+x my.AppImage</code></li><li>这样便可以运行 AppImage 软件了，例如：<code>./my.AppImage</code></li></ol><p>这里在代码行中做个汇总：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">进入文件目录</span><br>cd /path/to/AppImage<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看目录中文件</span><br>ls -l     <br><span class="hljs-meta prompt_"># </span><span class="language-bash">更改文件权限</span><br>sudo chmod a+x my.AppImage<br><span class="hljs-meta prompt_"># </span><span class="language-bash">运行程序</span><br>./my.AppImage<br></code></pre></td></tr></table></figure><p>笔者在本人系统中运行如下图所示：</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/5.1.%E9%80%9A%E8%BF%87%E5%91%BD%E4%BB%A4%E8%A1%8C%E8%BF%90%E8%A1%8CAppImage%E7%A8%8B%E5%BA%8F.png" alt="命令行安装AppImage软件"  /></div><h2 id="5-2-沙盒实现"><a href="#5-2-沙盒实现" class="headerlink" title="5.2 沙盒实现"></a>5.2 沙盒实现</h2><p>通过命令行操作可能很繁琐，那么可以通过诸如 AppImageLauncher 的沙盒程序来整合 AppImage 程序。下面将阐述利用沙盒程序整合 AppImage 文件的步骤：</p><ol><li>首先在当前发行版 Linux 系统中安装沙盒程序，笔者使用的是 AppImageLauncher 程序。</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S AppImageLauncher<br></code></pre></td></tr></table></figure><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/5.2.%E5%AE%89%E8%A3%85AppImageLauncher%E8%BD%AF%E4%BB%B6.png" alt="沙盒软件安装AppImage软件"  /></div><ol start="2"><li>然后下载需要运行的 AppImage 文件。</li><li>通过文件资源管理器进入 AppImage 所在目录，然后点击运行该 AppImage 文件。</li></ol><div style="text-align: center; margin: 35px;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E6%96%B9%E6%B3%95/5.3.%E5%8F%8C%E5%87%BB%E6%89%A7%E8%A1%8CAppImage%E8%BD%AF%E4%BB%B6.png" alt="双击安装AppImage软件"  /></div><p>至此，AppImageLauncher 就将 AppImage 文件整合到对应的目录统一管理。并且在整合的过程中在开始菜单自动生成了访问图标。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Manjaro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Manjaro及其常用软件安装配置</title>
    <link href="/2025/01/29/Manjaro%20%E5%8F%8A%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/"/>
    <url>/2025/01/29/Manjaro%20%E5%8F%8A%E5%B8%B8%E7%94%A8%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Manjaro 是一个 Arch Linux 的发行版本</p><p>来自 Manjaro 社区的官方介绍：</p><p>Manjaro is a versatile, free, and open-source Linux operating system designed with a strong focus on safeguarding user privacy and offering extensive control over hardware. This user-friendly OS is an excellent choice for those who seek a fresh computing experience, as it can be seamlessly installed on a diverse array of devices. With support for both x86-64 and ARM architectures, Manjaro stands as an ideal option for any device or computing environment. Furthermore, Manjaro provides an array of customization options and a rich selection of applications, all while prioritizing security and privacy features. To cater to a wide audience.</p><h1 id="一-Manjaro安装"><a href="#一-Manjaro安装" class="headerlink" title="一.Manjaro安装"></a>一.Manjaro安装</h1><h2 id="1-1-安装包及工具获取"><a href="#1-1-安装包及工具获取" class="headerlink" title="1.1 安装包及工具获取"></a>1.1 安装包及工具获取</h2><h3 id="1-1-1-安装包获取"><a href="#1-1-1-安装包获取" class="headerlink" title="1.1.1 安装包获取"></a>1.1.1 安装包获取</h3><p>访问<a href="https://manjaro.org/">Manjaro官网</a>的下载页可以看到，Manjaro 官方提供了三种桌面版本的 Manjaro 系统：Plasma、Xfce以及 GNOME。</p><ol><li>Plasma：是一种 KDE 桌面环境，其功能完善，自定义程度较高。对于硬件资源消耗较大</li><li>Xfce：是一种轻量级的桌面环境，其界面美观、对用户友好，它是由 C 语言编写而成，依赖于 GTK+。对资源消耗较小</li><li>GNOME：是一款GNU的桌面环境，Ubuntu 系统的默认桌面环境。对于资源消耗适中。</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5/Manjaro%E4%B8%8B%E8%BD%BD%E9%A1%B5.png" alt="Manjaro下载页"  /></div><p>笔者曾使用 Ubuntu 系统，比较喜欢GNOME的桌面环境，因此笔者选择 GNOME Desktop 版本。</p><h3 id="1-1-2-写入工具选择"><a href="#1-1-2-写入工具选择" class="headerlink" title="1.1.2 写入工具选择"></a>1.1.2 写入工具选择</h3><p>当前市面上有许多U盘烧录工具，如Rufus、USBWriter、Ventoy等。</p><h2 id="1-2-写入盘制作"><a href="#1-2-写入盘制作" class="headerlink" title="1.2 写入盘制作"></a>1.2 写入盘制作</h2><p>笔者采用 Rufus 软件写入文件到U盘。打开 Rufus 软件之后默认会选择U盘，然后在引导类型选择栏选择需要安装的 Manjaro 镜像文件。然后点击开始按钮进行烧录。</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%87%86%E5%A4%87%E9%98%B6%E6%AE%B5/Rusfus%E5%86%99%E5%85%A5%E8%BD%AF%E4%BB%B6.png" alt="Rufus写入软件"  /></div><h2 id="1-3-安装步骤"><a href="#1-3-安装步骤" class="headerlink" title="1.3 安装步骤"></a>1.3 安装步骤</h2><p>将写入系统镜像的U盘插到待安装系统的电脑上。开机选择U盘启动项开始安装</p><h3 id="1-3-1-语言及驱动选择"><a href="#1-3-1-语言及驱动选择" class="headerlink" title="1.3.1 语言及驱动选择"></a>1.3.1 语言及驱动选择</h3><p>进入驱动选择界面，将地区（tz 项）选择为中国上海，语言（lang 项）设置为中文，然后驱动选择<Boot with proprietary drivers> 项并回车。</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/1.%E9%80%89%E6%8B%A9%E9%A9%B1%E5%8A%A8%E7%B1%BB%E5%9E%8B.png" alt="选择驱动类型"  /></div><blockquote><p><strong>注</strong>：</p><p>图中第一项 <Boot with open source drivers> 为开源驱动。</p><p>图中第二项 <Boot with proprietary drivers> 为闭源驱动。</p><p>由于笔者是英伟达显卡，故选择第二项进行安装。</p></blockquote><h3 id="1-3-2-载入内核与系统界面"><a href="#1-3-2-载入内核与系统界面" class="headerlink" title="1.3.2 载入内核与系统界面"></a>1.3.2 载入内核与系统界面</h3><ul><li>回车安装之后会载入内核界面</li></ul><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/2.%E5%8A%A0%E8%BD%BD%E5%86%85%E6%A0%B8%E7%95%8C%E9%9D%A2.png" alt="载入内核界面"  /></div><ul><li>成功之后便会显示系统 Logo 界面</li></ul><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/3.%E7%B3%BB%E7%BB%9FLogo%E7%95%8C%E9%9D%A2.png" alt="系统Logo界面"  /></div><h3 id="1-3-3-系统欢迎页"><a href="#1-3-3-系统欢迎页" class="headerlink" title="1.3.3 系统欢迎页"></a>1.3.3 系统欢迎页</h3><p>进入系统欢迎页。将语言选择为 <code>简体中文</code>，然后点击启动安装程序按钮开始安装。</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/4.%E7%B3%BB%E7%BB%9F%E6%AC%A2%E8%BF%8E%E9%A1%B5.png" alt="系统欢迎页"  /></div><h3 id="1-3-4-进入系统安装页"><a href="#1-3-4-进入系统安装页" class="headerlink" title="1.3.4 进入系统安装页"></a>1.3.4 进入系统安装页</h3><p>进入系统安装页，点击下一步正式开始安装</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/5.%E8%BF%9B%E5%85%A5%E5%AE%89%E8%A3%85%E7%A8%8B%E5%BA%8F.png" alt="进入系统安装页"  /></div><h3 id="1-3-5-地区及键盘布局"><a href="#1-3-5-地区及键盘布局" class="headerlink" title="1.3.5 地区及键盘布局"></a>1.3.5 地区及键盘布局</h3><ul><li>在系统安装页将地区设置为 <code>亚洲/上海</code>，然后点击下一步。</li></ul><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/6.%E9%80%89%E6%8B%A9%E5%9C%B0%E5%8C%BA.png" alt="地区选择"  /></div><ul><li>键盘布局选择默认布局，然后点击下一步。</li></ul><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/7.%E9%80%89%E6%8B%A9%E9%94%AE%E7%9B%98%E5%B8%83%E5%B1%80.png" alt="键盘方式选择"  /></div><h3 id="1-3-6-系统分区"><a href="#1-3-6-系统分区" class="headerlink" title="1.3.6 系统分区"></a>1.3.6 系统分区</h3><p>这一步非常关键，分区不正确将影响系统安装。此时出现两个选项，我们选择手动分区，然后点击下一步。</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/8.0.%E9%80%89%E6%8B%A9%E5%88%86%E5%8C%BA%E6%96%B9%E5%BC%8F.png" alt="分区方式选择"  /></div><p>进入到分区具体流程，笔者的分区如下表所述进行：</p><table><thead><tr><th align="center">大小</th><th align="center">文件系统</th><th align="center">挂载点</th><th align="center">标记</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">20GiB</td><td align="center">ext4</td><td align="center">&#x2F;</td><td align="center">root</td><td align="center">根目录，用于存放系统文件</td></tr><tr><td align="center">512MiB</td><td align="center">ext4</td><td align="center">&#x2F;boot</td><td align="center">boot或者bios-grub</td><td align="center">引导分区，系统启动相关</td></tr><tr><td align="center">4096MiB</td><td align="center">linuxswap</td><td align="center">无挂载点</td><td align="center">swap</td><td align="center">交换分区，一般与内存大小相同</td></tr><tr><td align="center">10Gib</td><td align="center">ext4</td><td align="center">&#x2F;var</td><td align="center">无标记</td><td align="center">存储变量</td></tr><tr><td align="center">The Rest</td><td align="center">ext4</td><td align="center">&#x2F;home</td><td align="center">无标记</td><td align="center">家目录，用于存放用户数据</td></tr></tbody></table><blockquote><p><strong>注</strong>：几个分区的具体介绍</p><ol><li>&#x2F; 分区，大小通常为15-20GiB。根分区是最重要而且必需的，需要最先挂载,因为包括 &#x2F;usr 目录，根据安装的软件数量，会产生非常明显的增长。</li><li>&#x2F;boot 分区，大小通常为512MiB。引导分区包含内核、ramdisk 镜像以及 bootloader 配置文件和bootloader stage。它也可以存放内核在执行用户态程序之前所使用的其他数据。&#x2F;boot 在日常系统运行中并不需要，只在启动和内核升级（包括重建initial ramdisk）的时候用到。如果使用软RAID0（条带化）系统的话，必须有一个独立的 &#x2F;boot 分区。不使用 UEFI 时，引导分区大小建议为 200 MiB，使用 UEFI 时，需要至少 512 MiB 空间。</li><li>linuxswap 分区，大小通常为内存的大小。</li><li>&#x2F;home 分区，将&#x2F;home目录独立使得&#x2F;分区可以单独重新划分，但是请注意你可以在 &#x2F;home 没有独立分区的情况下你仍然可以在不修改 &#x2F;home 目录内容的情况下重装 Arch —— 删除其他顶级目录，然后执行pacstrap。不能与使用其他发行版的用户共享同一个 home 目录，因为不同的发行版可能使用不兼容的软件版本和补丁。可以共享媒体目录，或至少使用 &#x2F;home 分区下的不同 home 目录。分区大小跟着存储的内容而定。</li><li>&#x2F;var 分区，存储变量数据例如 spool 目录和文件，管理和登录数据,它通常被用作缓存或者日志记录，因此读写频繁。将它独立出来可以避免由于大量日志写入造成的磁盘空间耗尽等问题。</li><li>除了其他数据以外，还包括 ABS 树和 pacman 缓存。保留缓存的包提供了包降级的能力，因此非常有用。也正因为这样，&#x2F;var 的大小会随着时间推移而增长。尤其是 pacman 缓存将会随着新软件的安装、系统的升级而增长。在磁盘空间不足的时候，可以安全的清理这个目录。&#x2F;var 分配 8-12 GB 对于桌面系统来说是比较合适的取值，具体取值取决于安装的软件数量。</li></ol></blockquote><ol><li>根目录（&#x2F;）</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/8.1.%E6%A0%B9%E5%88%86%E5%8C%BA%E9%85%8D%E7%BD%AE.png" alt="根分区配置"  /></div><ol start="2"><li>引导分区（&#x2F;boot或者&#x2F;boot&#x2F;efi）</li></ol><ul><li>当进行单系统（Manjaro）安装时，直接挂载 &#x2F;boot 引导分区</li></ul><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/8.2.boot%E5%88%86%E5%8C%BA%E9%85%8D%E7%BD%AE.png" alt="单系统安装Boot分区配置"  /></div><ul><li>当进行双系统（Windows+Manjaro）安装时，则需要将 &#x2F;boot&#x2F;efi 挂载到 Windows 的 ESP 引导分区上。注意配置 ESP 分区的时候选择保留分区而别格式化分区。</li></ul><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/%E5%88%86%E5%8C%BA%E7%9A%84%E7%89%B9%E4%BE%8B/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E6%8C%82%E8%BD%BD%E6%96%B9%E6%A1%881.png" alt="双系统安装Boot分区配置"  /></div><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/%E5%88%86%E5%8C%BA%E7%9A%84%E7%89%B9%E4%BE%8B/%E5%8F%8C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC%E6%8C%82%E8%BD%BD%E6%96%B9%E6%A1%882.png" alt="双系统安装Boot分区配置"  /></div><blockquote><p><strong>注</strong>：</p><p>手动挂载&#x2F;boot&#x2F;efi分区的方法可以参考如下文章：<a href="https://blog.csdn.net/qq_44639125/article/details/125707257?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170654013516800213030099%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170654013516800213030099&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-4-125707257-null-null.142%5Ev99%5Epc_search_result_base4&utm_term=Manjaro%E5%AE%89%E8%A3%85%E5%88%86%E5%8C%BA&spm=1018.2226.3001.4187">manjaro 手动挂载&#x2F;boot&#x2F;efi分区</a></p></blockquote><ol start="3"><li>交换分区（linuxswap）</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/8.3.swap%E5%88%86%E5%8C%BA%E9%85%8D%E7%BD%AE.png" alt="交换分区配置"  /></div><ol start="4"><li>家目录（&#x2F;home）</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/8.4.home%E5%88%86%E5%8C%BA%E9%85%8D%E7%BD%AE%EF%BC%88%E5%89%A9%E4%B8%8B%E5%85%A8%E9%83%A8%EF%BC%89.png" alt="home分区配置"  /></div><ol start="5"><li>最终生成的分区方案</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/8.5.%E6%9C%80%E7%BB%88%E5%88%86%E5%8C%BA%E6%96%B9%E6%A1%88.png" alt="最终分区方案"  /></div><h3 id="1-3-7-用户名及密码设置"><a href="#1-3-7-用户名及密码设置" class="headerlink" title="1.3.7 用户名及密码设置"></a>1.3.7 用户名及密码设置</h3><p>在系统安装页的用户名界面输入自己的登录用户名并设置它对应的用户密码。如果嫌用户密码和管理员密码分别设置很麻烦就勾选 <code>&lt;为管理员账号使用同样的密码&gt;</code>。然后点击下一步。</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/9.%E8%AE%BE%E7%BD%AE%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%90%8D%E5%AD%97%E5%8F%8A%E5%AF%86%E7%A0%81.png" alt="用户名及密码"  /></div><h3 id="1-3-8-Office套件"><a href="#1-3-8-Office套件" class="headerlink" title="1.3.8 Office套件"></a>1.3.8 Office套件</h3><p>在系统安装页，Manjaro 提供了多种 Office 套件以供选择，笔者选择的是 LibreOffice。如果这几种都不喜欢可以跳过自行安装 WPS 。</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/10.%E9%80%89%E6%8B%A9office%E5%8A%9E%E5%85%AC%E5%A5%97%E4%BB%B6.png" alt="Office套件选择"  /></div><h3 id="1-3-9-开始系统安装"><a href="#1-3-9-开始系统安装" class="headerlink" title="1.3.9 开始系统安装"></a>1.3.9 开始系统安装</h3><ul><li>Office 套件选择完毕后点击下一步便开始系统安装，此时会生成一个系统安装的摘要，显示之后点击安装。</li></ul><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/11.%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E6%91%98%E8%A6%81.png" alt="系统安装摘要"  /></div><ul><li>此时会弹出一个消息框，选择现在安装继续进行</li></ul><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/12.%E5%AE%89%E8%A3%85%E6%8F%90%E7%A4%BA.png" alt="安装提示"  /></div><ul><li>系统开始安装，点击进度条右边的小红点可以查看系统安装详细信息</li></ul><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/13.%E7%B3%BB%E7%BB%9F%E5%AE%89%E8%A3%85%E7%95%8C%E9%9D%A2.png" alt="开始系统安装"  /></div><ul><li>系统安装完毕，勾选现在重启然后重启系统便可以正常使用了。</li></ul><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E5%AE%89%E8%A3%85%E9%98%B6%E6%AE%B5/14.%E5%AE%89%E8%A3%85%E7%BB%93%E6%9D%9F.png" alt="系统安装完毕"  /></div><h1 id="二-系统换源"><a href="#二-系统换源" class="headerlink" title="二.系统换源"></a>二.系统换源</h1><p>为了保证 Manjaro 系统下载软件的流畅性，通常需要将软件源更改为国内高校或者阿里腾讯等互联网大厂的软件镜像源。以下部分将介绍镜像源配置流程。</p><h2 id="2-1-获取源列表并更换官方源"><a href="#2-1-获取源列表并更换官方源" class="headerlink" title="2.1 获取源列表并更换官方源"></a>2.1 获取源列表并更换官方源</h2><p>获取方式可以通过命令行方式选取镜像源或者直接更改配置文件</p><h3 id="2-1-1-方式一：通过命令行"><a href="#2-1-1-方式一：通过命令行" class="headerlink" title="2.1.1 方式一：通过命令行"></a>2.1.1 方式一：通过命令行</h3><ol><li>执行如下命令出现镜像源复选框：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman-mirrors -c China -i -m rank<br></code></pre></td></tr></table></figure><ol start="2"><li>在弹出的复选框中选择自己所需的镜像源并点击确认生效。</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E6%9B%B4%E6%96%B0%E6%BA%90/1.%E6%89%A7%E8%A1%8C%E5%91%BD%E4%BB%A4.png" alt="选择镜像源"  /></div><ol start="3"><li>镜像源生效之后会将配置写入到 &#96;&#96;&#x2F;etc&#x2F;pacman.d&#x2F;mirrorlist&#96; 文件当中。</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E6%9B%B4%E6%96%B0%E6%BA%90/2.%E9%80%89%E6%8B%A9%E5%B9%B6%E7%A1%AE%E5%AE%9A%E9%95%9C%E5%83%8F%E6%BA%90.png" alt="镜像源生效"  /></div>4. 最后执行如下命令更新软件与系统<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -Syy<br></code></pre></td></tr></table></figure><h3 id="2-1-2-方式二：通过配置文件"><a href="#2-1-2-方式二：通过配置文件" class="headerlink" title="2.1.2 方式二：通过配置文件"></a>2.1.2 方式二：通过配置文件</h3><ol><li>首先打开配置文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">打开镜像配置文件</span><br>nano /etc/pacman.d/mirrorlist<br></code></pre></td></tr></table></figure><ol start="2"><li>找到 Server 关键字，并在这一区域附近添加需要的镜像站链接</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">添加开源镜像站链接</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">中国科学技术大学</span><br>Server = https://mirrors.ustc.edu.cn/manjaro/stable/$repo/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重庆邮电大学</span><br>Server = https://mirrors.cqupt.edu.cn/manjaro/stable/$repo/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重庆大学</span><br>Server = https://mirrors.cqu.edu.cn/manjaro/stable/$repo/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">南方科技大学</span><br>Server = https://mirrors.sustech.edu.cn/manjaro/stable/$repo/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">北京外国语大学</span><br>Server = https://mirrors.bfsu.edu.cn/manjaro/stable/$repo/$arch<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">华为镜像站</span><br>Server = https://mirrors.huaweicloud.com/manjaro/stable/$repo/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">阿里云镜像站</span><br>Server = https://mirrors.aliyun.com/manjaro/stable/$repo/$arch<br></code></pre></td></tr></table></figure><ol start="3"><li>最后执行如下命令更新软件与系统</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -Syy<br></code></pre></td></tr></table></figure><h2 id="2-2-Arch-Linux-CN-源更换"><a href="#2-2-Arch-Linux-CN-源更换" class="headerlink" title="2.2 Arch Linux CN 源更换"></a>2.2 Arch Linux CN 源更换</h2><p>在更换 <code>archlinuxcn</code> 源时将 <code>arch4edu</code> 的源也更换一下。</p><ol><li>使用 gedit 程序命令访问配置文件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo gedit /etc/pacman.conf<br></code></pre></td></tr></table></figure><ol start="2"><li>然后在文件末尾添加如下内容并保存</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs shell">[archlinuxcn]<br>SigLevel = TrustedOnly<br><span class="hljs-meta prompt_"># </span><span class="language-bash">中国科学技术大学</span><br>Server = https://mirrors.ustc.edu.cn/archlinuxcn/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重庆邮电大学</span><br>Server = https://mirrors.cqupt.edu.cn/archlinuxcn/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">重庆大学</span><br>Server = https://mirrors.cqu.edu.cn/archlinuxcn/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">南方科技大学</span><br>Server = https://mirrors.sustech.edu.cn/archlinuxcn/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">华中科技大学</span><br>Server = https://mirrors.hust.edu.cn/archlinuxcn/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">北京外国语大学</span><br>Server = https://mirrors.bfsu.edu.cn/archlinuxcn/$arch<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">阿里源</span><br>Server = https://mirrors.aliyun.com/archlinuxcn/$arch<br><span class="hljs-meta prompt_"># </span><span class="language-bash">163源</span><br>Server = http://mirrors.163.com/archlinux-cn/$arch<br><br><br>[arch4edu]<br>SigLevel = Optional TrustAll<br><span class="hljs-meta prompt_"># </span><span class="language-bash">阿里edu源</span><br>Server = https://mirrors.aliyun.com/arch4edu/$arch<br></code></pre></td></tr></table></figure><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E6%9B%B4%E6%96%B0%E6%BA%90/4.%E5%8A%A0%E5%85%A5archlinuxcn%E5%92%8Carch4edu%E6%BA%90.png" alt="更换archlinuxcn和arch4edu源"  /></div>3. 最后执行如下命令更新软件与系统<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -Syyu<br></code></pre></td></tr></table></figure><h1 id="三-常用软件安装"><a href="#三-常用软件安装" class="headerlink" title="三.常用软件安装"></a>三.常用软件安装</h1><h2 id="3-1-输入法安装"><a href="#3-1-输入法安装" class="headerlink" title="3.1 输入法安装"></a>3.1 输入法安装</h2><p>笔者在 Windows 系统上多年都是使用的搜狗输入法。但是由于 Qt 版本的更新，搜狗官方并未在 Linux 下推出新架构的搜狗拼音输入法，因此笔者选择安装 fcitx5 输入法并配置相应的环境。当然，本节也会提供 Fcitx 框架下搜狗输入法的安装。</p><blockquote><p><strong>注</strong>：</p><ul><li><p>两种输入法安装的步骤都是：框架+具体输入法的形式进行</p></li><li><p>Fcitx 和 Fcitx5 两种框架都提供基本的输入法</p></li></ul></blockquote><h3 id="3-1-1-Fcitx5-输入法安装"><a href="#3-1-1-Fcitx5-输入法安装" class="headerlink" title="3.1.1 Fcitx5 输入法安装"></a>3.1.1 Fcitx5 输入法安装</h3><p>Fcitx5 是一个输入法框架，它具有轻量级内核，并通过 addon 提供额外的语言支持。Fcitx5 接替 Fcitx 。</p><ol><li>Fcitx5 依赖安装</li></ol><p>安装 Fcitx5 输入法首先需要下载 fcitx5 的依赖包。通过如下命令安装这些依赖包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span>  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">由于之前装过 Fcitx ，所以需先卸载</span><br>sudo pacman -Rs $(pacman -Qsq fcitx)<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">Fcitx5 本体</span><br>sudo pacman -S fcitx5 <br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">集成了[fctxi5]、[fctxi5-configtool]、[fctxi5-gtk]、[fctxi5-qt]</span><br>sudo pacman -S fcitx5-im<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">Fcitx5 配置工具</span><br>sudo pacman -S fcitx5-configtool  <br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">对 Qt 程序软件的支持</span><br>sudo pacman -S fcitx5-qt# 集成 Qt5 和 Qt6 依赖库<br>sudo pacman -S fcitx5-qt4# 单独集成 Qt4 依赖库<br>sudo pacman -S fcitx5-qt5-git# 单独集成 Qt5 依赖库<br>sudo pacman -S fcitx5-qt6-git# 单独集成 Qt6 依赖库<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">Fcitx5 对于 GTK 程序的支持</span><br>sudo pacman -S fcitx5-gtk<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">Fcitx5 对于中文相关的 addon，例如拼音、双拼和五笔</span><br>sudo pacman -S fcitx5-chinese-addons<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">Fcitx5 的第三方主题库</span><br>sudo pacman -S fcitx5-material-color<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">Fcitx5 对 KDE 桌面环境的支持</span><br>sudo pacman -S kcm-fcitx5<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span> <br><span class="hljs-meta prompt_"># </span><span class="language-bash">Fcitx5 对日期时间的支持</span><br>sudo pacman -S fcitx5-lua<br><span class="hljs-meta prompt_"># </span><span class="language-bash">------------------------------------------------------------------------------ <span class="hljs-comment">#</span></span> <br></code></pre></td></tr></table></figure><p>通常想要运行 Fcitx5 的输入法环境只需要安装 fcitx5-im 即可，如果有更多定制化操作可视情况而定。</p><ol start="2"><li>Fcitx5 环境配置</li></ol><p>访问 <code>/etc/environment</code> 文件并将如下内容追加到文件末尾：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">GTK_IM_MODULE=fcitx5<br>QT_IM_MODULE=fcitx5<br>XMODIFIERS=@im=fcitx5<br>SDL_IM_MODULE=fcitx5<br>INPUT_METHOD=fcitx5<br>GLFW_IM_MODULE=fcitx<br></code></pre></td></tr></table></figure><p>然后注销登陆重启输入法或者重启系统即可，如果想要添加词库，可运行 <code>Fcitx5</code> 配置软件对拼音输入法进行配置。</p><h3 id="3-1-2-Fcitx-输入法安装"><a href="#3-1-2-Fcitx-输入法安装" class="headerlink" title="3.1.2 Fcitx 输入法安装"></a>3.1.2 Fcitx 输入法安装</h3><ul><li>安装搜狗输入法首先需要下载 <code>Fcitx</code> 的依赖包。通过如下命令安装这些依赖包：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S fcitx fcitx-configtool fcitx-gtk2 fcitx-gtk3 fcitx-qt5 fcitx-qt6<br></code></pre></td></tr></table></figure><ul><li>然后访问 ~&#x2F;.xprofile 文件并在末尾追加如下内容：</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">export GTK_IM_MODULE=fcitx<br>export QT_IM_MODULE=fcitx<br>export XMODIFIERS=&quot;@im=fcitx&quot;<br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><p>本文是对 ~&#x2F;.xprofile 文件进行的操作，也可以对 &#x2F;etc&#x2F;environment 文件进行上述相同的操作。如果不进行环境的配置，那么重启之后不能正常切换输入法，也就不能输入中文。</p><p>下面对几个环境变量配置文件进行简单介绍：</p><ul><li><p>profile: 每次终端登录时读取</p></li><li><p>bashrc: 每次终端登录时读取。</p></li><li><p>xinitrc: 每次startx启动Xwindows服务时读取</p></li><li><p>xprofile: 每次使用gdm、lightdm等图形登录管理器时读取。</p></li><li><p>environment：在所有用户登陆时都有效。</p></li></ul></blockquote><h3 id="3-1-3-搜狗输入法安装"><a href="#3-1-3-搜狗输入法安装" class="headerlink" title="3.1.3 搜狗输入法安装"></a>3.1.3 搜狗输入法安装</h3><p>AUR 提供了 fcitx-sogoupinyin 和 fcitx5-sogoupinyin 两个版本的输入法，笔者采用的是 fcitx-sogoupinyin 这一版本。下面正式开始搜狗输入法安装：</p><ul><li>然后通过从 <a href="https://aur.archlinux.org/packages?O=0&SeB=nd&K=sogou&outdated=&SB=p&SO=d&PP=50&submit=Go">AUR</a> 上给拉取软件包 git 链接到本地</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone &lt;Target Source Address&gt;<br></code></pre></td></tr></table></figure><ul><li>然后进入项目文件夹直接开始构建安装软件包</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd fcitx-sogoupinyin<br>makepkg -si<br></code></pre></td></tr></table></figure><p>此时会出现如下图所示的错误：</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/%E6%90%9C%E7%8B%97%E6%8B%BC%E9%9F%B3%E5%AE%89%E8%A3%85.png" alt="搜狗拼音安装"  /></div><p>这一错误会导致需要安装的 deb 包下载失败，从而导致整个安装过程的失败。为了避免此错误，笔者采用的方式是从 <a href="https://shurufa.sogou.com/">搜狗拼音输入法官网</a> 下载 deb 包放到此项目文件夹中，然后使用 PKGBUILD 文件构建安装软件包。不出意外的话，搜狗拼音输入法就安装完毕了。</p><ul><li>最后重启 Manjaro 系统，然后在 Fcitx 配置软件中将搜狗拼音输入法添加为第二输入法。这样就可以正常使用了。</li></ul><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Fcitx%E9%85%8D%E7%BD%AE%E6%90%9C%E7%8B%97%E6%8B%BC%E9%9F%B3%E8%BE%93%E5%85%A5%E6%B3%95.png" alt="Fcitx配置搜狗输入法"  /></div><h3 id="3-1-4-搜狗输入法安装导致问题"><a href="#3-1-4-搜狗输入法安装导致问题" class="headerlink" title="3.1.4 搜狗输入法安装导致问题"></a>3.1.4 搜狗输入法安装导致问题</h3><p>笔者安装了搜狗输入法进而导致了系统关机以及系统重启时会 <code>user@1000.service</code> 服务关闭异常。而将搜狗输入法卸载之后一切恢复到正常。</p><p>解决此问题的思路：</p><ol><li>启用 <code>debug-shell.sevice</code> 服务</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl enable debug-shell.service<br></code></pre></td></tr></table></figure><ol start="2"><li>关机出现问题时使用 <code>Alt+F9</code> 进入 shell 调试命令行</li><li>使用 systemctl status 命令查看正在运行的服务</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl list-unit-files --type=service | grep enabled<br></code></pre></td></tr></table></figure><p>此时发现了 <code>user@1000.service</code> 仍在运行</p><ol start="4"><li>使用 systemctl status 命令继续查看 <a href="mailto:&#x75;&#x73;&#101;&#x72;&#64;&#x31;&#x30;&#x30;&#x30;&#46;&#115;&#101;&#x72;&#118;&#x69;&#99;&#101;">&#x75;&#x73;&#101;&#x72;&#64;&#x31;&#x30;&#x30;&#x30;&#46;&#115;&#101;&#x72;&#118;&#x69;&#99;&#101;</a> 服务</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo systemctl status user@1000.service<br></code></pre></td></tr></table></figure><p>此时便定位到了 <code>user@1000.service</code> 服务下的 sogoupinyin -service 子服务仍然在运行。</p><h2 id="3-2-回滚工具安装"><a href="#3-2-回滚工具安装" class="headerlink" title="3.2 回滚工具安装"></a>3.2 回滚工具安装</h2><p>使用如下命令可以安装回滚工具（TimeShift）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S timeshift<br></code></pre></td></tr></table></figure><h2 id="3-3-Chrome-浏览器安装"><a href="#3-3-Chrome-浏览器安装" class="headerlink" title="3.3 Chrome 浏览器安装"></a>3.3 Chrome 浏览器安装</h2><p>使用如下命令可以安装谷歌浏览器（google-chrome）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -S google-chrome<br></code></pre></td></tr></table></figure><h2 id="3-4-Clash-软件安装"><a href="#3-4-Clash-软件安装" class="headerlink" title="3.4 Clash 软件安装"></a>3.4 Clash 软件安装</h2><h3 id="3-4-1-Clash-for-Windows"><a href="#3-4-1-Clash-for-Windows" class="headerlink" title="3.4.1 Clash for Windows"></a>3.4.1 Clash for Windows</h3><p><strong>来自官网的介绍</strong>：Clash for Windows 是代理工具 Clash 在 Windows 系统的唯一图形客户端，同时还支持Windows、Linux、macOS 三大系统，功能强大且支持多种代理协议，如 Shadowsocks(SS)、ShadowsocksR(SSR)、Socks、Snell、V2Ray、Trojan 等代理协议。由于不知名原因，Clash for Windows 的作者已在 Github 上删库跑路，最终版本停在了 0.20.39 版本。</p><ol><li><p>首先下载 Clash for Windows 软件的 deb 软件包。在 Github 上有许多备份包可供下载，这里不再赘述。</p></li><li><p>然后通过 <code>debtap</code> 命令将 Clash for Windows 软件的 deb 包转换包格式。详细如下截图所示：</p></li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Clash%E8%BD%AF%E4%BB%B6%E8%BD%AC%E5%8C%85.png" alt="Clash转包"  /></div><ol start="3"><li>打包完成后会生成一个 <code>.pkg.tar.zst</code> 的软件包，然后通过 <code>pacman</code> 命令进行本地安装</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">sudo pacman -U &lt;Packge Name&gt;<br></code></pre></td></tr></table></figure><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Clash%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85.png" alt="Clash本地安装"  /></div><ol start="4"><li>想要正常使用，还需要设置系统网络代理，下图展示的是笔者的代理参数：</li></ol><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Manjaro%20Install/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/Clash%E7%B3%BB%E7%BB%9F%E4%BB%A3%E7%90%86.png" alt="设置系统网络代理"  /></div><blockquote><p><strong>注</strong>：</p><ol><li><p>这里的端口对应的是软件 UI 界面上 Port 栏目的端口号。</p></li><li><p>想正常科学上网还需要相应的订阅节点，网上有很多免费节点可用， 这里便不再展开。</p></li><li><p>如果设置了开机自动启动 <code>Clash for Windows</code> 而不想在桌面显示，可以在软件设置中开启 <code>静默启动（Silent Start）</code> 选项。</p></li></ol></blockquote><p>至此，Clash for Windows 的 Manjaro 版本便安装完毕。</p><h3 id="3-4-2-Clash-Verge"><a href="#3-4-2-Clash-Verge" class="headerlink" title="3.4.2 Clash Verge"></a>3.4.2 Clash Verge</h3><p>除了使用 Clash for Windows 之外，你还可以选择使用基于 <code>Tauri</code> 的 Clash Verge 软件。具体的安装可采用如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S clash-verge-rev-bin<br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><p>装完打不开前端面板，疑似N卡最新闭源驱动不支持 webkit 硬件渲染。解决的办法是在 <code>/etc/environment</code> 配置文件中添加环境变量: <code>WEBKIT_DISABLE_COMPOSITING_MODE=1</code>。</p></blockquote><h2 id="3-5-QQ-安装"><a href="#3-5-QQ-安装" class="headerlink" title="3.5 QQ 安装"></a>3.5 QQ 安装</h2><p>近年来，随着国产 Linux 发行版的兴起。QQ 也顺应时代通过 QQNT（Electron）技术对原先的腾讯QQ进行改造并至今发布多个版本。可以通过以下命令进行安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S linuxqq<br></code></pre></td></tr></table></figure><h2 id="3-6-微信安装"><a href="#3-6-微信安装" class="headerlink" title="3.6 微信安装"></a>3.6 微信安装</h2><p>近期，腾讯公司推出了运行在国产 Linux 发行版系统上的 Universal 版微信。此版本一经推出，受到广大 Linux 用户及开发者的关注，AUR 上的大佬通过打包将这一安装包发布在 AUR 仓库。笔者也第一时间去安装体验了这一版本。具体安装如下指令所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S wechat-universal-bwrap<br></code></pre></td></tr></table></figure><h2 id="3-7-腾讯会议安装"><a href="#3-7-腾讯会议安装" class="headerlink" title="3.7 腾讯会议安装"></a>3.7 腾讯会议安装</h2><p>腾讯会议可在官网下载各种架构的 Linux 版本，下载 deb 包自行打包也可以，当然也可以在 AUR 上获取相应的软件安装包。笔者习惯在 AUR 上获取软件，具体命令如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S wemeet-bin<br></code></pre></td></tr></table></figure><h2 id="3-8-QQ音乐安装"><a href="#3-8-QQ音乐安装" class="headerlink" title="3.8 QQ音乐安装"></a>3.8 QQ音乐安装</h2><p>在 AUR 社区可以看到 @<a href="https://aur.archlinux.org/account/Hill-98">Hill-98</a> 大佬有两个版本的 QQ音乐软件包。</p><ul><li><p>1.1.5-8 版本对应的名称为：<a href="https://aur.archlinux.org/packages/qqmusic-electron">qqmusic-electron</a></p></li><li><p>1.1.5-1 版本对应的名称为：<a href="https://aur.archlinux.org/packages/qqmusic-bin">qqmusic-bin</a></p></li></ul><p>在这里，笔者使用了更高版本的 qqmusic-electron ，具体安装参照如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S qqmusic-electron <br></code></pre></td></tr></table></figure><h2 id="3-9-顶部栏隐藏"><a href="#3-9-顶部栏隐藏" class="headerlink" title="3.9 顶部栏隐藏"></a>3.9 顶部栏隐藏</h2><p>此插件的功能是当应用最大化时能自动隐藏顶部栏，此软件通过 yay 安装即可。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S gnome-shell-extension-hidetopbar-git<br></code></pre></td></tr></table></figure><h2 id="3-10-WPS-Office-套件安装"><a href="#3-10-WPS-Office-套件安装" class="headerlink" title="3.10 WPS Office 套件安装"></a>3.10 WPS Office 套件安装</h2><p>使用如下命令即可安装 WPS 套件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">WPS软件本体（国际版）</span><br>yay -S wps-office<br><span class="hljs-meta prompt_"># </span><span class="language-bash">WPS的中文语言包</span><br>yay -S wps-office-mui-zh-cn<br><span class="hljs-meta prompt_"># </span><span class="language-bash">WPS的符号依赖包</span><br>yay -S ttf-wps-fonts<br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><ol><li><p>开始安装会报错，需要先安装文件 base-devel 库文件</p></li><li><p>安装完毕后依然无法使用wps pdf软件。需安装 libtiff5 库文件</p></li><li><p>更多问题可参考 <a href="https://wiki.archlinuxcn.org/wiki/WPS_Office">WPS Office Wiki</a></p></li></ol></blockquote><h2 id="3-11-GitHub-Desktop-安装"><a href="#3-11-GitHub-Desktop-安装" class="headerlink" title="3.11 GitHub Desktop 安装"></a>3.11 GitHub Desktop 安装</h2><p>Github Desktop 在 AUR 上有相应的包，这里可以通过如下命令安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">AUR上有许多版本，这里选用的是中文版</span><br>yay -S github-desktop-zh-bin<br><span class="hljs-meta prompt_"># </span><span class="language-bash">如果使用原生的英文版，可用如下指令安装</span><br>yay -S github-desktop-bin<br></code></pre></td></tr></table></figure><h2 id="3-12-笔记软件"><a href="#3-12-笔记软件" class="headerlink" title="3.12 笔记软件"></a>3.12 笔记软件</h2><p>由于 <code>Notepad++</code> 并不支持众多 Linux 系统，所以可以使用 <code>Notepadqq</code> 、 <code>NotepadNext</code>  或者是 <code>Notepad--</code> 软件平替。当然，如果需要书写 Markdown 格式笔记更加流畅的体验，可以安装 <code>Typora</code> 软件。</p><ol><li><code>Notepadqq</code> 软件安装：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S notepadqq<br></code></pre></td></tr></table></figure><ol start="2"><li><code>NotepadNext</code> 软件安装：</li></ol><p>本软件在 AUR 中暂时没有收录，且无 deb 包提供，仅提供了 AppImage 格式的软件包，因此笔者的此软件就是通过 AppImage 包安装的。这里附上此软件的 AppImage 软件包链接：<a href="https://github.com/dail8859/NotepadNext">NotepadNext</a></p><ol start="3"><li><code>Notepad--</code> 软件安装：</li></ol><p>此软件是对于 <code>Notepad++</code> 的国产软件替代，笔者也相当推荐使用此软件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">此处有三个 `-`</span><br>yay -S notepad---bin<br></code></pre></td></tr></table></figure><ol start="3"><li><code>Typora</code> 软件安装：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">yay -S typora<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Manjaro</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Manjaro桌面快捷方式创建</title>
    <link href="/2025/01/23/Manjaro%20%E6%A1%8C%E9%9D%A2%E5%9B%BE%E6%A0%87%E5%88%9B%E5%BB%BA/"/>
    <url>/2025/01/23/Manjaro%20%E6%A1%8C%E9%9D%A2%E5%9B%BE%E6%A0%87%E5%88%9B%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在 Manjaro 系统日常使用中，有的软件点击率和使用率更高，因此这就需要使用更方便的访问方式，而桌面图标就能满足这一需求。在 Windows 系统中可直接将可执行程序（EXE程序）以创建快捷链接的方式实现桌面访问，而 Linux 系统需要自己创建 desktop 文件并修改相应键值对来达到桌面访问的目的。本文以下部分将阐述具体的实现方式。</p><h1 id="一-了解-desktop-文件"><a href="#一-了解-desktop-文件" class="headerlink" title="一.了解 desktop 文件"></a>一.了解 desktop 文件</h1><p>为了描述如何启动特定程序、如何在菜单中显示等功能，采用配置文件的方式写入相关信息可大大简化维护的时间成本。 <code>Desktop Entry</code> 配置文件就是在这样的背景下应运而生的，像诸如 <code>KDE</code> 、 <code>GNOME</code> 等桌面环境都采用了这一方式。</p><h2 id="1-1-编写说明"><a href="#1-1-编写说明" class="headerlink" title="1.1 编写说明"></a>1.1 编写说明</h2><p>desktop 文件有诸多语法规则和编写相关的配置操作。部分细节如下所示，更加完整的规则可参阅文档： <a href="https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html#recognized-keys">Desktop Entry Specification</a> </p><ol><li><p>Desktop Entry 文件采用 UTF-8 编码。</p></li><li><p>Desktop Entry 文件命名采用 <code>.desktop</code> 后缀</p></li><li><p>使用 <code>#</code> 号书写备注信息</p></li><li><p>此文件所有内容采用 <code>键值对</code> 格式书写</p></li><li><p>关键字可以选择进行本地化显示，具体的细则如下表：</p></li></ol><table><thead><tr><th align="center">LC_MESSAGES Value</th><th align="center">可选值</th></tr></thead><tbody><tr><td align="center">lang_COUNTRY@MODIFIER</td><td align="center">lang_COUNTRY@MODIFIER，lang_COUNTRY，lang@MODIFIER，lang，默认值</td></tr><tr><td align="center">lang_COUNTRY</td><td align="center">lang_COUNTRY，lang，默认值</td></tr><tr><td align="center">lang@MODIFIER</td><td align="center">lang@MODIFIER，lang，默认值</td></tr><tr><td align="center">lang</td><td align="center">lang，默认值</td></tr></tbody></table><p>具体书写方式为</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">`[ ]` 内的内容为可选项，非必须</span><br>key[LC_MESSAGES Value]=value<br></code></pre></td></tr></table></figure><h2 id="1-2-编写规则"><a href="#1-2-编写规则" class="headerlink" title="1.2 编写规则"></a>1.2 编写规则</h2><p>要想创建桌面图标，首先需要了解桌面项的编写方式，具体可参考文档： <a href="https://specifications.freedesktop.org/desktop-entry-spec/desktop-entry-spec-latest.html#recognized-keys">Desktop Entry Specification Version 1.5</a> 。</p><p>此文件的最重要内容是键值对，关键字的选取尤为关键，每个桌面项<strong>必须</strong>具有一个<code>Type</code>关键字和一个<code>Name</code>关键字，其他项定义应用程序菜单中的外观（<strong>非必须</strong>）。下面是此版本关键字的摘要表格。</p><table><thead><tr><th align="center">序号</th><th align="center">关键字</th><th align="center">值类型</th><th align="center">是否必须</th><th align="center">应用类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">1</td><td align="center">Type</td><td align="center">string</td><td align="center">必须</td><td align="center">&#x2F;</td><td align="center">类型</td></tr><tr><td align="center">2</td><td align="center">Version</td><td align="center">string</td><td align="center">非必须</td><td align="center">Type 1-3</td><td align="center">版本</td></tr><tr><td align="center">3</td><td align="center">Name</td><td align="center">localestring</td><td align="center">必须</td><td align="center">Type 1-3</td><td align="center">名称</td></tr><tr><td align="center">4</td><td align="center">GenericName</td><td align="center">localestring</td><td align="center">非必须</td><td align="center">Type 1-3</td><td align="center">通用名</td></tr><tr><td align="center">5</td><td align="center">NoDisplay</td><td align="center">boolean</td><td align="center">非必须</td><td align="center">Type 1-3</td><td align="center">不显示</td></tr><tr><td align="center">6</td><td align="center">Comment</td><td align="center">localestring</td><td align="center">非必须</td><td align="center">Type 1-3</td><td align="center">备注信息</td></tr><tr><td align="center">7</td><td align="center">Icon</td><td align="center">iconstring</td><td align="center">非必须</td><td align="center">Type 1-3</td><td align="center">图标</td></tr><tr><td align="center">8</td><td align="center">Hidden</td><td align="center">boolean</td><td align="center">非必须</td><td align="center">Type 1-3</td><td align="center">隐藏项</td></tr><tr><td align="center">9</td><td align="center">OnlyShowIn，NotShowIn</td><td align="center">string(s)</td><td align="center">非必须</td><td align="center">Type 1-3</td><td align="center">显示项</td></tr><tr><td align="center">10</td><td align="center">DBusActivatable</td><td align="center">boolean</td><td align="center">非必须</td><td align="center">&#x2F;</td><td align="center">D-Bus 选项</td></tr><tr><td align="center">11</td><td align="center">TryExec</td><td align="center">string</td><td align="center">非必须</td><td align="center">Type 1</td><td align="center">尝试执行</td></tr><tr><td align="center">12</td><td align="center">Exec</td><td align="center">string</td><td align="center">非必须</td><td align="center">Type 1</td><td align="center">执行</td></tr><tr><td align="center">13</td><td align="center">Path</td><td align="center">string</td><td align="center">非必须</td><td align="center">Type 1</td><td align="center">路径</td></tr><tr><td align="center">14</td><td align="center">Terminal</td><td align="center">boolean</td><td align="center">非必须</td><td align="center">Type 1</td><td align="center">终端</td></tr><tr><td align="center">15</td><td align="center">Actions</td><td align="center">string(s)</td><td align="center">非必须</td><td align="center">Type 1</td><td align="center">行为</td></tr><tr><td align="center">16</td><td align="center">MimeType</td><td align="center">string(s)</td><td align="center">非必须</td><td align="center">Type 1</td><td align="center">MIME 类型</td></tr><tr><td align="center">17</td><td align="center">Categories</td><td align="center">string(s)</td><td align="center">非必须</td><td align="center">Type 1</td><td align="center">类型</td></tr><tr><td align="center">18</td><td align="center">Implements</td><td align="center">string(s)</td><td align="center">非必须</td><td align="center">&#x2F;</td><td align="center">执行</td></tr><tr><td align="center">19</td><td align="center">Keywords</td><td align="center">localestring(s)</td><td align="center">非必须</td><td align="center">Type 1</td><td align="center">关键词</td></tr><tr><td align="center">20</td><td align="center">StartupNotify</td><td align="center">boolean</td><td align="center">非必须</td><td align="center">Type 1</td><td align="center">-</td></tr><tr><td align="center">21</td><td align="center">StartupWMClass</td><td align="center">string</td><td align="center">非必须</td><td align="center">Type 1</td><td align="center">-</td></tr><tr><td align="center">22</td><td align="center">URL</td><td align="center">string</td><td align="center">必须</td><td align="center">Type 2</td><td align="center">链接</td></tr><tr><td align="center">23</td><td align="center">PrefersNonDefaultGPU</td><td align="center">boolean</td><td align="center">非必须</td><td align="center">Type 1</td><td align="center">默认显卡</td></tr><tr><td align="center">24</td><td align="center">SingleMainWindow</td><td align="center">boolean</td><td align="center">非必须</td><td align="center">Type 1</td><td align="center">单窗口</td></tr></tbody></table><blockquote><p><strong>注</strong>：</p><ol><li><code>string</code>  类型可以是包含 ASCII 码中除控制符外的所有字符。</li><li><code>localestring</code> 类型是用户可见的字符类型，通常采用 UTF-8 编码。</li><li><code>iconstring</code>  与 <code>localestring</code> 类型大体上一致，只是用户不可见。同样采用 UTF-8 编码。</li><li><code>boolean</code>为布尔类型</li></ol></blockquote><h3 id="1-2-1-关键字详细说明"><a href="#1-2-1-关键字详细说明" class="headerlink" title="1.2.1 关键字详细说明"></a>1.2.1 关键字详细说明</h3><p>对表格的详细说明如下：</p><ol><li><p>Type<code> 关键字</code> ：指定 <code>Desktop Entry</code> 的类型。在 Version 1.5 规范中定义了三种类型：&#96; </p><ol><li><p>Type1 ： <code>Application</code></p></li><li><p>Type2 ： <code>Link</code></p></li><li><p>Type3 ： <code>Directory</code></p></li></ol></li><li><p><code>Version</code> 关键字：指定<code>Desktop Entry</code> 的版本号。</p></li><li><p><code>Name</code> 关键字：指定应用程序的名称。</p></li><li><p><code>GenericName</code> 关键字：指定应用程序的通用名。</p></li><li><p><code>NoDisplay</code>  关键字：这个关键字的意思是：“此应用已存在，不在开始菜单显示”。</p></li><li><p><code>Comment</code>  关键字：对于 <code>Name</code> 和 <code>GenericName</code> 关键字的简短解释说明。</p></li><li><p><code>Icon</code>  关键字：指定此应用程序在应用程序浏览器或是在文件浏览器中所显示的图标。一般以绝对路径形式提供。</p></li><li><p><code>Hidden</code>  关键字：此项对已删除的应用或者已卸载仍存在的文件适用。</p></li><li><p><code>OnlyShowIn，NotShowIn</code>  关键字：指定（只显示&#x2F;不显示）在某个桌面环境上。这一字段可对应多个数值。</p></li><li><p><code>DBusActivatable</code>  关键字：D-Bus 消息管理机制的支持。默认值为 false 。此项为 true 值时会默认调用 D-Bus 而忽略掉 Exec 关键字去执行该应用程序。</p></li><li><p><code>TryExec</code>  关键字：用以确定一个可执行文件是否已实际安装的路径</p></li><li><p><code>Exec</code>  关键字：指定可执行程序（可带参数）  ，这一关键字在 <code>DBusActivatable</code> 字段为 false 时生效。这一字段必须存在，以实现兼容性。此关键字的具体介绍可看 <strong>1.2.2 节</strong> 。</p></li><li><p><code>Path</code>  关键字：指定程序运行的 <code>bin</code> 目录。</p></li><li><p><code>Terminal</code>  关键字：确定应用程序的运行是否依赖终端窗口。</p></li><li><p><code>Actions</code>  关键字：标识应用程序行为，这一字段能告诉应用程序执行更具体的操作（一种行为代表一种调用此程序的方式），通俗讲就是此应用程序的鼠标右键功能选项和程序附加应用程序功能。指定的每种行为需要在文件当中新开一个 Group Header。 此关键字的具体介绍可看 <strong>1.2.3 节</strong> 。</p></li><li><p><code>MimeType</code>  关键字：此字段用于指定此应用程序支持的 <code>MIME类型</code> （全称 Multipurpose Internet Mail Extensions，是一种用于定义文档、文件或字节流的性质和格式的标准）。</p></li><li><p><code>Categories</code>  关键字：此字段指定该 <code>Desktop Entry</code> 在开始菜单中显示的类别，可指定多个数值，但默认第一个数值。更加详细的菜单项可查看技术文档：<a href="https://specifications.freedesktop.org/menu-spec/latest/apa.html#main-category-registry">Desktop Menu Specification</a> 。此关键字的具体介绍可看 <strong>1.2.4 节</strong> 。</p></li><li><p><code>Implements</code>  关键字：此字段用于指定 <code>D-Bus</code> 一个或者更多接口名。这一关键字需要 <code>DBusActivatable</code> 字段为 true 时生效。</p></li><li><p><code>Keywords</code>  关键字：指定此字段可以在开始菜单更方便地搜索到此应用。可以指定多个字符串来描述此应用。当然，此字段不应当与 <code>Name</code> 字段和 <code>GenericName</code> 字段重复。</p></li><li><p><code>StartupNotify</code>  关键字：更加完整的协议内容可查看技术文档： <a href="http://www.freedesktop.org/Standards/startup-notification-spec">Startup Notification Protocol Specification</a> 。</p></li><li><p><code>StartupWMClass</code>  关键字：更加完整的协议内容可查看技术文档： <a href="http://www.freedesktop.org/Standards/startup-notification-spec">Startup Notification Protocol Specification</a> 。</p></li><li><p><code>URL</code>  关键字：当 <code>Type</code> 类型为 <code>Link</code> 时此关键字段是必须的，具体功能时指定具体的链接</p></li><li><p><code>PrefersNonDefaultGPU</code>  关键字：这是一个提示性关键字，不是强制性的。如果此字段为 true ，则该程序默认运行在独立显卡上；如果为 false ，则该程序运行在集成显卡上。</p></li><li><p><code>SingleMainWindow</code>  关键字：这是一个提示性关键字，不是强制性的。用于指定是否单窗口运行，如果为 true ，应用只单窗口运行；如果为 flase ，则可多开窗口。</p></li></ol><h3 id="1-2-2-Exec-关键字（第-12-项）"><a href="#1-2-2-Exec-关键字（第-12-项）" class="headerlink" title="1.2.2 Exec 关键字（第 12 项）"></a>1.2.2 Exec 关键字（第 12 项）</h3><p>此关键字用于指定一个或多个参数的可执行程序。指定该可执行程序的方式可以是：<strong>绝对路径</strong>或<strong>此可执行程序的名称</strong>。如果未提供此项，则会在 path 环境变量中去查找可执行文件。</p><p><code>Field Code</code> 码的作用：</p><ol><li><code>%f</code> ： 传递<strong>单本地文件</strong>给本 Desktop Entry 文件。</li><li><code>%F</code> ： 传递<strong>多本地文件</strong>给本 Desktop Entry 文件。</li><li><code>%u</code> ： 传递<strong>单个 URL 或者单个本地路径</strong>给本 Desktop Entry 文件。</li><li><code>%U</code> ： 传递<strong>多个 URL 或者多个本地路径</strong>给本 Desktop Entry 文件。</li><li><code>%i</code> ： 将 Icon 关键字扩展为两个参数。如果 Icon 关键字为空或无 Icon 关键字，则不应扩展为任何参数。</li><li><code>%c</code> ： 此文件中 Name 关键字所列出应用程序的翻译名称。</li><li><code>%k</code> ： 传入位置可以是 URI 或者本地文件名。如果不知道位置，则为空。</li></ol><blockquote><p><strong>注</strong>：</p><ol><li>此 Field Code 码只能从上述前四个中选取一个。这七个 Field Code 码不能在双引号中。</li><li>Field Code 是其他程序调用此 Desktop Entry 文件时传入的参数。</li></ol></blockquote><h3 id="1-2-3-Actions-关键字（第-15-项）"><a href="#1-2-3-Actions-关键字（第-15-项）" class="headerlink" title="1.2.3 Actions 关键字（第 15 项）"></a>1.2.3 Actions 关键字（第 15 项）</h3><p>一个 <code>Desktop Entry</code> 文件可以有一个或多个 <code>Actions</code> 。一个 Action 就对应一种调用此程序的方式。这一方式可以用来创建 Quicklists 或者 Jumplists 。</p><blockquote><p><strong>注</strong>：</p><p>一个 Desktop 文件的组成：</p><ol><li>一个 <code>[Desktop Entry]</code> 组成。必须。</li><li>若干个 <code>[Desktop Aciton &lt;Action Identifier&gt;]</code> 组成。非必须。</li></ol></blockquote><p>指定的每种 Action 都需要在文件当中新开一个 Group Header 。其关键字必须包含 <code>Name</code> ，而 <code>Icon</code> 和 <code>Exec</code> 关键字则非必须。</p><h3 id="1-2-4-Categories-关键字（第-17-项）"><a href="#1-2-4-Categories-关键字（第-17-项）" class="headerlink" title="1.2.4  Categories 关键字（第 17 项）"></a>1.2.4  Categories 关键字（第 17 项）</h3><p>在 Desktop Entry 文件中，可以有一个或者多个 Category ，但是默认选择 Main Category 生效。更多的 Category 项目可以参阅文档：<a href="https://specifications.freedesktop.org/menu-spec/latest/apas02.html">Additional Category</a> 。</p><table><thead><tr><th align="center">Main Category</th><th align="center">描述</th><th align="center">备注</th></tr></thead><tbody><tr><td align="center">Audio Video</td><td align="center">多媒体音视频</td><td align="center">-</td></tr><tr><td align="center">Audio</td><td align="center">音频程序</td><td align="center">选择此字段则也须包括 Audio Video 字段</td></tr><tr><td align="center">Video</td><td align="center">视频程序</td><td align="center">选择此字段则也须包括 Audio Video 字段</td></tr><tr><td align="center">Development</td><td align="center">开发者程序</td><td align="center">-</td></tr><tr><td align="center">Education</td><td align="center">教育软件</td><td align="center">-</td></tr><tr><td align="center">Game</td><td align="center">游戏程序</td><td align="center">-</td></tr><tr><td align="center">Graphics</td><td align="center">浏览，处理图片程序</td><td align="center">-</td></tr><tr><td align="center">Network</td><td align="center">网络程序</td><td align="center">-</td></tr><tr><td align="center">Office</td><td align="center">办公软件</td><td align="center">-</td></tr><tr><td align="center">Science</td><td align="center">科学软件</td><td align="center">-</td></tr><tr><td align="center">Settings</td><td align="center">设置</td><td align="center">可能出现在单独菜单中，或者在控制中心中</td></tr><tr><td align="center">System</td><td align="center">系统软件，如日志文件软件</td><td align="center">-</td></tr><tr><td align="center">Utility</td><td align="center">实用程序，如 Accessories</td><td align="center">-</td></tr></tbody></table><h2 id="1-3-存放位置"><a href="#1-3-存放位置" class="headerlink" title="1.3 存放位置"></a>1.3 存放位置</h2><p>通常，通过包管理器或者自动安装的软件要么在用户条目目录下自动创建了 desktop 文件，要么就在系统目录下自动创建了 desktop 文件。在这两个目录下创建了 desktop 文件，访问图标将出现在 Linux 的开始菜单中。如果本人想要在桌面创建图标则需要在主目录的桌面文件夹下创建一个 desktop 文件。</p><h3 id="1-3-1-用户条目的-desktop-文件"><a href="#1-3-1-用户条目的-desktop-文件" class="headerlink" title="1.3.1 用户条目的 desktop 文件"></a>1.3.1 用户条目的 desktop 文件</h3><p>此文件夹下desktop 文件通常是安装软件后自动生成。具体目录如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">~/.local/share/application<br><span class="hljs-meta prompt_"># </span><span class="language-bash">等效于如下路径，其中 dustwind 为笔者的用户目录</span><br>/home/dustwind/.local/share/applications<br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><p>主目录等效于根目录的 home 目录下的用户目录，即：</p><p>～ 等效于 &#x2F;home&#x2F;{UserName} 目录</p></blockquote><h3 id="1-3-2-系统条目的-desktop-文件"><a href="#1-3-2-系统条目的-desktop-文件" class="headerlink" title="1.3.2 系统条目的 desktop 文件"></a>1.3.2 系统条目的 desktop 文件</h3><p>此文件夹下 desktop 文件通常是安装软件后自动生成。具体目录如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">通常的 Linux 系统是如下目录</span><br>/usr/share/applications<br><span class="hljs-meta prompt_"># </span><span class="language-bash">有的 Linux 系统会是如下目录</span><br>/usr/local/share/applications/<br></code></pre></td></tr></table></figure><blockquote><p><strong>注</strong>：</p><p>需要注意的是，<strong>用户条目</strong>下的文件优先级高于<strong>系统条目</strong>下的文件优先级</p></blockquote><h3 id="1-3-3-在桌面访问的-desktop-文件"><a href="#1-3-3-在桌面访问的-desktop-文件" class="headerlink" title="1.3.3 在桌面访问的 desktop 文件"></a>1.3.3 在桌面访问的 desktop 文件</h3><p>如果想要在桌面访问软件，则需要访问软件的 desktop 文件放到如下目录中并编辑对应的桌面项。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">中文环境下为如下目录</span><br>~/桌面<br><span class="hljs-meta prompt_"># </span><span class="language-bash">英文环境下为如下目录</span><br>~/Desktop<br></code></pre></td></tr></table></figure><h1 id="二-实现-desktop-文件"><a href="#二-实现-desktop-文件" class="headerlink" title="二.实现 desktop 文件"></a>二.实现 desktop 文件</h1><p>这里以 google-chrome 软件为例编写 desktop 文件。具体可对照规格文档查看具体含义，这里就不再阐述。本章节的实现可以参考： <a href="https://wiki.archlinuxcn.org/wiki/%E6%A1%8C%E9%9D%A2%E9%A1%B9">ArchWiki—桌面项</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs shell">[Desktop Entry]<br>Version=1.0<br>Name=Google Chrome<br><span class="hljs-meta prompt_"># </span><span class="language-bash">Only KDE 4 seems to use GenericName, so we reuse the KDE strings.</span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">From Ubuntu<span class="hljs-string">&#x27;s language-pack-kde-XX-base packages, version 9.04-20090413.</span></span><br>GenericName=Web Browser<br>GenericName[en_GB]=Web Browser<br>GenericName[zh_CN]=网页浏览器<br>GenericName[zh_TW]=網頁瀏覽器<br><span class="hljs-meta prompt_"># </span><span class="language-bash"><span class="hljs-string">Gnome and KDE 3 uses Comment.</span></span><br>Comment=Access the Internet<br>Comment[en_GB]=Access the Internet<br>Comment[zh_CN]=访问互联网<br>Comment[zh_TW]=連線到網際網路<br>StartupWMClass=Google-chrome<br>Exec=/usr/bin/google-chrome-stable %U<br>StartupNotify=true<br>Terminal=false<br>Icon=google-chrome<br>Type=Application<br>Categories=Network;WebBrowser;<br>MimeType=application/pdf;application/rdf+xml;application/rss+xml;application/xhtml+xml;application/xhtml_xml;application/xml;image/gif;image/jpeg;image/png;image/webp;text/html;text/xml;x-scheme-handler/http;x-scheme-handler/https;<br>Actions=new-window;new-private-window;<br><br>[Desktop Action new-window]<br>Name=New Window<br>Name[en_GB]=New Window<br>Name[zh_CN]=新建窗口<br>Name[zh_TW]=開新視窗<br>StartupWMClass=Google-chrome<br>Exec=/usr/bin/google-chrome-stable<br><br>[Desktop Action new-private-window]<br>Name=New Incognito Window<br>Name[en_GB]=New Incognito window<br>Name[zh_CN]=新建隐身窗口<br>Name[zh_TW]=新增無痕式視窗<br>StartupWMClass=Google-chrome<br>Exec=/usr/bin/google-chrome-stable --incognito<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>Manjaro</tag>
      
      <tag>Desktop Entry</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C/C++『排序算法』</title>
    <link href="/2022/05/02/C++%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <url>/2022/05/02/C++%20%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="前言：定义排序的结构和交换函数"><a href="#前言：定义排序的结构和交换函数" class="headerlink" title="前言：定义排序的结构和交换函数"></a>前言：定义排序的结构和交换函数</h1><p>在代码举例的过程中会用到顺序表结构，同时排序过程难免涉及数据交换，故此设计以下结构体和函数<br>顺序表结构如下所示：<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义排序的所用到的结构</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXSIZE 10</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br>    <span class="hljs-type">int</span> r[MAXSIZE + <span class="hljs-number">1</span>]; <span class="hljs-comment">//通常将r[0]作为哨兵或者临时变量</span><br>    <span class="hljs-type">int</span> Length;<span class="hljs-comment">//顺序表长度</span><br>&#125; SqList;<br></code></pre></td></tr></table></figure></p><p>交换函数如下所示：<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义在排序中常常用到的交换数据的函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">swap</span><span class="hljs-params">(SqList *L, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> temp = L-&gt;r[i];<br>    L-&gt;r[i] = L-&gt;r[j];<br>    L-&gt;r[j] = temp;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>此外，为了使用统一的函数接口SqList，有些情况下的排序算法采取多层封装</p><hr><h1 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1 冒泡排序"></a>1 冒泡排序</h1><h2 id="1-1-交换排序"><a href="#1-1-交换排序" class="headerlink" title="1.1 交换排序"></a>1.1 交换排序</h2><pre><code class="hljs"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 1.冒泡排序初级版，仅对顺序表L作交换排序，输入参数为一个顺序表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Bubble_Sort0</span><span class="hljs-params">(SqList *L)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; L-&gt;Length; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; L-&gt;Length; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (L-&gt;r[i] &gt; L-&gt;r[j])<br>            &#123;<br>                <span class="hljs-built_in">swap</span>(L, i, j); <span class="hljs-comment">//交换L-&gt;r[i] 和 L-&gt;r[j] 的值</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></code></pre><h2 id="1-2-冒泡排序"><a href="#1-2-冒泡排序" class="headerlink" title="1.2 冒泡排序"></a>1.2 冒泡排序</h2><pre><code class="hljs"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 2.冒泡排序，输入参数为一个顺序表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Bubble_Sort</span><span class="hljs-params">(SqList *L)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; L-&gt;Length; i++)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (j = L-&gt;Length - <span class="hljs-number">1</span>; j &gt;= i; j--) <span class="hljs-comment">// j从后往前循环</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (L-&gt;r[j] &gt; L-&gt;r[j + <span class="hljs-number">1</span>]) <span class="hljs-comment">//若前者大于后者</span><br>            &#123;<br>                <span class="hljs-built_in">swap</span>(L, j, j + <span class="hljs-number">1</span>); <span class="hljs-comment">//交换L-&gt;r[j] 和 L-&gt;r[j+1] 的值</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></code></pre><h2 id="1-3-冒泡排序优化"><a href="#1-3-冒泡排序优化" class="headerlink" title="1.3 冒泡排序优化"></a>1.3 冒泡排序优化</h2><pre><code class="hljs"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 3.冒泡排序优化，输入参数为一个顺序表</span><br><span class="hljs-comment">// typedef bool Status;</span><br><span class="hljs-comment">// #define TRUE 1</span><br><span class="hljs-comment">// #define FALSE 0</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Bubble_Sort_Improve</span><span class="hljs-params">(SqList *L)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-type">bool</span> flag = <span class="hljs-literal">true</span>;                       <span class="hljs-comment">// flag用来做标记</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; L-&gt;Length &amp;&amp; flag; i++) <span class="hljs-comment">//若flag为false则退出循环</span><br>    &#123;<br>        flag = <span class="hljs-literal">false</span>;                        <span class="hljs-comment">// flag初始化为false</span><br>        <span class="hljs-keyword">for</span> (j = L-&gt;Length - <span class="hljs-number">1</span>; j &gt;= i; j--) <span class="hljs-comment">// j从后往前循环</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (L-&gt;r[j] &gt; L-&gt;r[j + <span class="hljs-number">1</span>]) <span class="hljs-comment">//若前者大于后者</span><br>            &#123;<br>                <span class="hljs-built_in">swap</span>(L, j, j + <span class="hljs-number">1</span>); <span class="hljs-comment">//交换L-&gt;r[j] 和 L-&gt;r[j+1] 的值</span><br>                flag = <span class="hljs-literal">true</span>;       <span class="hljs-comment">//如果有数据交换，则flag为true</span><br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></code></pre><hr><h1 id="2-简单选择排序"><a href="#2-简单选择排序" class="headerlink" title="2 简单选择排序"></a>2 简单选择排序</h1><pre><code class="hljs"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//执行简单选择排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Select_Sort</span><span class="hljs-params">(SqList *L)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i, j, min;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; L-&gt;Length; i++)<br>    &#123;<br>        min = i; <span class="hljs-comment">//将当前下标定义为最小值下标</span><br>        <span class="hljs-keyword">for</span> (j = i + <span class="hljs-number">1</span>; j &lt; L-&gt;Length; j++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (L-&gt;r[min] &gt; L-&gt;r[j]) <span class="hljs-comment">//如果有小于当前最小值的关键字</span><br>            &#123;<br>                min = j; <span class="hljs-comment">//将此关键字的下标赋值给min</span><br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (i != min) <span class="hljs-comment">//若min不等于i，说明找到最小值，交换</span><br>        &#123;<br>            <span class="hljs-built_in">swap</span>(L, j, j + <span class="hljs-number">1</span>); <span class="hljs-comment">//交换L-&gt;r[j] 和 L-&gt;r[min] 的值</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></code></pre><hr><h1 id="3-直接插入排序"><a href="#3-直接插入排序" class="headerlink" title="3 直接插入排序"></a>3 直接插入排序</h1><pre><code class="hljs"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//执行插入排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Insert_Sort</span><span class="hljs-params">(SqList *L)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">2</span>; i &lt; L-&gt;Length; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (L-&gt;r[i] &lt; L-&gt;r[i - <span class="hljs-number">1</span>])<br>        &#123;<br>            L-&gt;r[<span class="hljs-number">0</span>] = L-&gt;r[i]; <span class="hljs-comment">//设置哨兵</span><br>            <span class="hljs-keyword">for</span> (j = i - <span class="hljs-number">1</span>; L-&gt;r[j] &gt; L-&gt;r[<span class="hljs-number">0</span>]; j--)<br>            &#123;<br>                L-&gt;r[j + <span class="hljs-number">1</span>] = L-&gt;r[j]; <span class="hljs-comment">//记录后移</span><br>            &#125;<br>            L-&gt;r[j] = L-&gt;r[<span class="hljs-number">0</span>]; <span class="hljs-comment">//插入到正确位置</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></code></pre><hr><h1 id="4-希尔排序"><a href="#4-希尔排序" class="headerlink" title="4 希尔排序"></a>4 希尔排序</h1><pre><code class="hljs"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//执行希尔排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Shell_Sort</span><span class="hljs-params">(SqList *L)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-type">int</span> increment = L-&gt;Length;<br>    <span class="hljs-keyword">do</span><br>    &#123;<br>        increment = increment / <span class="hljs-number">3</span> + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span> (i = increment + <span class="hljs-number">1</span>; i &lt; L-&gt;Length; i++)<br>        &#123;<br>            <span class="hljs-keyword">if</span> (L-&gt;r[i] &lt; L-&gt;r[i - increment])<br>            &#123;<br>                <span class="hljs-comment">/*需将 L-&gt;r[i] 插入有序增量表w*/</span><br>                L-&gt;r[<span class="hljs-number">0</span>] = L-&gt;r[i]; <span class="hljs-comment">//暂存在L-&gt;r[0]</span><br>                <span class="hljs-keyword">for</span> (j = i - increment; j &gt; <span class="hljs-number">0</span> &amp;&amp; L-&gt;r[<span class="hljs-number">0</span>] &lt; L-&gt;r[j]; j++)<br>                &#123;<br>                    L-&gt;r[j + increment] = L-&gt;r[j]; <span class="hljs-comment">//记录后移，查找插入位置</span><br>                &#125;<br>                L-&gt;r[j + increment] = L-&gt;r[<span class="hljs-number">0</span>]; <span class="hljs-comment">//插入</span><br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span> (increment &gt; <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure></code></pre><hr><h1 id="5-堆排序"><a href="#5-堆排序" class="headerlink" title="5 堆排序"></a>5 堆排序</h1><pre><code class="hljs"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//首先本函数调整L-&gt;r[s]的关键字，使得L-&gt;r[s......m]成为一个大顶堆</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">HeapAdjust</span><span class="hljs-params">(SqList *L, <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> m)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> temp;<br>    temp = L-&gt;r[s];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> j = <span class="hljs-number">2</span> * s; j &lt;= m; j *= <span class="hljs-number">2</span>) <span class="hljs-comment">//沿关键字较大的的孩子节点向下筛选</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (j &lt; m &amp;&amp; L-&gt;r[j] &lt; L-&gt;r[j + <span class="hljs-number">1</span>])<br>        &#123;<br>            ++j; <span class="hljs-comment">// j为关键字中较大记录的下标</span><br>        &#125;<br>        <span class="hljs-keyword">if</span> (temp &gt;= L-&gt;r[j])<br>        &#123;<br>            <span class="hljs-keyword">break</span>; <span class="hljs-comment">// rc应当插入在位置s上</span><br>        &#125;<br>        L-&gt;r[s] = L-&gt;r[j];<br>        s = j;<br>    &#125;<br>    L-&gt;r[s] = temp; <span class="hljs-comment">//插入</span><br>&#125;<br><span class="hljs-comment">//然后执行堆排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Heap_Sort</span><span class="hljs-params">(SqList *L)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = L-&gt;Length / <span class="hljs-number">2</span>; i &gt; <span class="hljs-number">0</span>; i--)<br>    &#123;<br>        <span class="hljs-built_in">HeapAdjust</span>(L, i, L-&gt;Length); <span class="hljs-comment">//将L中的r构建成一个大顶堆</span><br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = L-&gt;Length; i &gt; <span class="hljs-number">1</span>; i--)<br>    &#123;<br>        <span class="hljs-built_in">swap</span>(L, <span class="hljs-number">1</span>, i);           <span class="hljs-comment">//将堆顶记录与当前未经排序的子序列的最后一个记录交换</span><br>        <span class="hljs-built_in">HeapAdjust</span>(L, <span class="hljs-number">1</span>, i - <span class="hljs-number">1</span>); <span class="hljs-comment">//将L-&gt;r[1.....i-1]重新调整为大顶堆</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></code></pre><hr><h1 id="6-归并排序"><a href="#6-归并排序" class="headerlink" title="6 归并排序"></a>6 归并排序</h1><h2 id="6-1-递归版归并排序"><a href="#6-1-递归版归并排序" class="headerlink" title="6.1 递归版归并排序"></a>6.1 递归版归并排序</h2><pre><code class="hljs"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//首先归并两个序列</span><br><span class="hljs-comment">//将有序的两个序列SRC[i......m]和SRC[m+1......n]归并为有序的DES[i......n]</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Merge</span><span class="hljs-params">(<span class="hljs-type">int</span> SRC[], <span class="hljs-type">int</span> DES[], <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> j, k, l;<br>    <span class="hljs-keyword">for</span> (j = m + <span class="hljs-number">1</span>, k = i; j &lt;= m &amp;&amp; j &lt;= n; k++) <span class="hljs-comment">//将SRC中记录由小到大归并到DES中</span><br>    &#123;<br>        <span class="hljs-keyword">if</span> (SRC[i] &lt; SRC[j])<br>        &#123;<br>            DES[k] = SRC[i++];<br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            DES[k] = SRC[j++];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i &lt;= m)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (l = <span class="hljs-number">0</span>; l &lt;= m - i; l++)<br>        &#123;<br>            DES[k + <span class="hljs-number">1</span>] = SRC[i + <span class="hljs-number">1</span>]; <span class="hljs-comment">//将剩余的SRC[i......m]复制到DES中</span><br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (j &lt;= n)<br>    &#123;<br>        <span class="hljs-keyword">for</span> (l = <span class="hljs-number">0</span>; l &lt;= n - j; l++)<br>        &#123;<br>            DES[k + <span class="hljs-number">1</span>] = SRC[j + <span class="hljs-number">1</span>]; <span class="hljs-comment">//将剩余的SRC[j......n]复制到DES中</span><br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//然后外封装一个函数，将SRC[s......t]归并排序为DES[s......t]</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MSort</span><span class="hljs-params">(<span class="hljs-type">int</span> SRC[], <span class="hljs-type">int</span> DES[], <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> t)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> m;<br>    <span class="hljs-type">int</span> TEMP[MAXSIZE + <span class="hljs-number">1</span>];<br>    <span class="hljs-keyword">if</span> (s == t)<br>    &#123;<br>        DES[s] = SRC[s];<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        m = (s + t) / <span class="hljs-number">2</span>;            <span class="hljs-comment">//将SRC[s......t]平分为两个序列SRC[s......m]和SRC[m+1......t]</span><br>        <span class="hljs-built_in">MSort</span>(SRC, TEMP, s, m);     <span class="hljs-comment">//递归将SRC[s......m]归并为有序的TEMP[s......m]</span><br>        <span class="hljs-built_in">MSort</span>(SRC, TEMP, m + <span class="hljs-number">1</span>, t); <span class="hljs-comment">//递归将SRC[m+1......t]归并为有序的TEMP[m+1......t]</span><br>        <span class="hljs-built_in">Merge</span>(TEMP, DES, s, m, t);  <span class="hljs-comment">//将TEMP[s......m]和TEMP[m+1......t]归并到DES[s......t]</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//最后递归归并排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Merge_Sort_Recursion</span><span class="hljs-params">(SqList *L)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">MSort</span>(L-&gt;r, L-&gt;r, <span class="hljs-number">1</span>, L-&gt;Length);<br>&#125;<br></code></pre></td></tr></table></figure></code></pre><h2 id="6-2-迭代版归并排序"><a href="#6-2-迭代版归并排序" class="headerlink" title="6.2 迭代版归并排序"></a>6.2 迭代版归并排序</h2><pre><code class="hljs"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//首先</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MergePass</span><span class="hljs-params">(<span class="hljs-type">int</span> SRC[], <span class="hljs-type">int</span> DES[], <span class="hljs-type">int</span> s, <span class="hljs-type">int</span> n)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i = <span class="hljs-number">1</span>;<br>    <span class="hljs-type">int</span> j;<br>    <span class="hljs-keyword">while</span> (i &lt;= n - <span class="hljs-number">2</span> * s + <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">Merge</span>(SRC, DES, i, i + s - <span class="hljs-number">1</span>, i + <span class="hljs-number">2</span> * s - <span class="hljs-number">1</span>); <span class="hljs-comment">//两两归并</span><br>        i = i + <span class="hljs-number">2</span> * s;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (i &lt; n - s + <span class="hljs-number">1</span>)<br>    &#123;<br>        <span class="hljs-built_in">Merge</span>(SRC, DES, i, i + s - <span class="hljs-number">1</span>, n); <span class="hljs-comment">//归并最后两个序列</span><br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-keyword">for</span> (j = i; j &lt;= n; j++) <span class="hljs-comment">//若剩下最后单个序列</span><br>        &#123;<br>            DES[j] = SRC[j];<br>        &#125;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//然后迭代归并排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Merge_Sort_Iterate</span><span class="hljs-params">(SqList *L)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> *TR = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(L-&gt;Length * <span class="hljs-built_in">sizeof</span>(<span class="hljs-type">int</span>)); <span class="hljs-comment">//申请额外空间</span><br>    <span class="hljs-type">int</span> k = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (k &lt; L-&gt;Length)<br>    &#123;<br>        <span class="hljs-built_in">MergePass</span>(L-&gt;r, TR, k, L-&gt;Length);<br>        k = <span class="hljs-number">2</span> * k; <span class="hljs-comment">//子序列长度加倍</span><br>        <span class="hljs-built_in">MergePass</span>(TR, L-&gt;r, k, L-&gt;Length);<br>        k = <span class="hljs-number">2</span> * k; <span class="hljs-comment">//子序列长度加倍</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></code></pre><hr><h1 id="7-快速排序"><a href="#7-快速排序" class="headerlink" title="7 快速排序"></a>7 快速排序</h1><pre><code class="hljs"><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//首先，交换顺序表中的子表记录，并使枢轴记录到位，并返回相应位置</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Partition</span><span class="hljs-params">(SqList *L, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> pivotkey;<br>    pivotkey = L-&gt;r[low]; <span class="hljs-comment">//将表的第一个记录作枢轴记录</span><br>    <span class="hljs-keyword">while</span> (low &lt; high)    <span class="hljs-comment">//从表的两边交替向中间扫描</span><br>    &#123;<br>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; L-&gt;r[high] &gt;= pivotkey)<br>        &#123;<br>            high--;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(L, low, high); <span class="hljs-comment">//将比枢轴记录小的记录交换到低端</span><br>        <span class="hljs-keyword">while</span> (low &lt; high &amp;&amp; L-&gt;r[low] &lt;= pivotkey)<br>        &#123;<br>            low++;<br>        &#125;<br>        <span class="hljs-built_in">swap</span>(L, low, high); <span class="hljs-comment">//将比枢轴记录大的记录交换到高端</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> low; <span class="hljs-comment">//返回枢轴所在位置</span><br>&#125;<br><span class="hljs-comment">//然后，递归排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">QSort</span><span class="hljs-params">(SqList *L, <span class="hljs-type">int</span> low, <span class="hljs-type">int</span> high)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> pivot;<br>    <span class="hljs-keyword">if</span> (low &lt; high)<br>    &#123;<br>        pivot = <span class="hljs-built_in">Partition</span>(L, low, high); <span class="hljs-comment">//将L-&gt;r[low ...... high]一分为二并算出枢轴值pivot</span><br>        <span class="hljs-built_in">QSort</span>(L, low, pivot - <span class="hljs-number">1</span>);        <span class="hljs-comment">//对低子表递归排序</span><br>        <span class="hljs-built_in">QSort</span>(L, pivot + <span class="hljs-number">1</span>, high);       <span class="hljs-comment">//对高子表递归排序</span><br>    &#125;<br>&#125;<br><span class="hljs-comment">//最后，执行快速排序</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Quick_Sort</span><span class="hljs-params">(SqList *L)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">QSort</span>(L, <span class="hljs-number">1</span>, L-&gt;Length);<br>&#125;<br></code></pre></td></tr></table></figure></code></pre><p>快速排序的优化说明：<br>    <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp">快速排序算法优化<br>       <span class="hljs-number">1.</span>优化选取枢轴----三数取中（始终保持左端较小）：在Partition函数第<span class="hljs-number">3</span>行和第<span class="hljs-number">4</span>行插入如下代码<br>           <span class="hljs-type">int</span> mid = low + (high - low)/<span class="hljs-number">2</span>;<br>           <span class="hljs-keyword">if</span> (L-&gt;r[low]&gt;L-&gt;r[high])<br>               <span class="hljs-built_in">swap</span>(L,low,high);<br>           <span class="hljs-keyword">if</span> (L-&gt;r[mid]&gt;L-&gt;r[high])<br>               <span class="hljs-built_in">swap</span>(L,mid,high);<br>           <span class="hljs-keyword">if</span> (L-&gt;r[mid]&gt;L-&gt;r[low])<br>               <span class="hljs-built_in">swap</span>(L,low,mid);<br>       <span class="hljs-number">2.</span>优化不必要交换----在Partition函数中<br>           首先，将枢轴关键字pivotkey备份到L-&gt;r[<span class="hljs-number">0</span>];<br>           其次，采用替换而不是交换的方式进行操作<br>           再者，将枢轴数值替换回L-&gt;r[low];<br>       <span class="hljs-number">3.</span>优化小数组时的排序方案<br>           定义一个插入排序的最大数值【<span class="hljs-meta">#<span class="hljs-keyword">define</span> MAX_LENGTH_INSERT_SORT 7】</span><br>           在QSort函数中high-low的值 如果大于这个定义值就用快速排序，<br>                                    如果小于等于这个定义值就用插入排序<br>       <span class="hljs-number">4.</span>优化递归操作<br>           将QSort函数的<span class="hljs-keyword">if</span>语句改成<span class="hljs-keyword">while</span>语句，并将第二个QSort改为low=pivot+<span class="hljs-number">1</span>的尾递归<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    
    <tags>
      
      <tag>C/CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C/C++『查找算法』</title>
    <link href="/2022/05/01/C++%20%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/"/>
    <url>/2022/05/01/C++%20%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="1-顺序表查找"><a href="#1-顺序表查找" class="headerlink" title="1 顺序表查找"></a>1 顺序表查找</h1><h2 id="1-1-常规顺序表查找"><a href="#1-1-常规顺序表查找" class="headerlink" title="1.1 常规顺序表查找"></a>1.1 常规顺序表查找</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//顺序查找算法，a为数组，n为要查找的数组个数/数组下标最大值，key为要查找的关键字</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Sequential_Search</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= n; i++)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (key == a[i])<br>            <span class="hljs-keyword">return</span> i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-2-顺序表查找的优化"><a href="#1-2-顺序表查找的优化" class="headerlink" title="1.2 顺序表查找的优化"></a>1.2 顺序表查找的优化</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//顺序查找算法改进，a 为数组，n 为要查找的数组个数/数组下标最大值，key 为要查找的关键字</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Sequential_Search_Improve</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i;<br>    i = n;      <span class="hljs-comment">//设置搜索范围从数组结尾开始</span><br>    a[<span class="hljs-number">0</span>] = key; <span class="hljs-comment">//设置a[0]为key，即设置哨兵（此时在a中一定有key值，如果返回下标为0，表示查询失败；如果返回下标非0，表示查询到key所在的位置）</span><br>    <span class="hljs-keyword">while</span> (a[i] != key)<br>    &#123;<br>        i--;<br>    &#125;<br>    <span class="hljs-keyword">return</span> i; <span class="hljs-comment">//返回0则表示查找失败</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="2-有序表查找"><a href="#2-有序表查找" class="headerlink" title="2 有序表查找"></a>2 有序表查找</h1><h2 id="2-1-折半查找-二分查找"><a href="#2-1-折半查找-二分查找" class="headerlink" title="2.1 折半查找&#x2F;二分查找"></a>2.1 折半查找&#x2F;二分查找</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//折半查找，又叫二分查找,a 为数组，n 为要查找的数组个数/数组下标最大值，key 为要查找的关键字</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Binary_Search</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> low, mid, high;<br>    low = <span class="hljs-number">1</span>;  <span class="hljs-comment">//定义最低下标为记录首位</span><br>    high = n; <span class="hljs-comment">//定义最高下标为记录末位</span><br>    <span class="hljs-keyword">while</span> (low &lt;= high)<br>    &#123;<br>        mid = (low + high) / <span class="hljs-number">2</span>; <span class="hljs-comment">//折半</span><br>        <span class="hljs-keyword">if</span> (key &lt; a[mid])       <span class="hljs-comment">//若查找值比中值小，则最高下标调整到 mid - 1 位</span><br>        &#123;<br>            high = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; a[mid]) <span class="hljs-comment">//若查找值比中值大，则最低下标调整到 mid + 1 位</span><br>        &#123;<br>            low = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">//若相等，则说明mid为key所查找的位置</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-插值查找"><a href="#2-2-插值查找" class="headerlink" title="2.2 插值查找"></a>2.2 插值查找</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//插值查找,a 为数组，n 为要查找的数组个数/数组下标最大值，key 为要查找的关键字</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Interporlation_Search</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> low, mid, high;<br>    low = <span class="hljs-number">1</span>;  <span class="hljs-comment">//定义最低下标为记录首位</span><br>    high = n; <span class="hljs-comment">//定义最高下标为记录末位</span><br>    <span class="hljs-keyword">while</span> (low &lt;= high)<br>    &#123;<br>        mid = low + (high - low) * (key - a[low]) / (a[high] - a[low]); <span class="hljs-comment">//插值</span><br>        <span class="hljs-keyword">if</span> (key &lt; a[mid])                                               <span class="hljs-comment">//若查找值比中值小，则最高下标调整到 mid - 1 位</span><br>        &#123;<br>            high = mid - <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; a[mid]) <span class="hljs-comment">//若查找值比中值大，则最低下标调整到 mid + 1 位</span><br>        &#123;<br>            low = mid + <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-comment">//若相等，则说明mid为key所查找的位置</span><br>        &#123;<br>            <span class="hljs-keyword">return</span> mid;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-斐波拉契查找"><a href="#2-3-斐波拉契查找" class="headerlink" title="2.3 斐波拉契查找"></a>2.3 斐波拉契查找</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//斐波拉契查找,a 为数组，n 为要查找的数组个数/数组下标最大值，key 为要查找的关键字</span><br><br><span class="hljs-comment">//首先定义个斐波拉契分割函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fibonacci</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">2</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> i == <span class="hljs-number">0</span> ? <span class="hljs-number">0</span> : <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">Fibonacci</span>(i - <span class="hljs-number">1</span>) + <span class="hljs-built_in">Fibonacci</span>(i - <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-comment">//然后定义斐波拉契搜索法</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Fibonacci_Search</span><span class="hljs-params">(<span class="hljs-type">int</span> *a, <span class="hljs-type">int</span> n, <span class="hljs-type">int</span> key)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> low, high, mid, i, k;<br>    low = <span class="hljs-number">1</span>;  <span class="hljs-comment">//定义最低下标为记录首位</span><br>    high = n; <span class="hljs-comment">//定义最高下标为记录末位</span><br>    k = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (n &gt; <span class="hljs-built_in">Fibonacci</span>(k) - <span class="hljs-number">1</span>) <span class="hljs-comment">//计算n位于斐波拉契数列的位置</span><br>    &#123;<br>        k++;<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = n; i &lt; <span class="hljs-built_in">Fibonacci</span>(k) - <span class="hljs-number">1</span>; i++) <span class="hljs-comment">//将不满的数值补满</span><br>    &#123;<br>        a[i] = a[n];<br>    &#125;<br>    <span class="hljs-keyword">while</span> (low &lt;= high)<br>    &#123;<br>        mid = low + <span class="hljs-built_in">Fibonacci</span>(k - <span class="hljs-number">1</span>) - <span class="hljs-number">1</span>; <span class="hljs-comment">//计算当前分隔的下标</span><br>        <span class="hljs-keyword">if</span> (key &lt; a[mid])                 <span class="hljs-comment">//若查找记录小于当前分隔记录</span><br>        &#123;<br>            high = mid - <span class="hljs-number">1</span>; <span class="hljs-comment">//最高下标调整到 mid - 1 位</span><br>            k = k - <span class="hljs-number">1</span>;      <span class="hljs-comment">//斐波拉契数列下标减一位</span><br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (key &gt; a[mid]) <span class="hljs-comment">//若查找记录大于当前分隔记录</span><br>        &#123;<br>            low = mid + <span class="hljs-number">1</span>; <span class="hljs-comment">//最低下标调整到 mid + 1 位</span><br>            k = k - <span class="hljs-number">2</span>;     <span class="hljs-comment">//斐波拉契数列下标减两位</span><br>        &#125;<br>        <span class="hljs-keyword">else</span><br>        &#123;<br>            <span class="hljs-keyword">if</span> (mid &lt;= n)<br>            &#123;<br>                <span class="hljs-keyword">return</span> mid; <span class="hljs-comment">//若相等则说明 mid 即为查找到的位置</span><br>            &#125;<br>            <span class="hljs-keyword">else</span><br>            &#123;<br>                <span class="hljs-keyword">return</span> n; <span class="hljs-comment">//若 mid &gt; n 则说明是补全数值，返回n</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="3-线性索引排序"><a href="#3-线性索引排序" class="headerlink" title="3 线性索引排序"></a>3 线性索引排序</h1><hr><h1 id="4-……"><a href="#4-……" class="headerlink" title="4 ……"></a>4 ……</h1>]]></content>
    
    
    
    <tags>
      
      <tag>C/CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Linux 常用命令</title>
    <link href="/2022/04/29/Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/04/29/Linux%20%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h1 id="常用-Linux-命令"><a href="#常用-Linux-命令" class="headerlink" title="常用 Linux 命令"></a>常用 Linux 命令</h1><h2 id="一-目录操作"><a href="#一-目录操作" class="headerlink" title="一.目录操作"></a>一.目录操作</h2><h3 id="1-1-基本命令"><a href="#1-1-基本命令" class="headerlink" title="1.1 基本命令"></a>1.1 基本命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">pwd # 查看当前⼯作⽬录<br>clear # 清除屏幕<br>cd ~ # 当前⽤户⽬录<br>cd / # 根⽬录<br>cd - # 上⼀次访问的⽬录<br>cd .. # 上⼀级⽬录<br></code></pre></td></tr></table></figure><h3 id="1-2-查看目录内信息"><a href="#1-2-查看目录内信息" class="headerlink" title="1.2 查看目录内信息"></a>1.2 查看目录内信息</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ll # 查看当前⽬录下内容（LL的⼩写）<br></code></pre></td></tr></table></figure><h3 id="1-3-创建目录"><a href="#1-3-创建目录" class="headerlink" title="1.3 创建目录"></a>1.3 创建目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">mkdir aaa  # 在当前⽬录下创建aaa⽬录，相对路径；<br>mkdir ./bbb  # 在当前⽬录下创建bbb⽬录，相对路径；<br>mkdir /ccc  # 在根⽬录下创建ccc⽬录，绝对路径；<br>mkdir -p temp/nginx  # 递归创建目录（会创建⾥⾯没有的⽬录⽂件夹）<br></code></pre></td></tr></table></figure><h3 id="1-4-搜索命令"><a href="#1-4-搜索命令" class="headerlink" title="1.4 搜索命令"></a>1.4 搜索命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">find / -name &#x27;b&#x27; # 查询根⽬录下（包括⼦⽬录），名以b的⽬录和⽂件；<br>find / -name &#x27;b*&#x27; # 查询根⽬录下（包括⼦⽬录），名以b开头的⽬录和⽂件；<br></code></pre></td></tr></table></figure><h3 id="1-5-重命名"><a href="#1-5-重命名" class="headerlink" title="1.5 重命名"></a>1.5 重命名</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv 原先⽬录 ⽂件的名称 # 举例：mv tomcat001 tomcat<br></code></pre></td></tr></table></figure><h3 id="1-6-剪切命令"><a href="#1-6-剪切命令" class="headerlink" title="1.6 剪切命令"></a>1.6 剪切命令</h3><blockquote><p>有⽬录剪切到制定⽬录下，没有的话剪切为指定⽬录</p></blockquote><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">mv /aaa /bbb# 将根⽬录下的aaa⽬录，移动到bbb⽬录下，在bbb，麚也叫aaa⽬录；<br>mv bbbb usr/bbb # 将当前⽬录下的bbbb⽬录，移动到usr⽬录下，并且修改名称为bbb；<br>mv bbb usr/aaa # 将当前⽬录下的bbbb⽬录，移动到usr⽬录下，并且修改名称为aaa；<br></code></pre></td></tr></table></figure><h3 id="1-6-复制目录"><a href="#1-6-复制目录" class="headerlink" title="1.6 复制目录"></a>1.6 复制目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp -r /aaa /bbb # 将/⽬录下的aaa⽬录复制到/bbb⽬录下，在/bbb⽬录下的名称为aaa<br>cp -r /aaa /bbb/aaa # 将/⽬录下的aa⽬录复制到/bbb⽬录下，且修改名为aaa;<br></code></pre></td></tr></table></figure><h3 id="1-7-删除目录"><a href="#1-7-删除目录" class="headerlink" title="1.7 删除目录"></a>1.7 删除目录</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -r /bbb # 普通删除。会询问你是否删除每⼀个⽂件<br>rm -rf /bbb  # 强制删除/⽬录下的bbb⽬录。如果bbb⽬录中的⼦⽬录均被强制删除，不会提示<br></code></pre></td></tr></table></figure><h2 id="二-文件操作"><a href="#二-文件操作" class="headerlink" title="二.文件操作"></a>二.文件操作</h2><h3 id="2-1-删除操作"><a href="#2-1-删除操作" class="headerlink" title="2.1 删除操作"></a>2.1 删除操作</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -r a.java # 删除当前⽬录下的a.java⽂件（每次回询问是否删除y：同意）<br></code></pre></td></tr></table></figure><h3 id="2-2-强制删除"><a href="#2-2-强制删除" class="headerlink" title="2.2 强制删除"></a>2.2 强制删除</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -rf a.java # 强制删除当前⽬录下的a.java⽂件<br>rm -rf ./a* # 强制删除当前⽬录下以a开头的所有⽂件；<br>rm -rf ./* # 强制删除当前⽬录下所有⽂件（慎⽤）；<br></code></pre></td></tr></table></figure><h3 id="2-3-创建文件"><a href="#2-3-创建文件" class="headerlink" title="2.3 创建文件"></a>2.3 创建文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">touch 文件名<br></code></pre></td></tr></table></figure><h3 id="2-4-递归删除-pyc格式的文件"><a href="#2-4-递归删除-pyc格式的文件" class="headerlink" title="2.4 递归删除.pyc格式的文件"></a>2.4 递归删除.pyc格式的文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -name &#x27;*.pyc&#x27; -exec rm -rf &#123;&#125; \;<br></code></pre></td></tr></table></figure><h3 id="2-5-打印当前文件夹下指定大小的文件"><a href="#2-5-打印当前文件夹下指定大小的文件" class="headerlink" title="2.5 打印当前文件夹下指定大小的文件"></a>2.5 打印当前文件夹下指定大小的文件</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -name &quot;*&quot; -size 145800c -print;<br></code></pre></td></tr></table></figure><h3 id="2-6-递归删除指定大小的⽂件-145800）"><a href="#2-6-递归删除指定大小的⽂件-145800）" class="headerlink" title="2.6 递归删除指定大小的⽂件(145800）"></a>2.6 递归删除指定大小的⽂件(145800）</h3><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sqf"><span class="hljs-built_in">find</span> . -<span class="hljs-built_in">name</span> <span class="hljs-string">&quot;*&quot;</span> -<span class="hljs-built_in">size</span> <span class="hljs-number">145800</span>c -<span class="hljs-built_in">exec</span> rm -rf &#123;&#125; \;<br></code></pre></td></tr></table></figure><h3 id="2-7-递归删除指定大小的⽂件，并打印出来"><a href="#2-7-递归删除指定大小的⽂件，并打印出来" class="headerlink" title="2.7 递归删除指定大小的⽂件，并打印出来"></a>2.7 递归删除指定大小的⽂件，并打印出来</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">find . -name &quot;*&quot; -size 145800c -print -exec rm -rf &#123;&#125; \;<br></code></pre></td></tr></table></figure><blockquote><ul><li>“.” 表示从当前⽬录开始递归查找</li><li>“ -name ‘*.exe’ “ 根据名称来查找，要查找所有以.exe结尾的⽂件夹或者⽂件</li><li>“ -type f “ 查找的类型为⽂件</li><li>“-print” 输出查找的⽂件⽬录名</li><li>-size 145800c 指定⽂件的⼤⼩ </li><li>-exec rm -rf {} ; 递归删除（前⾯查询出来的结果）</li></ul></blockquote><p>split命令：</p><p>可以将一个大文件分割成若干个小文件，又是需要将文件分割成更小的片段，比如为提高可读性，生成日志等。</p><blockquote><ul><li>-b：值为每⼀输出档案的⼤⼩，单位为 byte</li><li>-C：每⼀输出档中，单⾏的最⼤ byte 数</li><li>-d：使⽤数字作为后缀 </li><li>-l：值为每⼀输出档的⾏数⼤⼩</li><li>-a：指定后缀⻓度(默认为2)</li></ul></blockquote><p>举例：</p><ol><li>使⽤split命令将上⾯创建的date.file⽂件分割成⼤⼩为10KB的⼩⽂件</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">split -b 10k date.file<br></code></pre></td></tr></table></figure><ol start="2"><li>⽂件被分割成多个带有字⺟的后缀⽂件，如果想⽤数字后缀可使⽤-d参数，同时可以使⽤-a length来指定后缀的⻓度</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">split -b 10k date.file -d -a 3<br></code></pre></td></tr></table></figure><ol start="3"><li>为分割后的⽂件指定⽂件名的前缀</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">split -b 10k date.file -d -a 3 split_file<br></code></pre></td></tr></table></figure><ol start="4"><li>使⽤-l选项根据⽂件的⾏数来分割⽂件，例如把⽂件分割成每个包含10⾏的⼩⽂件：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">plit -l 10 date.file<br></code></pre></td></tr></table></figure><h2 id="三-⽂件内容操作（查看⽇志，更改配置⽂件）"><a href="#三-⽂件内容操作（查看⽇志，更改配置⽂件）" class="headerlink" title="三.⽂件内容操作（查看⽇志，更改配置⽂件）"></a>三.⽂件内容操作（查看⽇志，更改配置⽂件）</h2><h3 id="3-1-修改文件内容"><a href="#3-1-修改文件内容" class="headerlink" title="3.1 修改文件内容"></a>3.1 修改文件内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">vim a.java  # 进⼊⼀般模式<br>i(按键)# 进⼊插⼊模式(编辑模式)<br>ESC(按键) # 退出<br>:wq # 保存退出（shift+：调起输⼊框）<br>:q！      # 不保存退出（shift+：调起输⼊框）（内容更改）<br>:q  # 不保存退出（shift+：调起输⼊框）（没有内容更改）<br></code></pre></td></tr></table></figure><h3 id="3-2-查看文件内容"><a href="#3-2-查看文件内容" class="headerlink" title="3.2 查看文件内容"></a>3.2 查看文件内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat a.java # 查看a.java⽂件的最后⼀⻚内容；<br>more a.java # 从第⼀⻚开始查看a.java⽂件内容，按回⻋键⼀⾏⼀⾏进⾏查看，<br>     # 空格键⼀⻚⼀⻚进⾏查看，q退出；<br>less a.java# 从第⼀⻚开始查看a.java⽂件内容，按回⻋键⼀⾏⼀⾏的看，<br>     # 按空格键⼀⻚⼀⻚的看，⽀持使⽤PageDown和PageUp翻⻚，q退出；<br></code></pre></td></tr></table></figure><p>总结下more和less的区别：</p><blockquote><ol><li>less可以按键盘上下⽅向键显示上下内容,more不能通过上下⽅向键控制显示 </li><li>less不必读整个⽂件，加载速度会⽐more更快</li><li>less退出后shell不会留下刚显示的内容,⽽more退出后会在shell上留下刚显示的内容</li><li>more不能后退.</li></ol></blockquote><h3 id="3-3-查看前后行内容"><a href="#3-3-查看前后行内容" class="headerlink" title="3.3 查看前后行内容"></a>3.3 查看前后行内容</h3><p>实时查看文件的后几行（查询日志文件更方便）</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tail -f a.java # 查看a.java⽂件的后10⾏内容；<br></code></pre></td></tr></table></figure><p>前后几行查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">head a.java # 查看a.java⽂件的前10⾏内容（默认是显示十行）<br>tail -f a.java # 查看a.java⽂件的后10⾏内容（默认是显示十行）<br>head -n 7 a.java # 查看a.java⽂件的前7⾏内容<br>tail -n 7 a.java # 查看a.java⽂件的后7⾏内容<br></code></pre></td></tr></table></figure><h3 id="3-4-文件内部搜索指定内容"><a href="#3-4-文件内部搜索指定内容" class="headerlink" title="3.4 文件内部搜索指定内容"></a>3.4 文件内部搜索指定内容</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">grep under 123.txt # 在123.txt⽂件中搜索under字符串，⼤⼩写敏感，显示⾏；<br>grep -n under 123.txt # 在123.txt⽂件中搜索under字符串，⼤⼩写敏感，显示⾏及⾏号<br>grep -v under 123.txt # 在123.txt⽂件中搜索under字符串，⼤⼩写敏感，显示没搜索到的⾏<br>grep -i under 123.txt # 在123.txt⽂件中搜索under字符串，⼤⼩写敏感，显示⾏<br>grep -ni under 123.txt  # 在123.txt⽂件中搜索under字符串，⼤⼩写敏感，显示⾏及⾏号<br></code></pre></td></tr></table></figure><h3 id="3-5-终止操作指令"><a href="#3-5-终止操作指令" class="headerlink" title="3.5 终止操作指令"></a>3.5 终止操作指令</h3><p>Ctrl+c 和 Ctrl+z 都是中断命令，但是作⽤却不⼀样</p><blockquote><ol><li><p>Ctrl+C扮演类似的⻆⾊，强制中断程序的执⾏</p></li><li><p>Ctrl+Z就扮演了类似的⻆⾊，将任务中断，但是任务并没有结束，在进程中只是维持挂起的状态，⽤户可以使⽤ fg&#x2F;bg操作前台或后台的任务，fg命令重新启动前台被中断的任务，bg命令把被中断的任务放在后台执⾏</p></li></ol></blockquote><h3 id="3-6-重定向功能"><a href="#3-6-重定向功能" class="headerlink" title="3.6 重定向功能"></a>3.6 重定向功能</h3><p>可以使⽤ &gt; 或 &lt; 将命令的输出的命令重定向到test.txt⽂件中（没有则创建⼀个）。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo &#x27;Hello World&#x27; &gt; /root/test.txt<br></code></pre></td></tr></table></figure><h2 id="四-系统⽇志位置"><a href="#四-系统⽇志位置" class="headerlink" title="四.系统⽇志位置"></a>四.系统⽇志位置</h2><p>汇总日志信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat /etc/redhat-release  # 查看操作系统版本<br>/var/log/message# 系统启动后的信息和错误⽇志，是Red Hat Linux中最常⽤的⽇志之⼀<br>/var/log/message # 系统启动后的信息和错误⽇志，是Red Hat Linux中最常⽤的⽇志之⼀<br>/var/log/secure # 与安全相关的⽇志信息<br>/var/log/maillog# 与邮件相关的⽇志信息<br>/var/log/cron# 与定时任务相关的⽇志信息<br>/var/log/spooler # 与UUCP和news设备相关的⽇志信息<br>/var/log/boot.log # 守护进程启动和停⽌相关的⽇志消息<br></code></pre></td></tr></table></figure><p>查看某⽂件下的⽤户操作⽇志，到达操作的⽬录下，执⾏下⾯的程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cat .bash_history<br></code></pre></td></tr></table></figure><h2 id="五-创建与删除软连接"><a href="#五-创建与删除软连接" class="headerlink" title="五.创建与删除软连接"></a>五.创建与删除软连接</h2><h3 id="5-1-建立软连接"><a href="#5-1-建立软连接" class="headerlink" title="5.1 建立软连接"></a>5.1 建立软连接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ln -s /usr/local/app /data<br></code></pre></td></tr></table></figure><blockquote><p> 注意：创建软连接时，data⽬录后不加 &#x2F; (加上后是查找其下⼀级⽬录)；</p></blockquote><h3 id="5-2-删除软连接"><a href="#5-2-删除软连接" class="headerlink" title="5.2 删除软连接"></a>5.2 删除软连接</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">rm -rf /data<br></code></pre></td></tr></table></figure><h2 id="六-压缩与解压缩"><a href="#六-压缩与解压缩" class="headerlink" title="六.压缩与解压缩"></a>六.压缩与解压缩</h2><h3 id="6-1-tar命令"><a href="#6-1-tar命令" class="headerlink" title="6.1 tar命令"></a>6.1 tar命令</h3><div style="text-align: center;">      <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/tar%E5%91%BD%E4%BB%A4.png" alt="tar命令"/></div><ol><li>压缩（-c）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将当前⽬录下a.java、b.java打包</span><br>tar -cvf start.tar a.java b.java <br><span class="hljs-meta prompt_"># </span><span class="language-bash">将当前⽬录下的所欲⽂件打包压缩成haha.tar⽂件</span><br>tar -cvf start.tar ./*<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">将当前⽬录下a.java、b.java打包</span><br>tar -zcvf start.tar.gz a.java b.java<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将当前⽬录下的所欲⽂件打包压缩成start.tar.gz⽂件</span><br>tar -zcvf start.tar.gz ./* <br></code></pre></td></tr></table></figure><ol start="2"><li>解压缩（-x）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">解压start.tar压缩包，到当前⽂件夹下</span><br>tar -xvf start.tar<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压start.tar压缩包，到/usr/local⽬录下（C为⼤写，中间⽆空格）</span><br>tar -xvf start.tar -C usr/local  <br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压start.tar.gz压缩包，到当前⽂件夹下</span><br>tar -zxvf start.tar.gz<br><span class="hljs-meta prompt_"># </span><span class="language-bash">解压start.tar.gz压缩包，到/usr/local⽬录下（C为⼤写，中间⽆空格）</span><br>tar -zxvf start.tar.gz -C usr/local <br></code></pre></td></tr></table></figure><ol start="3"><li>解压缩（tar.xz文件）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tar -xf node-v12.18.1-linux-x64.tar.xz<br></code></pre></td></tr></table></figure><h3 id="6-2-zip-unzip命令"><a href="#6-2-zip-unzip命令" class="headerlink" title="6.2 zip&#x2F;unzip命令"></a>6.2 zip&#x2F;unzip命令</h3><ol><li>压缩（zip）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">将单个⽂件压缩(lib.zip)</span><br>zip lib.zip tomcat.jar<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将lib⽬录进⾏压缩(lib.zip)</span><br>zip -r lib.zip lib/ <br><span class="hljs-meta prompt_"># </span><span class="language-bash">将多个⽂件压缩为zip⽂件(lib.zip)</span> <br>zip -r lib.zip tomcat-embed.jar xml-aps.jar <br></code></pre></td></tr></table></figure><ol start="2"><li>解压缩（unzip）</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">解压⼀个zip格式压缩包</span><br>unzip file1.zip<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将`english.zip`包，解压到指定目录`/usr/app/`下</span><br>unzip -d /usr/app/com.lydms.english.zip <br></code></pre></td></tr></table></figure><h2 id="七-Linux下文件的详细信息"><a href="#七-Linux下文件的详细信息" class="headerlink" title="七.Linux下文件的详细信息"></a>七.Linux下文件的详细信息</h2><blockquote><p>r:read w:write x: execute执⾏</p><p>解释：</p><ol><li><p>前三位代表当前⽤户对⽂件权限：可以读&#x2F;可以写&#x2F;不能执⾏</p></li><li><p>中间三位代表当前组的其他⽤户对当前⽂件的操作权限：可以读&#x2F;不能写&#x2F;不能执⾏</p></li><li><p>后三位其他⽤户对当前⽂件权限：可以读&#x2F;不能写&#x2F;不能执⾏</p></li></ol><p>d-rw-r–r– 1 root root 34942 Jan 19 2018 bootstrap.jar</p><p>备注各个部分分别为：文件类型，文件权限，链接数，所属用户，所属组，文件大小，最后修改日期，文件名</p></blockquote><h3 id="7-1-更改文件权限"><a href="#7-1-更改文件权限" class="headerlink" title="7.1 更改文件权限"></a>7.1 更改文件权限</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">chmod u+x web.xml （---x------） # 为⽂件拥有者（user）添加执⾏权限；<br>chmod g+x web.xml （------x---） # 为⽂件拥有者所在组（group）添加执⾏权限；<br>chmod 111 web.xml （---x--x--x） # 为所有⽤户分类，添加可执⾏权限；<br>chmod 222 web.xml （--w--w--w-） # 为所有⽤户分类，添加可写⼊权限； <br>chmod 444 web.xml （-r--r--r--） # 为所有⽤户分类，添加可读取权限；<br></code></pre></td></tr></table></figure><h2 id="八-常用的Docker容器命令"><a href="#八-常用的Docker容器命令" class="headerlink" title="八.常用的Docker容器命令"></a>八.常用的Docker容器命令</h2><p>更多详细命令可以参看 [[Docker 常用命令]]</p><h3 id="8-1-下载镜像"><a href="#8-1-下载镜像" class="headerlink" title="8.1 下载镜像"></a>8.1 下载镜像</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">格式为：wget+镜像源</span><br>wget https://mirrors.huaweicloud.com/elasticsearch/7.8.0/elasticsearch-7.8.0-windows-x86_64.zip<br></code></pre></td></tr></table></figure><p><a href="https://mirrors.huaweicloud.com/">华为开源镜像源</a>：<a href="https://mirrors.huaweicloud.com/">https://mirrors.huaweicloud.com/</a></p><h3 id="8-2-常用命令"><a href="#8-2-常用命令" class="headerlink" title="8.2 常用命令"></a>8.2 常用命令</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1.查看docker中下载好的镜像</span><br>docker images<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.查询需要的容器名称</span><br>docker search mysql<br><span class="hljs-meta prompt_"># </span><span class="language-bash">3.将需要的docker容器下载运⾏到本地(名称、端⼝号、msyql密码、ID)：</span><br>docker run -di --name=first -p 3306:3306 -e MYSQL_ROOT_PASSWORD=root 26d26dsfsd31a<br><span class="hljs-meta prompt_"># </span><span class="language-bash">4.查看运⾏的docker容器</span><br>docker ps<br><span class="hljs-meta prompt_"># </span><span class="language-bash">5.查看所有的docker容器（包括未运⾏的）</span><br>docker ps -a<br><span class="hljs-meta prompt_"># </span><span class="language-bash">6.停⽌当前运⾏的docker容器</span><br>docker stop first<br><span class="hljs-meta prompt_"># </span><span class="language-bash">7.启动docker容器</span><br>docker start first<br><span class="hljs-meta prompt_"># </span><span class="language-bash">8.重启docker容器</span><br>docker restart first<br><span class="hljs-meta prompt_"># </span><span class="language-bash">9.删除docker容器：</span><br>docker rm first<br></code></pre></td></tr></table></figure><h2 id="九-运维常用命令"><a href="#九-运维常用命令" class="headerlink" title="九.运维常用命令"></a>九.运维常用命令</h2><h3 id="9-1-查询服务器状态"><a href="#9-1-查询服务器状态" class="headerlink" title="9.1 查询服务器状态"></a>9.1 查询服务器状态</h3><p>查看服务器是否可用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">ping + IP地址</span><br>ping 49.32.56.164<br></code></pre></td></tr></table></figure><p>查看服务器指定端口是否可用</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">telnet + IP地址</span><br>telnet 49.32.56.164<br></code></pre></td></tr></table></figure><blockquote><p>Telnet安装：<a href="https://blog.csdn.net/lydms/article/details/113698856">https://blog.csdn.net/lydms/article/details/113698856</a></p></blockquote><h3 id="9-2-常用命令"><a href="#9-2-常用命令" class="headerlink" title="9.2 常用命令"></a>9.2 常用命令</h3><ol><li>shutdown命令</li></ol><p>关闭计算机。shutdown是最常⽤也是最安全的关机和重启命令，它会在关机之前调⽤fsck检查磁盘，其中-h和-r是最常⽤的参数</p><blockquote><p>-h：停⽌系统服务并关机</p><p>-r：停⽌系统服务后重启</p></blockquote><p>举例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">立即关机</span><br>shutdown -h now<br><span class="hljs-meta prompt_"># </span><span class="language-bash">到10:53关机，如果该时间⼩于当前时间，则到隔天</span> <br>shutdown -h 10:53<br><span class="hljs-meta prompt_"># </span><span class="language-bash">10分钟后⾃动关机</span><br>shutdown -h +10<br><span class="hljs-meta prompt_"># </span><span class="language-bash">立即重启</span><br>shutdown -r now<br><span class="hljs-meta prompt_"># </span><span class="language-bash">30分钟后重启并并发送通知给其它在线⽤户</span><br>shutdown -r +30 &#x27;The System Will Reboot in 30 Mins&#x27;  <br></code></pre></td></tr></table></figure><ol start="2"><li>查看处于各种连接状态数量(ESTABLISHED、CLOSE_WAIT、TIME_WAIT)</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看处于 ESTABLISHED 状态连接</span><br>netstat -nt | awk &#x27;&#123;if($NF==&quot;ESTABLISHED&quot;)&#123;wait[$5]++&#125;&#125;END&#123;for(i in wait) print i,wait[i]&#125;&#x27;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看处于 CLOSE_WAIT 状态连接</span><br>netstat -nt | awk &#x27;&#123;if($NF==&quot;CLOSE_WAIT&quot;)&#123;wait[$5]++&#125;&#125;END&#123;for(i in wait) print i,wait[i]&#125;&#x27;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看处于 TIME_WAIT 状态连接</span><br>netstat -nt | awk &#x27;&#123;if($NF==&quot;TIME_WAIT&quot;)&#123;wait[$5]++&#125;&#125;END&#123;for(i in wait) print i,wait[i]&#125;&#x27;<br></code></pre></td></tr></table></figure><ol start="3"><li>ping 命令</li></ol><p>对<a href="http://www.dustwind.club/">www.dustwind.club</a> 发送ping 包, 检查与其是否联通</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ping -c 4 dustwind.club<br></code></pre></td></tr></table></figure><ol start="4"><li>netstat命令</li></ol><p>netstat 命令⽤于显示各种⽹络相关信息，如⽹络连接, 路由表, 接⼝状态等等</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">列出所有处于监听状态的tcp端⼝</span><br>netstat -lt<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看所有的端⼝信息, 包括 PID 和进程名称</span><br>netstat -tulpn<br></code></pre></td></tr></table></figure><ol start="5"><li>查看当前端⼝号占⽤情况</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1.查看某⼀端⼝的占⽤情况</span><br>lsof -i:8080<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.显示tcp，udp的端⼝和进程等相关情况</span><br>netstat -tunlp<br><span class="hljs-meta prompt_"># </span><span class="language-bash">3.指定端口的进程情况</span><br>netstat -tunlp|grep 8080<br><span class="hljs-meta prompt_"># </span><span class="language-bash">4.查看PID进程情况</span><br>ps -aux |grep 28990<br>jstack 2246|grep &#x27;0x9eb&#x27; -A 50   # 根据PID，查看JVM中各线程信息(&#x27;0x9eb&#x27;为nid值）<br></code></pre></td></tr></table></figure><ol start="6"><li>ps命令</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">过滤得到当前系统中的 ssh 进程信息</span><br>ps aux | grep &#x27;ssh&#x27;<br></code></pre></td></tr></table></figure><ol start="7"><li>管道命令</li></ol><p>简单来说, Linux 中管道的作⽤是将上⼀个命令的输出作为下⼀个命令的输⼊, 像 pipe ⼀样将各个命令串联起来执行, 管道的操作符是 |</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">管道命令查看当前运⾏的程序中，名称为java的程序</span><br>ps -ef|grep java<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看/etc/passwd⽂件中的root内容</span><br>cat /etc/passwd | grep &#x27;root&#x27;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">查看当前系统的ip连接（Windows和Linux通⽤）</span><br>netstat -an<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将sh test.sh任务放到后台，并将打印的⽇志输出到 nohup.out ⽂件中，终端不再能够接收任何输⼊（标准输⼊）</span><br>nohup sh test.sh &amp;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将sh test.sh任务放到后台，并将打印的⽇志输出到 test.out ⽂件中，终端不再能够接收任何输⼊（标准输⼊）</span><br>nohup sh test.sh &gt;&gt; test.out &amp;<br><span class="hljs-meta prompt_"># </span><span class="language-bash">将sh test.sh任务放到后台，并将打印的⽇志输出到nohup.out⽂件中，终端能够接收任何输⼊</span><br>nohup sh test.sh &amp;<br></code></pre></td></tr></table></figure><ol start="8"><li>添加Host地址</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">打开配置文件</span><br>vim /etc/hosts<br><span class="hljs-meta prompt_"># </span><span class="language-bash">在打开文件中添加内容</span><br>49.32.56.164 dustwind.club<br><span class="hljs-meta prompt_"># </span><span class="language-bash">保存文件，重启网络</span><br>/etc/init.d/network restart<br></code></pre></td></tr></table></figure><h2 id="十-yum常用命令"><a href="#十-yum常用命令" class="headerlink" title="十.yum常用命令"></a>十.yum常用命令</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">1.下载并安装iptables</span><br>yum install iptables-services<br><span class="hljs-meta prompt_"># </span><span class="language-bash">2.列出当前系统中安装的所有包</span><br>yum list <br><span class="hljs-meta prompt_"># </span><span class="language-bash">3.在rpm仓库中搜寻软件包</span><br>yum search package_name<br><span class="hljs-meta prompt_"># </span><span class="language-bash">4.更新当前系统中所有安装的rpm包</span><br>yum update package_name.rpm<br><span class="hljs-meta prompt_"># </span><span class="language-bash">5.更新⼀个rpm包</span><br>yum update package_name<br><span class="hljs-meta prompt_"># </span><span class="language-bash">6.删除⼀个rpm包</span><br>yum remove package_name<br><span class="hljs-meta prompt_"># </span><span class="language-bash">7.删除所有缓存的包和头⽂件</span><br>yum clean all<br></code></pre></td></tr></table></figure><h2 id="十一-其他命令"><a href="#十一-其他命令" class="headerlink" title="十一.其他命令"></a>十一.其他命令</h2><ol><li>查看历史使用命令：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">查看历史使用命令<span class="hljs-built_in">history</span></span><br>history | grep es# 过滤与 es 相关的命令<br></code></pre></td></tr></table></figure><ol start="2"><li>查看占用资源：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -au # 占⽤的资源是从进程启动开始，计算的平均占⽤资源，⽐如cpu等<br>top    # 实时占⽤的资源<br></code></pre></td></tr></table></figure><ol start="3"><li>查看当前目录所占存储：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">du -lh # 查看当前⽂件下各⽂件夹占⽤存储空间<br>du -sh # 查看当前⽂件夹所占存储空间<br>du --max-depth=&lt;⽬录层数&gt;      # 超过指定层数的⽬录后，予以忽略。<br>du --max-depth=1  # 只查看当前⽬录下⽂件占⽤的存储空间<br></code></pre></td></tr></table></figure><ol start="4"><li><p>管道命令：</p><p>根据项⽬查看进程，更加PID查看项⽬，以及项⽬路径</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">ps -ef 查看所有的进程<br>ps -ef | grep mysql 查看mysql相关的进程<br></code></pre></td></tr></table></figure><ol start="5"><li>通过进程PID查看所占的端口号：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">netstat -nap |grep 进程ID(PID)<br></code></pre></td></tr></table></figure><ol start="6"><li>查看Linux下的系统存储使用率：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">df -h # 查看系统硬盘使⽤情况<br></code></pre></td></tr></table></figure><ol start="7"><li>杀死进程（根据PID）：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">kill -9 2630 # 杀死进程pid为2630的进程<br></code></pre></td></tr></table></figure><ol start="8"><li>关闭防火墙：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">service iptables stop # 临时关闭防⽕墙<br>chkconfig iptables off # 防⽕墙开启不启动<br>service iptables status # 查看防⽕墙状态<br></code></pre></td></tr></table></figure><ol start="9"><li>开机启动选项：<a href="https://www.cnblogs.com/lldsn/p/10489593.html"></a></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">msconfig # 查看开机启动选项<br>chkconfig # 查看开机启动服务列表<br></code></pre></td></tr></table></figure><ol start="10"><li>查看MySQL服务的程序状态：</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">service mysql start # 开启MySQL <br>service mysql status # 查看MySQL的状态 <br>service mysql stop # 关闭MySQL <br></code></pre></td></tr></table></figure><h2 id="十二-Linux内核优化"><a href="#十二-Linux内核优化" class="headerlink" title="十二.Linux内核优化"></a>十二.Linux内核优化</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">打开配置文件</span><br>vim /etc/sysctl.conf<br><span class="hljs-meta prompt_"># </span><span class="language-bash">加载新的配置（需开启防⽕墙iptables，否则会报错）</span><br>sysctl -p<br></code></pre></td></tr></table></figure><blockquote><p>详细查阅地址：<a href="https://www.cnblogs.com/lldsn/p/10489593.html">https://www.cnblogs.com/lldsn/p/10489593.html</a></p></blockquote><h2 id="十三-用户权限操作"><a href="#十三-用户权限操作" class="headerlink" title="十三.用户权限操作"></a>十三.用户权限操作</h2><h3 id="13-1-用户策略"><a href="#13-1-用户策略" class="headerlink" title="13.1 用户策略"></a>13.1 用户策略</h3><ol><li>添加用户sum：</li></ol><blockquote><p>useradd –d &#x2F;usr&#x2F;sum -m sum</p><p>参数注释：</p><p>-u：指定 UID，这个 UID 必须是⼤于等于500，并没有其他⽤户占⽤的 UID</p><p>-g：指定默认组，可以是 GID 或者 GROUPNAME，同样也必须真实存在</p><p>-G：指定额外组</p><p>-c：指定⽤户的注释信息</p><p>-d： 指定⽤户的家⽬录</p></blockquote><ol start="2"><li>已创建用户sum设置密码：</li></ol><blockquote><p>passwd sum</p></blockquote><ol start="3"><li>为用户添加root权限（visudo命令）</li></ol><blockquote><p>visudo</p><p>步骤：</p><ol><li>在sudoers 文件中找到root用户权限位置</li><li>添加与root用户相同的权限（复制root行，修改root为需修改权限的用户名）</li></ol></blockquote><ol start="4"><li>显示新建用户的信息</li></ol><blockquote><p>cat &#x2F;etc&#x2F;passwd</p></blockquote><ol start="5"><li>删除sum用户</li></ol><blockquote><p>userdel sum</p></blockquote><ol start="6"><li>删除用户文件夹</li></ol><blockquote><p>rm -rf &#x2F;usr&#x2F;sum</p></blockquote><ol start="7"><li>切换到添加的用户sum</li></ol><blockquote><p>su sum</p></blockquote><ol start="8"><li>回到root用户</li></ol><blockquote><p>exit</p></blockquote><h3 id="13-2-组策略"><a href="#13-2-组策略" class="headerlink" title="13.2 组策略"></a>13.2 组策略</h3><ol><li>添加用户组</li></ol><blockquote><p>groupadd groupname</p></blockquote><ol start="2"><li>删除用户组</li></ol><blockquote><p>groupdel groupname</p></blockquote><ol start="3"><li>显示分组信息</li></ol><blockquote><p>cat &#x2F;etc&#x2F;group</p></blockquote><h2 id="十四-TOP命令"><a href="#十四-TOP命令" class="headerlink" title="十四.TOP命令"></a>十四.TOP命令</h2><h3 id="14-1-top命令用于查看实时占用的资源"><a href="#14-1-top命令用于查看实时占用的资源" class="headerlink" title="14.1 top命令用于查看实时占用的资源"></a>14.1 top命令用于查看实时占用的资源</h3><blockquote><p>top [参数]</p><p>详细参数：</p><p>-b 批处理</p><p>-c 显示完整的治命令</p><p>-I 忽略失效过程</p><p>-s 保密模式</p><p>-S 累积模式</p><p>-i&lt;时间&gt; 设置间隔时间</p><p>-u&lt;用户名&gt; 指定用户名</p><p>-p&lt;进程号&gt; 指定进程</p><p>-n&lt;次数&gt; 循环显示的次数</p></blockquote><h3 id="14-2-举例"><a href="#14-2-举例" class="headerlink" title="14.2 举例"></a>14.2 举例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs shell">top - 14:06:23 up 70 days, 16:44,  2 users,  load average: 1.25, 1.32, 1.35<br>Tasks: 206 total,   1 running, 205 sleeping,   0 stopped,   0 zombie<br>Cpu(s):  5.9%us,  3.4%sy,  0.0%ni, 90.4%id,  0.0%wa,  0.0%hi,  0.2%si,  0.0%st<br>Mem:  32949016k total, 14411180k used, 18537836k free,   169884k buffers<br>Swap: 32764556k total,        0k used, 32764556k free,  3612636k cached<br><br>  PID USER      PR  NI  VIRT  RES  SHR S %CPU %MEM    TIME+  COMMAND                                               <br>28894 root      22   0 1501m 405m  10m S 52.2  1.3   2534:16 java                                                                   <br>18249 root      18   0 3201m 1.9g  11m S 35.9  6.0 569:39.41 java                                                                   <br> 2808 root      25   0 3333m 1.0g  11m S 24.3  3.1 526:51.85 java                                                               <br>25668 root      23   0 3180m 704m  11m S 14.0  2.2 360:44.53 java                                                                   <br>  574 root      25   0 3168m 611m  10m S 12.6  1.9 556:59.63 java                                                                   <br> 1599 root      20   0 3237m 1.9g  11m S 12.3  6.2 262:01.14 java                                                                   <br> 1008 root      21   0 3147m 842m  10m S  0.3  2.6   4:31.08 java                                                                   <br>13823 root      23   0 3031m 2.1g  10m S  0.3  6.8 176:57.34 java                                                                   <br>28218 root      15   0 12760 1168  808 R  0.3  0.0   0:01.43 top                                                                    <br>29062 root      20   0 1241m 227m  10m S  0.3  0.7   2:07.32 java                                                                   <br>    1 root      15   0 10368  684  572 S  0.0  0.0   1:30.85 init                                                                   <br>    2 root      RT  -5     0    0    0 S  0.0  0.0   0:01.01 migration/0                                                            <br>    3 root      34  19     0    0    0 S  0.0  0.0   0:00.00 ksoftirqd/0                                                            <br>    4 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 watchdog/0                                                             <br>    5 root      RT  -5     0    0    0 S  0.0  0.0   0:00.80 migration/1                                                            <br>    6 root      34  19     0    0    0 S  0.0  0.0   0:00.00 ksoftirqd/1                                               <br>    7 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 watchdog/1                                                             <br>    8 root      RT  -5     0    0    0 S  0.0  0.0   0:20.59 migration/2                                                            <br>    9 root      34  19     0    0    0 S  0.0  0.0   0:00.09 ksoftirqd/2                                                            <br>   10 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 watchdog/2                                                             <br>   11 root      RT  -5     0    0    0 S  0.0  0.0   0:23.66 migration/3                                                            <br>   12 root      34  19     0    0    0 S  0.0  0.0   0:00.03 ksoftirqd/3                                                            <br>   13 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 watchdog/3                                                             <br>   14 root      RT  -5     0    0    0 S  0.0  0.0   0:20.29 migration/4                                                            <br>   15 root      34  19     0    0    0 S  0.0  0.0   0:00.07 ksoftirqd/4                                                            <br>   16 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 watchdog/4                                                             <br>   17 root      RT  -5     0    0    0 S  0.0  0.0   0:23.07 migration/5                                                            <br>   18 root      34  19     0    0    0 S  0.0  0.0   0:00.07 ksoftirqd/5                                                            <br>   19 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 watchdog/5                                                             <br>   20 root      RT  -5     0    0    0 S  0.0  0.0   0:17.16 migration/6                                                            <br>   21 root      34  19     0    0    0 S  0.0  0.0   0:00.05 ksoftirqd/6                                                            <br>   22 root      RT  -5     0    0    0 S  0.0  0.0   0:00.00 watchdog/6                                                             <br>   23 root      RT  -5     0    0    0 S  0.0  0.0   0:58.28 migration/7<br></code></pre></td></tr></table></figure><p>前五行是当前系统情况整体的统计信息区，具体内容构成如下：</p><ol><li><p>第一行：任务队列信息，同 uptime 命令的执行结果。</p><p>具体参数说明：</p><p>14:06:23 — 当前系统时间</p><p>up 70 days, 16:44 — 系统已经运行了70天16小时44分钟（在这期间系统没有重启过的吆！）</p><p>2 users — 当前有2个用户登录系统</p><p>load average: 1.15, 1.42, 1.44 — load average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。</p><blockquote><p>load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了。</p></blockquote></li><li><p>第二行：任务总述。</p><p>具体参数说明：</p><p>Tasks — 任务（进程）</p><p>系统现在共有206个进程，其中处于运行中的有1个，205个在休眠（sleep），stoped状态的有0个，zombie状态（僵尸）的有0个。</p></li><li><p>第三行：cpu状态信息。</p><p>具体参数说明：</p><p>5.9%us — 用户空间占用CPU的百分比。</p><p>3.4% sy — 内核空间占用CPU的百分比。</p><p>0.0% ni — 改变过优先级的进程占用CPU的百分比</p><p>90.4% id — 空闲CPU百分比</p><p>0.0% wa — IO等待占用CPU的百分比</p><p>0.0% hi — 硬中断（Hardware IRQ）占用CPU的百分比</p><p>0.2% si — 软中断（Software Interrupts）占用CPU的百分比</p></li></ol><blockquote><p>备注：在这里CPU的使用比率和windows概念不同，需要理解linux系统用户空间和内核空间的相关知识！</p></blockquote><ol start="4"><li><p>第四行：内存状态。</p><p>具体参数说明：</p><p>32949016k total — 物理内存总量（32GB）</p><p>14411180k used — 使用中的内存总量（14GB）</p><p>18537836k free — 空闲内存总量（18GB）</p><p>169884k buffers — 缓存的内存量 （169M）</p></li><li><p>第五行，swap交换分区信息。</p><p>具体参数说明：</p><p>32764556k total — 交换区总量（32GB）</p><p>0k used — 使用的交换区总量（0K）</p><p>32764556k free — 空闲交换区总量（32GB）</p><p>3612636k cached — 缓冲的交换区总量（3.6GB）</p></li><li><p>第六行：空行。</p></li><li><p>第七行：各进程（任务）的状态监控。</p><p>具体参数说明：PID — 进程id</p><p>USER — 进程所有者</p><p>PR — 进程优先级</p><p>NI — nice值。负值表示高优先级，正值表示低优先级</p><p>VIRT — 进程使用的虚拟内存总量，单位kb。VIRT&#x3D;SWAP+RES</p><p>RES — 进程使用的、未被换出的物理内存大小，单位kb。RES&#x3D;CODE+DATA</p><p>SHR — 共享内存大小，单位kb</p><p>S — 进程状态。D&#x3D;不可中断的睡眠状态 R&#x3D;运行 S&#x3D;睡眠 T&#x3D;跟踪&#x2F;停止 Z&#x3D;僵尸进程</p><p>%CPU — 上次更新到现在的CPU时间占用百分比</p><p>%MEM — 进程使用的物理内存百分比</p><p>TIME+ — 进程使用的CPU时间总计，单位1&#x2F;100秒</p><p>COMMAND — 进程名称（命令名&#x2F;命令行）</p></li></ol><h2 id="十五-文件安装"><a href="#十五-文件安装" class="headerlink" title="十五.文件安装"></a>十五.文件安装</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_"># </span><span class="language-bash">下载文件（file.name）：</span><br>yum install -y file.name<br><span class="hljs-meta prompt_"># </span><span class="language-bash">上传文件：</span><br>rz<br><span class="hljs-meta prompt_"># </span><span class="language-bash">保存文件：</span><br>sz<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C/C++『数据结构』</title>
    <link href="/2022/04/27/C++%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2022/04/27/C++%20%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><h2 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1.数据结构"></a>1.数据结构</h2><p>什么是数据结构？数据结构就是相互之间存在的一种或者多种特定关系的数据元素集合。</p><h2 id="2-数据结构的分类"><a href="#2-数据结构的分类" class="headerlink" title="2.数据结构的分类"></a>2.数据结构的分类</h2><p>按照视点不同分成<strong>逻辑结构</strong>和<strong>物理结构</strong>两种：</p><h3 id="2-1-逻辑结构"><a href="#2-1-逻辑结构" class="headerlink" title="2.1 逻辑结构"></a>2.1 逻辑结构</h3><p>逻辑结构是值数据对象中各个数据元素之间的相互关系。其大致可分为一下四种：</p><ol><li>集合结构：集合结构当中数据元素除<strong>同属一个集合</strong>外它们之间没任何关系。</li><li>线性结构：线性结构当中数据元素之间是<strong>一对一</strong>关系。</li><li>树形结构：树形结构当中数据元素之间存在<strong>一对多</strong>的层次关系。</li><li>图形结构：图形结构当中数据元素之间存在<strong>多对多</strong>关系。</li></ol><h3 id="2-2-物理结构"><a href="#2-2-物理结构" class="headerlink" title="2.2 物理结构"></a>2.2 物理结构</h3><p>物理结构是指数据的逻辑结构在计算机当中的存储形式。其大致可分为一下两种：</p><ol><li>顺序存储结构</li></ol><p>顺序存储结构是把数据元素存放在地址连续的存储单元中，其数据间的逻辑关系与物理关系保持一致。</p><ol start="2"><li>链式存储结构</li></ol><p>链式存储结构是把数据元素存在任意存储单元中。其存储单元可以连续也可以不连续。这就意味着数据存在哪里并不重要，只要用一个指针存储地址信息便能查找到它。</p><hr><h1 id="分类介绍"><a href="#分类介绍" class="headerlink" title="分类介绍"></a>分类介绍</h1><p>数据结构按照存储结构可大致分为：</p><ol><li><p><strong>线性表</strong>，具体的还可细分为顺序表（可近似理解为数组）、链表、栈和队列、串；</p></li><li><p><strong>树结构</strong>，包括普通树，二叉树，线索二叉树等；</p></li><li><p><strong>图结构</strong>。</p></li></ol><h2 id="1-线性表"><a href="#1-线性表" class="headerlink" title="1.线性表"></a>1.线性表</h2><p>线性表是什么？线性表就是由零个或者多个数据元素组成的有限序列。其各元素依次排列，每个元素的前面和后边有且仅有一个元素与之相邻（首元素和尾元素除外）。</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%BB%93%E6%9E%84.png" alt="线性表结构"  /></div><blockquote><p><strong>注</strong>：线性表不只有一种存储结构，它包含了顺序存储结构和链式存储结构两种表述方式，是顺序表和链表的统称。作为特殊的线性表，栈和队列同样有顺序存储结构和链式存储结构两种表述方式</p></blockquote><ol><li><strong>顺序表</strong>：是线性表的顺序存储结构，即用一段地址连续的存储单元依次存储线性表的数据元素。顺序表结构的底层实现借助的是数组，可以把顺序表近似等价为数组。</li></ol><blockquote><p><strong>注</strong>：数据结构是研究数据存储方式的，它囊括的都是各种存储结构，而数组只是各种编程语言中的基本数据类型，并不属于数据结构的范畴。</p></blockquote><ol start="2"><li><strong>链表</strong>：是线性表的链式存储结构，即用一组任意的存储单元存储线性表的数据结构。</li><li><strong>栈和队列</strong>：栈和队列是特殊的线性表，因为它们对线性表的数据元素进出做出明确要求。<strong>栈</strong>是限定仅在表尾进行插入删除操作的线性表，又称为后进先出（<strong>LIFO</strong>）的线性表；而<strong>队列</strong>则是限定在表的一端进行插入操作，表的另一端进行删除操作的线性表，队列又称为先进先出（<strong>FIFO</strong>）的线性表。</li><li><strong>串</strong>：又叫字符串，是由另个或者多个多个字符组成的有限序列。</li></ol><h2 id="2-树结构"><a href="#2-树结构" class="headerlink" title="2.树结构"></a>2.树结构</h2><p>树（Tree）是 n（n≥0）个节点的有限集。树结构是典型的一对多关系。</p><p>当 n &#x3D; 0 时称为空树；</p><p>当 n ≠ 0 时的非空树中：</p><ul><li>有且仅有一个特定的节点称为根节点（Root）；</li><li>当 n &gt; 1 时，其余节点可以分割成若干个互不相交的子集，其每个集合本身也为一棵树，这棵树便是根的子树（SubTree）。</li></ul><p>特别的，当所有的节点的子集都不超过两个时称为二叉树。</p><p>特别的，堆是特殊的二叉树，即堆是完全二叉树。</p><h2 id="3-图结构"><a href="#3-图结构" class="headerlink" title="3.图结构"></a>3.图结构</h2><p>图是由定点的有穷非空集合与顶点之间边的集合组成，通常可表示为 G(V,E) ，其中 G 表示一个图，V 表示 G 当中定点的集合，E 表示 G 当中边的集合。图结构是典型的多对多关系。</p><h2 id="4-顺序表、树、图的关系"><a href="#4-顺序表、树、图的关系" class="headerlink" title="4.顺序表、树、图的关系"></a>4.顺序表、树、图的关系</h2><blockquote><p>线性表可以没有数据元素，称空表；树可以没有结点，称空树；而图当中不能没有顶点，因此图必须是有穷非空的。</p></blockquote><table><thead><tr><th align="center">存储类型</th><th align="center">数据元素名称</th><th align="center">相邻数据元素关系</th></tr></thead><tbody><tr><td align="center">线性表</td><td align="center">元素 (Element)</td><td align="center">线性关系</td></tr><tr><td align="center">树</td><td align="center">结点 (Node)</td><td align="center">层次关系</td></tr><tr><td align="center">图</td><td align="center">顶点 (Vertex)</td><td align="center">边（边集可以为空）</td></tr></tbody></table><hr><h1 id="一-顺序表（数组）"><a href="#一-顺序表（数组）" class="headerlink" title="一.顺序表（数组）"></a>一.顺序表（数组）</h1><p><strong>顺序表（SeqList）</strong>：是线性表的顺序存储结构，用一段地址连续的存储单元依次存储线性表的数据元素。顺序表结构的底层实现借助的是数组。顺序表的C++代码实现可参考如下链接：<a href="https://blog.csdn.net/weixin_48025315/article/details/119778068?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169391870016800186532858%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169391870016800186532858&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-119778068-null-null.142%5Ev93%5Einsert_down1&utm_term=SeqList&spm=1018.2226.3001.4187">顺序表（SeqList）的初始化、增、删、查、改等</a></p><h1 id="二-链表"><a href="#二-链表" class="headerlink" title="二.链表"></a>二.链表</h1><p><strong>链表（Linked List）</strong>：是线性表的链式存储结构，用一组任意的存储单元存储线性表的数据结构。</p><p>常用的链表建立方式：</p><ul><li><p>头插法（逆序建立链表）</p></li><li><p>尾插法（正序建立链表）</p></li></ul><h2 id="2-1-单链表"><a href="#2-1-单链表" class="headerlink" title="2.1 单链表"></a>2.1 单链表</h2><ol><li>结点定义</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 结点定义</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> SLTData; <span class="hljs-comment">// 定义单链表数据域类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">SLTNode</span><br>&#123;<br>    SLTData data;  <span class="hljs-comment">// 数据域</span><br>    SLTNode *next; <span class="hljs-comment">// 指针域</span><br>&#125; SListNode;<br></code></pre></td></tr></table></figure><ol start="2"><li>创建单链表结点</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 创建单链表结点</span><br><span class="hljs-function">SListNode *<span class="hljs-title">SLTNode_Create</span><span class="hljs-params">(SLTData x)</span></span><br><span class="hljs-function"></span>&#123;<br>    SListNode *newNode = (SListNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(SListNode));<br>    <span class="hljs-keyword">if</span> (newNode == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;内存申请失败&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    newNode-&gt;data = x;<br>    newNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> newNode;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>插入操作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 插入头插，尾插，指定pos前插，指定pos后插</span><br><span class="hljs-comment">// 单链表头插法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SLT_PushFront</span><span class="hljs-params">(SListNode **pphead, SLTData x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pphead);<br>    SListNode *newnode = <span class="hljs-built_in">SLTNode_Create</span>(x);<br>    newnode-&gt;next = *pphead;<br>    *pphead = newnode;<br>&#125;<br><br><span class="hljs-comment">// 单链表尾插法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SLT_PushBack</span><span class="hljs-params">(SListNode **pphead, SLTData x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pphead); <span class="hljs-comment">// 断言，验证pphead的合法性</span><br>    SListNode *newnode = <span class="hljs-built_in">SLTNode_Create</span>(x);<br>    <span class="hljs-comment">// 1.链表为空</span><br>    <span class="hljs-keyword">if</span> (*pphead == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        *pphead = newnode;<br>        <span class="hljs-comment">// 不需要让newnode-&gt;next=NULL,在SLTNode_Create函数中已经进行过此操作</span><br>    &#125;<br>    <span class="hljs-comment">// 2.链表不为空</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// 找到链表的尾巴tail</span><br>        SListNode *tail = *pphead;<br>        <span class="hljs-keyword">while</span> (tail-&gt;next)<br>        &#123;<br>            tail = tail-&gt;next;<br>        &#125;<br>        tail-&gt;next = newnode;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 单链表在指定pos前插入</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SLTInsertFront</span><span class="hljs-params">(SListNode **pphead, SListNode *pos, SLTData x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pphead);<br>    <span class="hljs-built_in">assert</span>(pos);<br><br>    SListNode *newnode = <span class="hljs-built_in">SLTNode_Create</span>(x);<br>    <span class="hljs-comment">// 头插</span><br>    <span class="hljs-keyword">if</span> ((*pphead)-&gt;next == pos)<br>    &#123;<br>        newnode-&gt;next = *pphead;<br>        *pphead = newnode;<br>    &#125;<br>    <span class="hljs-comment">// 非头插</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        SListNode *prev = *pphead;<br>        <span class="hljs-keyword">while</span> (prev-&gt;next != pos)<br>        &#123;<br>            prev = prev-&gt;next;<br>            <span class="hljs-built_in">assert</span>(prev-&gt;next);<br>        &#125;<br>        newnode-&gt;next = pos;<br>        prev-&gt;next = newnode;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 单链表在指定pos后插入</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SLTInsertBack</span><span class="hljs-params">(SListNode *phead, SListNode *pos, SLTData x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pos);<br>    SListNode *cur = phead;<br>    <span class="hljs-comment">// 防止pos传错了</span><br>    <span class="hljs-keyword">while</span> (cur != pos)<br>    &#123;<br>        cur = cur-&gt;next;<br>        <span class="hljs-built_in">assert</span>(pos);<br>    &#125;<br>    SListNode *newnode = <span class="hljs-built_in">SLTNode_Create</span>(x);<br>    newnode-&gt;next = pos-&gt;next;<br>    pos-&gt;next = newnode;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>删除操作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 删除  头删，尾删，在指定pos删</span><br><span class="hljs-comment">// 单链表头删法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SLT_PopFront</span><span class="hljs-params">(SListNode **pphead)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pphead);<br>    <span class="hljs-built_in">assert</span>(*pphead);<br>    SListNode *cur = *pphead;<br>    *pphead = (*pphead)-&gt;next;<br>    <span class="hljs-built_in">free</span>(cur);<br>    cur = <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// 单链表尾删法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SLT_PopBack</span><span class="hljs-params">(SListNode **pphead)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pphead);<br>    <span class="hljs-built_in">assert</span>(*pphead);<br>    <span class="hljs-comment">// 1.链表只有一个元素</span><br>    <span class="hljs-comment">// 2.链表有两个及两个以上的元素</span><br>    <span class="hljs-keyword">if</span> ((*pphead)-&gt;next == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">free</span>(*pphead);<br>        *pphead = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        SListNode* tail = *pphead;<br>        <span class="hljs-keyword">while</span> (tail-&gt;next-&gt;next)<br>        &#123;<br>        tail = tail-&gt;next;<br>        &#125;<br>        <span class="hljs-built_in">free</span>(tail-&gt;next);<br>        tail-&gt;next = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// 删除某个结点</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SLT_PosErase</span><span class="hljs-params">(SListNode **pphead, SListNode *pos)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pphead);<br>    <span class="hljs-built_in">assert</span>(pos);<br>    <span class="hljs-comment">// 头删</span><br><br>    <span class="hljs-keyword">if</span> (*pphead == pos)<br>    &#123;<br>        SListNode *cur = *pphead;<br>        *pphead = (*pphead)-&gt;next;<br>        <span class="hljs-built_in">free</span>(cur);<br>        cur = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-comment">// 非头删</span><br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        SListNode *prev = *pphead;<br>        <span class="hljs-keyword">while</span> (prev-&gt;next != pos)<br>        &#123;<br>            prev = prev-&gt;next;<br>            <span class="hljs-built_in">assert</span>(prev-&gt;next);<br>        &#125;<br>        prev-&gt;next = pos-&gt;next;<br>        <span class="hljs-built_in">free</span>(pos);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>修改操作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 单链表结点修改</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SLT_Alter</span><span class="hljs-params">(SLTNode *phead, SLTNode *pos, SLTData x)</span></span><br><span class="hljs-function"></span>&#123;<br>    SLTNode *cur = phead;<br>    <span class="hljs-keyword">while</span> (cur != pos)<br>    &#123;<br>        cur = cur-&gt;next;<br>        <span class="hljs-built_in">assert</span>(cur);<br>    &#125;<br>    pos-&gt;data = x;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li>查找操作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 单链表结点查找</span><br><span class="hljs-function">SListNode *<span class="hljs-title">SLT_Search</span><span class="hljs-params">(SListNode *phead, SLTData x)</span></span><br><span class="hljs-function"></span>&#123;<br>    SListNode *cur = phead;<br>    <span class="hljs-keyword">while</span> (cur)<br>    &#123;<br>        <span class="hljs-keyword">if</span> (cur-&gt;data == x)<br>        &#123;<br>            <span class="hljs-keyword">return</span> cur;<br>        &#125;<br>        cur = cur-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="7"><li>单链表打印</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 打印单链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SLT_Print</span><span class="hljs-params">(SListNode *phead)</span></span><br><span class="hljs-function"></span>&#123;<br>    SListNode *cur = phead;<br>    <span class="hljs-keyword">while</span> (cur)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;%d-&gt;&quot;</span> &lt;&lt; cur-&gt;data; <span class="hljs-comment">// 打印当前结点</span><br>        cur = cur-&gt;next;             <span class="hljs-comment">// 指针指向下一个节点</span><br>    &#125;<br>    cout &lt;&lt; <span class="hljs-string">&quot;NULL&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-comment">// 最后打印出来的效果如同 1-&gt;2-&gt;3-&gt;4-&gt;NULL</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="8"><li>单链表销毁</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 销毁链表</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SLT_Destory</span><span class="hljs-params">(SListNode **pphead)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pphead);<br>    SListNode *cur = *pphead;<br>    <span class="hljs-keyword">while</span> (cur)<br>    &#123;<br>        SListNode *next = cur-&gt;next;<br>        <span class="hljs-built_in">free</span>(cur);<br>        cur = next;<br>    &#125;<br>    *pphead = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-双向链表"><a href="#2-2-双向链表" class="headerlink" title="2.2 双向链表"></a>2.2 双向链表</h2><h2 id="2-3-循环链表"><a href="#2-3-循环链表" class="headerlink" title="2.3 循环链表"></a>2.3 循环链表</h2><h2 id="2-4-静态链表"><a href="#2-4-静态链表" class="headerlink" title="2.4 静态链表"></a>2.4 静态链表</h2><h1 id="三-栈"><a href="#三-栈" class="headerlink" title="三.栈"></a>三.栈</h1><p><strong>栈（Stack）</strong>：是限定仅在表尾进行插入删除操作的线性表。栈是一种后进先出的线性表，称为 LIFO 。</p><h2 id="3-1-栈的顺序存储结构"><a href="#3-1-栈的顺序存储结构" class="headerlink" title="3.1 栈的顺序存储结构"></a>3.1 栈的顺序存储结构</h2><ol><li>栈基本参数的定义</li></ol><p>由于静态容量的栈结构实际上并不实用，因此下面主要实现动态容量的顺序栈。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义顺序栈的参数</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Stack_DataType; <span class="hljs-comment">// 栈中元素类型重命名为int</span><br><br><span class="hljs-comment">// 静态容量栈结构</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Stack_Capacity 20 <span class="hljs-comment">// 栈容量设定</span></span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stack</span><br>&#123;<br>    Stack_DataType st[Stack_Capacity]; <span class="hljs-comment">// 定长数组</span><br>    <span class="hljs-type">int</span> top;                           <span class="hljs-comment">// 记录栈顶位置</span><br>&#125; Static_SeqStack;<br><br><span class="hljs-comment">// 动态容量栈结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Stack</span><br>&#123;<br>    Stack_DataType *st; <span class="hljs-comment">// 指向动态开辟的数组</span><br>    <span class="hljs-type">int</span> top;            <span class="hljs-comment">// 记录栈顶位置</span><br>    <span class="hljs-type">int</span> capacity;       <span class="hljs-comment">// 栈容量设定</span><br>&#125; Dynamic_SeqStack;<br></code></pre></td></tr></table></figure><ol start="2"><li>栈的初始化</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stack_Init</span><span class="hljs-params">(DynamicStack *dst)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(dst);<br>    dst-&gt;a = <span class="hljs-literal">NULL</span>;<br>    dst-&gt;top = <span class="hljs-number">-1</span>;<br>    dst-&gt;capacity = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>栈的销毁</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 销毁栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stack_Destroy</span><span class="hljs-params">(DynamicStack *dst)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(dst);<br><br>    <span class="hljs-keyword">if</span> (dst-&gt;a)<br>    &#123;<br>        <span class="hljs-built_in">free</span>(dst-&gt;a);<br>    &#125;<br>    dst-&gt;a = <span class="hljs-literal">NULL</span>;<br>    dst-&gt;top = <span class="hljs-number">-1</span>;<br>    dst-&gt;capacity = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>入栈操作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 入栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stack_Push</span><span class="hljs-params">(DynamicStack *dst, Stack_DataType x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(dst);<br>    <span class="hljs-keyword">if</span> (dst-&gt;top == dst-&gt;capacity - <span class="hljs-number">1</span>) <span class="hljs-comment">// 检查栈空间是否满了</span><br>    &#123;<br>        <span class="hljs-comment">// 如果栈原始容量为0，新容量设为4，否则设为原始容量的2倍</span><br>        <span class="hljs-type">int</span> newcapacity = (dst-&gt;capacity == <span class="hljs-number">0</span>) ? <span class="hljs-number">4</span> : (dst-&gt;capacity) * <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">// 扩容至新容量</span><br>        Stack_DataType *temp = (Stack_DataType *)<span class="hljs-built_in">realloc</span>(dst-&gt;a, newcapacity * <span class="hljs-built_in">sizeof</span>(Stack_DataType));<br>        <span class="hljs-keyword">if</span> (temp == <span class="hljs-literal">NULL</span>)<br>        &#123;<br>            <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;申请内存失败&quot;</span>);<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>        &#125;<br>        dst-&gt;a = temp;<br>        <span class="hljs-comment">// 更新容量</span><br>        dst-&gt;capacity = newcapacity;<br>    &#125;<br>    dst-&gt;top++;           <span class="hljs-comment">// 栈顶指针加一</span><br>    dst-&gt;a[dst-&gt;top] = x; <span class="hljs-comment">// 将新增元素放入栈顶空间</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>出栈操作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 出栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Stack_Pop</span><span class="hljs-params">(DynamicStack *dst)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(dst);<br>    <span class="hljs-built_in">assert</span>(dst-&gt;top != <span class="hljs-number">-1</span>); <span class="hljs-comment">// 栈不能为空</span><br><br>    dst-&gt;top--; <span class="hljs-comment">// 栈顶指针减一</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li>检测栈是否为空</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 检测栈是否为空，如果为空返回true，否则返回NULL</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Stack_isEmpty</span><span class="hljs-params">(DynamicStack *dst)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(dst);<br>    <span class="hljs-keyword">return</span> dst-&gt;top == <span class="hljs-number">-1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="7"><li>获取栈中有效元素个数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 获取栈中有效元素个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Stack_Size</span><span class="hljs-params">(DynamicStack *dst)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(dst);<br>    <span class="hljs-keyword">return</span> dst-&gt;top + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="8"><li>获取栈顶元素</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 获取栈顶元素</span><br><span class="hljs-function">Stack_DataType <span class="hljs-title">Stack_Top</span><span class="hljs-params">(DynamicStack *dst)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(dst);<br>    <span class="hljs-built_in">assert</span>(!<span class="hljs-built_in">Stack_isEmpty</span>(dst)); <span class="hljs-comment">// 栈不能为空</span><br><br>    <span class="hljs-keyword">return</span> dst-&gt;a[dst-&gt;top];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-栈的链式存储结构"><a href="#3-2-栈的链式存储结构" class="headerlink" title="3.2 栈的链式存储结构"></a>3.2 栈的链式存储结构</h2><p>由于栈只允许在表尾进行插入和删除元素操作。可以将单链表的尾部作为栈底，头部作为栈顶，方便插入和删除（进栈头插，出栈头删），这样头指针 head 和栈顶指针 top 就合二为一。</p><ol><li>栈的基本参数定义</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义链式栈的参数</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> LinkStack_DataType; <span class="hljs-comment">// 队列中元素类型重命名为int</span><br><span class="hljs-comment">// 定义链式栈的链表结点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LinkStackNode</span><br>&#123;<br><br>    LinkStack_DataType data; <span class="hljs-comment">// 数据域</span><br>    LinkStackNode *next;     <span class="hljs-comment">// 指针域</span><br>&#125; *LinkStackPtr;<br><br><span class="hljs-comment">// 定义栈的链式结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">LinkStack</span><br>&#123;<br>    LinkStackNode *top;          <span class="hljs-comment">// 栈顶结点(表示整个链表的内存初始地址)</span><br>    LinkStack_DataType capacity; <span class="hljs-comment">// 栈容量</span><br>&#125; LinkStack;<br></code></pre></td></tr></table></figure><ol start="2"><li>链式栈的初始化</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化链式栈</span><br><span class="hljs-function">LinkStack *<span class="hljs-title">LinkStack_Init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>    LinkStack *mystack = (LinkStack *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LinkStack));<br>    mystack-&gt;capacity = <span class="hljs-number">0</span>;<br>    LinkStackNode *newNode = (LinkStackNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LinkStackNode));<br>    newNode-&gt;next = <span class="hljs-literal">NULL</span>;<br>    mystack-&gt;top = newNode;<br>    <span class="hljs-keyword">return</span> mystack;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>链式栈的摧毁</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 摧毁链式栈</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LinkStack_Destory</span><span class="hljs-params">(LinkStack *ls)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(ls);<br>    LinkStackNode *cur = ls-&gt;top;<br>    <span class="hljs-keyword">while</span> (cur)<br>    &#123;<br>        LinkStackNode *next = cur-&gt;next;<br>        <span class="hljs-built_in">free</span>(cur);<br>        cur = next;<br>    &#125;<br>    <span class="hljs-built_in">free</span>(ls);<br>    ls = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>入栈操作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 入栈操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LinkStack_Push</span><span class="hljs-params">(LinkStack *mystack, LinkStack_DataType data)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 创建一个临时结点</span><br>    LinkStackNode *newNode = (LinkStackNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(LinkStackNode));<br>    newNode-&gt;data = data;<br>    newNode-&gt;next = mystack-&gt;top-&gt;next;<br>    mystack-&gt;top-&gt;next = newNode;<br>    mystack-&gt;capacity++;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>出栈操作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 出栈操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">LinkStack_Pop</span><span class="hljs-params">(LinkStack *mystack)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (mystack-&gt;capacity == <span class="hljs-number">0</span>)<br>    &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;无法出栈&quot;</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-comment">// 创建一个临时结点</span><br>        LinkStackNode *newNode = mystack-&gt;top-&gt;next;<br>        mystack-&gt;top-&gt;next = newNode-&gt;next;<br>        newNode = <span class="hljs-literal">NULL</span>;<br>        <span class="hljs-built_in">free</span>(newNode);<br>        mystack-&gt;capacity--;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li>判断栈是否为空</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 判断栈是否为空</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">LinkStack_isEmpty</span><span class="hljs-params">(LinkStack *mystack)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">return</span> (<span class="hljs-type">bool</span>)!mystack-&gt;capacity;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="7"><li>获取栈顶元素</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 获取栈顶元素</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LinkStack_Top</span><span class="hljs-params">(LinkStack *mystack)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">if</span> (mystack-&gt;capacity == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> mystack-&gt;top-&gt;next-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="8"><li>获取栈中有效元素个数</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 获取栈中有效元素个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">LinkStack_Size</span><span class="hljs-params">(LinkStack *mystack)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(mystack);<br>    <span class="hljs-keyword">return</span> mystack-&gt;capacity;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-3-栈的应用"><a href="#3-3-栈的应用" class="headerlink" title="3.3 栈的应用"></a>3.3 栈的应用</h2><p>栈可应用于递归和四则运算</p><blockquote><p>注：递归和迭代的区别</p><ul><li><strong>递归</strong>：要解决一个问题，递归的思想是将这一问题通过递推式转换成另一小范围的表示，通过层层递归到达解决一个递归尽头的问题，然后层层返回解决这一问题</li><li><strong>迭代</strong>：要解决一个问题，迭代的思想是初始条件，通过初始条件以及一个递推式一次一次迭代，最终解决这一问题</li></ul></blockquote><h1 id="四-队列"><a href="#四-队列" class="headerlink" title="四.队列"></a>四.队列</h1><p><strong>队列（Queue）</strong>：是限定表的一端进行插入操作，表的另一端进行删除操作的线性表。队列是一种先进先出的线性表，称为 FIFO 。</p><ol><li>队列的顺序结构</li></ol><p>入队操作，不需要移动任何元素，时间复杂度为O(1)</p><p>出队操作，所有元素需要往前移动，时间复杂度为O(N)</p><ol start="2"><li>队列的链式结构</li></ol><p>首先我们定义两个指针，队头指针指向第一个节点，队尾指针指向尾节点</p><p>入队操作（尾插），时间复杂度为O(1)</p><p>出队操作（头删），时间复杂度为O(1)</p><h2 id="4-1-队列的顺序存储结构"><a href="#4-1-队列的顺序存储结构" class="headerlink" title="4.1 队列的顺序存储结构"></a>4.1 队列的顺序存储结构</h2><ol><li>顺序队列的定义</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义顺序队列的参数</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Queue_DataType; <span class="hljs-comment">// 队列中元素类型重命名为int</span><br><br><span class="hljs-comment">// 静态容量队列结构</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Queue_Capacity 20 <span class="hljs-comment">// 队列容量设定</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">StaticSeqQueue</span><br>&#123;<br>    Queue_DataType *base; <span class="hljs-comment">// 队列基地址</span><br>    <span class="hljs-type">int</span> front;            <span class="hljs-comment">// 记录队首</span><br>    <span class="hljs-type">int</span> rear;             <span class="hljs-comment">// 记录队尾</span><br>&#125; SeqQueue;<br></code></pre></td></tr></table></figure><ol start="2"><li>初始化顺序队列</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化顺序队列</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SeqQueue_Init</span><span class="hljs-params">(SeqQueue *dQ)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 为顺序队列开辟存储空间</span><br>    dQ-&gt;base = (Queue_DataType *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(Queue_DataType) * Queue_Capacity);<br>    <span class="hljs-built_in">assert</span>(dQ-&gt;base != <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-comment">// 初始化时，队头和队尾都在0位置</span><br>    dQ-&gt;front = dQ-&gt;rear = <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>入队操作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 入队操作</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SeqQueue_Push</span><span class="hljs-params">(SeqQueue *sQ, Queue_DataType x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 判断队列是否还有存储空间</span><br>    <span class="hljs-keyword">if</span> (sQ-&gt;rear &gt;= Queue_Capacity)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 如果还有存储空间，将数据入队</span><br>    sQ-&gt;base[sQ-&gt;rear++] = x;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>出队操作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 出队</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SeqQueue_pop</span><span class="hljs-params">(SeqQueue *sQ)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 判断队列中的元素是否为空</span><br>    <span class="hljs-keyword">if</span> (sQ-&gt;front == sQ-&gt;rear)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 如果队列中的元素不为空，进行出队操作</span><br>    sQ-&gt;front++;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>队列容量和队首元素的访问</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 获取队列元素个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">SeqQueue_Capacity</span><span class="hljs-params">(SeqQueue *sQ)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">//也可以将Capacity字段直接整合到队列结构体中</span><br>    <span class="hljs-comment">// 将尾指针位置减去头指针的位置就是队列中元素的个数</span><br>    <span class="hljs-keyword">return</span> (sQ-&gt;rear - sQ-&gt;front);<br>&#125;<br><br><span class="hljs-comment">// 获取队首元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SeqQueue_Front</span><span class="hljs-params">(SeqQueue *sQ, Queue_DataType *v)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 判断队列中的元素是否为空</span><br>    <span class="hljs-keyword">if</span> (sQ-&gt;front == sQ-&gt;rear)<br>        <span class="hljs-keyword">return</span>;<br>    <span class="hljs-comment">// 如果队列中的元素不为空，取出队头元素</span><br>    *v = sQ-&gt;base[sQ-&gt;front];<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="6"><li>打印顺序队列的元素</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 打印顺序队列中的元素</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SeqQueue_Print</span><span class="hljs-params">(SeqQueue *sQ)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 遍历队头到队尾中的每个元素，并将其打印输出</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = sQ-&gt;front; i &lt; sQ-&gt;rear; ++i)<br>    &#123;<br>        cout &lt;&lt; sQ-&gt;base[i] &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    cout &lt;&lt; endl;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="7"><li>队列的清空与销毁</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 清空队列</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SeqQueue_Clear</span><span class="hljs-params">(SeqQueue *sQ)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 将队头指针和队尾指针都重置为0</span><br>    sQ-&gt;front = sQ-&gt;rear = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 销毁队列</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">SeqQueue_Destroy</span><span class="hljs-params">(SeqQueue *sQ)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-comment">// 释放队列的存储空间</span><br>    <span class="hljs-built_in">free</span>(sQ-&gt;base);<br>    <span class="hljs-comment">// 将队列空间的位置指针置空</span><br>    sQ-&gt;base = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-2-队列的链式存储结构"><a href="#4-2-队列的链式存储结构" class="headerlink" title="4.2 队列的链式存储结构"></a>4.2 队列的链式存储结构</h2><ol><li>链式队列结点定义</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 队列的定义</span><br><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Queue_DataType; <span class="hljs-comment">// 队列中元素类型重命名为int</span><br><br><span class="hljs-comment">// 定义队列链式结点</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">QueueNode</span><br>&#123;<br>    Queue_DataType data;    <span class="hljs-comment">// 节点数据</span><br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">QueueNode</span> *next; <span class="hljs-comment">// 节点指针</span><br>&#125; QueueNode;<br><br><span class="hljs-comment">// 定义队列的链式结构</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">QueuePtr</span><br>&#123;<br>    QueueNode *phead; <span class="hljs-comment">// 队头指针</span><br>    QueueNode *ptail; <span class="hljs-comment">// 队尾指针</span><br>&#125; LinkQueue;<br><br></code></pre></td></tr></table></figure><ol start="2"><li>判定队列是否为空</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 检查队列是否为空，若为空返回true，否则返回false</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">Queue_isEmpty</span><span class="hljs-params">(LinkQueue *pQ)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pQ);<br>    <span class="hljs-keyword">return</span> pQ-&gt;phead == <span class="hljs-literal">NULL</span> &amp;&amp; pQ-&gt;ptail == <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>链式队列的初始化</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 初始化队列</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Queue_Init</span><span class="hljs-params">(LinkQueue *pQ)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pQ);<br>    <span class="hljs-comment">// 队列为空</span><br>    pQ-&gt;phead = pQ-&gt;ptail = <span class="hljs-literal">NULL</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="4"><li>链式队列的销毁</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 销毁队列</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Queue_Destroy</span><span class="hljs-params">(LinkQueue *pQ)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pQ);<br><br>    QueueNode *cur = pQ-&gt;phead;<br>    <span class="hljs-keyword">while</span> (cur) <span class="hljs-comment">// 遍历链式队列</span><br>    &#123;<br>        QueueNode *next = cur-&gt;next;<br>        <span class="hljs-built_in">free</span>(cur);<br>        cur = next;<br>    &#125;<br>    cur = <span class="hljs-literal">NULL</span>;<br>    pQ-&gt;phead = pQ-&gt;ptail = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 队列为空</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li>链式队列的入队操作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 入队（尾插法）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Queue_Push</span><span class="hljs-params">(LinkQueue *pQ, Queue_DataType x)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pQ);<br><br>    QueueNode *newnode = (QueueNode *)<span class="hljs-built_in">malloc</span>(<span class="hljs-built_in">sizeof</span>(QueueNode)); <span class="hljs-comment">// 动态申请一个节点</span><br>    <span class="hljs-keyword">if</span> (newnode == <span class="hljs-literal">NULL</span>)<br>    &#123;<br>        <span class="hljs-built_in">perror</span>(<span class="hljs-string">&quot;动态申请失败&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">-1</span>);<br>    &#125;<br>    newnode-&gt;data = x;<br>    newnode-&gt;next = <span class="hljs-literal">NULL</span>; <span class="hljs-comment">// 尾节点next指针置空</span><br><br>    <span class="hljs-keyword">if</span> (pQ-&gt;phead == <span class="hljs-literal">NULL</span>) <span class="hljs-comment">// 队列为空</span><br>    &#123;<br>        pQ-&gt;phead = newnode;<br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">// 队列不为空</span><br>    &#123;<br>        pQ-&gt;ptail-&gt;next = newnode;<br>    &#125;<br>    pQ-&gt;ptail = newnode; <span class="hljs-comment">// 更新队尾指针</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="6"><li>链式队列的出队操作</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 出队（头删法）</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">Queue_Pop</span><span class="hljs-params">(LinkQueue *pQ)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pQ);<br>    <span class="hljs-built_in">assert</span>(!<span class="hljs-built_in">Queue_isEmpty</span>(pQ)); <span class="hljs-comment">// 队列不能为空</span><br><br>    <span class="hljs-keyword">if</span> (pQ-&gt;phead == pQ-&gt;ptail) <span class="hljs-comment">// 队列中只有一个节点</span><br>    &#123;<br>        <span class="hljs-built_in">free</span>(pQ-&gt;phead);<br>        pQ-&gt;phead = pQ-&gt;ptail = <span class="hljs-literal">NULL</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        QueueNode *next = pQ-&gt;phead-&gt;next; <span class="hljs-comment">// 记录头节点的直接后继</span><br>        <span class="hljs-built_in">free</span>(pQ-&gt;phead);                   <span class="hljs-comment">// 释放头节点</span><br>        pQ-&gt;phead = next;                  <span class="hljs-comment">// 更新队头指针</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="7"><li>链式队列元素个数统计</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 获取队列元素个数</span><br><span class="hljs-comment">// 如果会频繁调用此接口函数，可以在QueuePtr结构体中加一个size字段记录数据个数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">Queue_Size</span><span class="hljs-params">(LinkQueue *pQ)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pQ);<br>    <span class="hljs-type">int</span> size = <span class="hljs-number">0</span>;<br>    QueueNode *cur = pQ-&gt;phead;<br>    <span class="hljs-keyword">while</span> (cur) <span class="hljs-comment">// 遍历链表</span><br>    &#123;<br>        size++;<br>        cur = cur-&gt;next;<br>    &#125;<br>    <span class="hljs-keyword">return</span> size;<br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="8"><li>链式队列的访问</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 链式队列元素查询</span><br><span class="hljs-comment">// 获取队头元素</span><br><span class="hljs-function">Queue_DataType <span class="hljs-title">QueueFront</span><span class="hljs-params">(LinkQueue *pQ)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pQ);<br>    <span class="hljs-built_in">assert</span>(!<span class="hljs-built_in">Queue_isEmpty</span>(pQ)); <span class="hljs-comment">// 队列不能为空</span><br><br>    <span class="hljs-keyword">return</span> pQ-&gt;phead-&gt;data;<br>&#125;<br><br><span class="hljs-comment">// 队列为空是获取不了队尾元素的</span><br><span class="hljs-comment">// 获取队尾元素</span><br><span class="hljs-function">Queue_DataType <span class="hljs-title">QueueBack</span><span class="hljs-params">(LinkQueue *pQ)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-built_in">assert</span>(pQ);<br>    <span class="hljs-built_in">assert</span>(!<span class="hljs-built_in">Queue_isEmpty</span>(pQ)); <span class="hljs-comment">// 队列不能为空</span><br><br>    <span class="hljs-keyword">return</span> pQ-&gt;ptail-&gt;data;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-3-循环队列"><a href="#4-3-循环队列" class="headerlink" title="4.3 循环队列"></a>4.3 循环队列</h2><p>循环队列就是将正常的队列的队首与队尾相连形成一个循环。同普通队列一样，循环队列依然存在顺序存储结构与链式存储结构，本文便不作更多代码阐述。</p><blockquote><p>注意：</p><ol><li><p>循环队列中，tail 永远指向最后一个元素的下一个位置；</p></li><li><p>循环队列中，永远要多开一个存储空间。</p></li></ol></blockquote><h1 id="五-串（字符串）"><a href="#五-串（字符串）" class="headerlink" title="五.串（字符串）"></a>五.串（字符串）</h1><p><strong>串（String）</strong>：是由另个或者多个多个字符组成的有限序列，又称字符串。零个字符的串称为空串，可直接用 <strong>“”</strong> 表示。</p><blockquote><p>注：区分 char[]（或者char *） 与 string：</p><ul><li><p>char[]（char *）是一组 char 类型字符变量组成的，它就是一个数组，每个单元里面放一个字符数据；</p></li><li><p>string 是一个整体，以字符 ‘\0’ 作为分隔标识结尾，而且它还有很多<strong>类函数</strong>可以调用使用。</p></li></ul></blockquote><p>C++中有大量的字符串操作函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">//复制字符串 s2 到字符串 s1</span><br><span class="hljs-built_in">strcpy</span>(s1, s2);<br><br><span class="hljs-comment">//连接字符串 s2 到字符串 s1 的末尾</span><br><span class="hljs-built_in">strcat</span>(s1, s2);<br><br><span class="hljs-comment">//返回字符串 s1 的长度</span><br><span class="hljs-built_in">strlen</span>(s1);<br><br><span class="hljs-comment">//如果 s1 和 s2 是相同的，则返回 0</span><br><span class="hljs-comment">//如果 s1&lt;s2 则返回值小于 0</span><br><span class="hljs-comment">//如果 s1&gt;s2 则返回值大于 0</span><br><span class="hljs-built_in">strcmp</span>(s1, s2);<br><br><span class="hljs-comment">//返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置</span><br><span class="hljs-built_in">strchr</span>(s1, ch);<br><br><span class="hljs-comment">//返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置</span><br><span class="hljs-built_in">strstr</span>(s1, s2);<br></code></pre></td></tr></table></figure><h2 id="5-1-串的顺序存储结构"><a href="#5-1-串的顺序存储结构" class="headerlink" title="5.1 串的顺序存储结构"></a>5.1 串的顺序存储结构</h2><p>串的顺序存储结构就是将所有字符数据元素保存在一个数组当中并以“\0”来表示字符串的结束。注意，字符串的长度加“\0”的长度不应当超过定义数组本身的长度。</p><h2 id="5-2-串的链式存储结构"><a href="#5-2-串的链式存储结构" class="headerlink" title="5.2 串的链式存储结构"></a>5.2 串的链式存储结构</h2><p>串的链式存储结构与链式表是相似的，由于串的结构中每个数据元素都是一个字符。</p><h1 id="六-树"><a href="#六-树" class="headerlink" title="六.树"></a>六.树</h1><p><strong>树（Tree）</strong>：是 n（n≥0）个节点的有限集。树结构是典型的<strong>一对多</strong>关系。</p><p>当 n &#x3D; 0 时称为空树；</p><p>当 n ≠ 0 时的非空树中：</p><ul><li>有且仅有一个特定的节点称为根节点（Root）；</li><li>当 n &gt; 1 时，其余节点可以分割成若干个互不相交的子集，其每个集合本身也为一棵树，这棵树便是根的子树（SubTree）。</li></ul><h1 id="七-堆（完全二叉树）"><a href="#七-堆（完全二叉树）" class="headerlink" title="七.堆（完全二叉树）"></a>七.堆（完全二叉树）</h1><p><strong>堆（Heap）</strong>：堆本质上就是一棵完全二叉树。与内存管理的堆区不同，这儿是说的是一种数据结构。</p><h2 id="7-1-堆的结构性质"><a href="#7-1-堆的结构性质" class="headerlink" title="7.1 堆的结构性质"></a>7.1 堆的结构性质</h2><p>堆一般使用数组来实现，即利用数组的索引来表示节点之间的关系。因此堆具有如下<strong>性质</strong>：</p><ol><li>根节点索引一般为 0 ；</li><li>对于堆中任意非根节点 i ，它的左孩子节点为 2 i + 1 ，右孩子节点为 2 i + 2 ，父节点为 ( i - 1 ) &#x2F; 2 ；</li><li>每个节点的左右子树也都必须是一个堆；</li><li>小堆不是升序，大堆不是降序。</li></ol><p>堆的实现参考如下链接：<a href="https://blog.csdn.net/weixin_48025315/article/details/123165836">堆（Heap）</a></p><h1 id="八-哈希"><a href="#八-哈希" class="headerlink" title="八.哈希"></a>八.哈希</h1><p><strong>哈希（Hash）</strong>：哈希表，又称为散列表，是根据码值访问的数据结构。哈希表的码就是数组的索引下标，然后通过码下标就可以直接访问数组中的数据元素。</p><p>C++ 中的哈希集合为 unordered_set，可以查找元素是否在集合中。如需同时存储键和值，则就要用 unordered_map 。</p><h2 id="8-1-哈希函数设计原则"><a href="#8-1-哈希函数设计原则" class="headerlink" title="8.1 哈希函数设计原则"></a>8.1 哈希函数设计原则</h2><p>哈希函数的设计原则：</p><ol><li><p>哈希函数的定义域必须包括需要存储的全部关键码，有m个地址的散列表的值域在 0 到 m-1 之间</p></li><li><p>哈希函数所计算的地址能均匀分布在整个空间中且尽量简单</p></li></ol><h2 id="8-2-常见哈希函数"><a href="#8-2-常见哈希函数" class="headerlink" title="8.2 常见哈希函数"></a>8.2 常见哈希函数</h2><p>常见的哈希构造函数：</p><ol><li>直接寻址法<br>取关键字的某个线性函数为哈希函数：H a s h ( k e y ) &#x3D; A ∗ k e y + B<br>优点：简单、均匀<br>缺点：需要事先知道关键字的分布情况<br>场景：适合查找比较小且连续的情况</li><li>除留余数法<br>设哈希表中允许的地址数为 m ，取一个不大于 m 且最接近或者等于m的质数 p 作为除数，<br>然后按照哈希函数：H a s h ( k e y ) &#x3D; k e y % p ( p &lt; &#x3D; m ) 将关键码转换成哈希地址</li><li>平方取中法<br>假设关键字为 1234 ，对它平方就是 1522756 ，抽取中间的 3 位 277 作为哈希地址；再比如关键字为 4321 ，对它平方就是 18671041 ，抽取中间的 3 位 671（或710）作为哈希地址。平方取中法比较适合：不知道关键字的分布，而位数又不是很大的情况。</li><li>折叠法<br>折叠法是将关键字从左到右分割成位数相等的几部分（最后一部分位数可以短些），然后将这几部分叠加求和，并按哈希表表长，取后几位作为哈希地址。</li><li>随机数法<br>选择一个随机函数，取关键字的随机函数值为它的哈希地址，即 H a s h ( k e y ) &#x3D; r a n d o m ( k e y )，其中 random 为随机数函数。</li><li>如果关键字由多位字符或者数字组成，就可以考虑抽取其中的两位或者多位作为该关键字对应的哈希地址，在取法上尽量选择变化较多的位，避免冲突发生。</li></ol><blockquote><p>注：哈希函数设计越精妙，就越不容易产生哈希冲突，尽管如此依然无法完全避免哈希冲突。</p></blockquote><h1 id="九-图"><a href="#九-图" class="headerlink" title="九.图"></a>九.图</h1><p><strong>图（Graph）</strong>：是由定点的有穷非空集合与顶点之间边的集合组成，通常可表示为 G(V,E) ，其中 G 表示一个图，V 表示 G 当中定点的集合，E 表示 G 当中边的集合。图结构是典型的<strong>多对多</strong>关系。更详细的内容可参照如下链接：<a href="https://blog.csdn.net/Real_Fool_/article/details/114141377?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522169392471216800227439245%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=169392471216800227439245&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-114141377-null-null.142%5Ev93%5Einsert_down1&utm_term=graph&spm=1018.2226.3001.4187">图(Graph)</a></p><p>图的类型包括：有向图、无向、简单图、完全图（简单完全图）、多重图。</p><h2 id="9-1-图的存储"><a href="#9-1-图的存储" class="headerlink" title="9.1 图的存储"></a>9.1 图的存储</h2><p>图的任意两个顶点之间都可能存在联系，因此图无法用较为简单的顺序存储结构表示。而多重链表的方式，要么浪费众多存储单元，要么操作不方便。因此诞生如下五种图的存储结构：邻接矩阵，邻接表，十字链表，邻接多重表，边集数组。</p><ol><li>邻接矩阵：存储方式是用两个数组来表示图。一个一维数组存储顶点信息，一个二维数组存储图中边的信息；</li><li>邻接表：存储方式是用一个一维数组存储顶点信息，图中每个顶点形成的邻接点构成一个线性表（由于邻接点个数不定，则用单链表存储）；</li><li>十字链表：是邻接表与逆邻接表结合形成的；</li><li>邻接多重表：是针对有向图的邻接表处理；</li><li>边集数组：由两个一维数组构成。一个存储顶点信息，一个存储边的信息。而这个边的数组每个数据元素由一条边的起点下标（Begin）、终点下标（End）、权重（Weight）组成。</li></ol><h2 id="9-2-图的遍历"><a href="#9-2-图的遍历" class="headerlink" title="9.2 图的遍历"></a>9.2 图的遍历</h2><p>图的遍历通常是从某一顶点出发访问遍所有其余顶点，且使每个顶点仅被访问一遍。对于图的遍历，为了避免陷入回路的死循环，通常采用如下两种访问方式：</p><ol><li><strong>深度优先遍历（Depth_First_Search）</strong>：简称 DFS 搜索算法。具体操作为：从图中某一个顶点 v 出发访问此顶点，然后从 v 的为被访问的邻接点出发深度优先遍历图，直到图中所有和 v 有路径想通的顶点都被访问到。若图中有未被访问，则另外选取未曾访问的顶点出发重复如上操作直至图中所有顶点均被访问到。</li><li><strong>广度优先遍历（Breadth_First_Search）</strong>：简称 BFS 搜索算法，此种遍历方式类似于树的层序遍历。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>C/CPP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git学习</title>
    <link href="/2022/03/27/Git%20%E5%AD%A6%E4%B9%A0/"/>
    <url>/2022/03/27/Git%20%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="一-Git简介"><a href="#一-Git简介" class="headerlink" title="一.Git简介"></a>一.Git简介</h1><h2 id="1-1-Git工作机制"><a href="#1-1-Git工作机制" class="headerlink" title="1.1 Git工作机制"></a>1.1 Git工作机制</h2><p>Git包含两部分仓库，一个是本地仓库，一个是远程仓库。其基本工作机制如下图所示：</p><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Git%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B.png" alt="Git工作机制"></p><hr><h1 id="二-本地仓库"><a href="#二-本地仓库" class="headerlink" title="二.本地仓库"></a>二.本地仓库</h1><p>本地仓库的操作包含分支内操作以及分支间操作。</p><h2 id="2-1-Git分支内操作常用命令"><a href="#2-1-Git分支内操作常用命令" class="headerlink" title="2.1 Git分支内操作常用命令"></a>2.1 Git分支内操作常用命令</h2><table><thead><tr><th align="center">命令名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git config –global user.name “用户名”</td><td align="center">设置用户签名（用户名）</td></tr><tr><td align="center">git config –global user.email “邮箱号”</td><td align="center">设置用户签名（邮箱名）</td></tr><tr><td align="center">git init</td><td align="center">初始化本地库</td></tr><tr><td align="center">git status</td><td align="center">查看本地库状态</td></tr><tr><td align="center">git add 文件名</td><td align="center">添加到暂存区</td></tr><tr><td align="center">git commit -m “日志信息” 文件名</td><td align="center">提交到本地库</td></tr><tr><td align="center">git reflog</td><td align="center">查看版本信息</td></tr><tr><td align="center">git log</td><td align="center">查看版本详细信息</td></tr><tr><td align="center">get reset –hard 版本号</td><td align="center">回退到指定版本</td></tr></tbody></table><h2 id="2-2-Git分支间操作常用命令"><a href="#2-2-Git分支间操作常用命令" class="headerlink" title="2.2 Git分支间操作常用命令"></a>2.2 Git分支间操作常用命令</h2><table><thead><tr><th align="center">操作名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git branch 分支名</td><td align="center">创建分支</td></tr><tr><td align="center">git branch -v</td><td align="center">查看分支</td></tr><tr><td align="center">git checkout 分支名</td><td align="center">切换分支</td></tr><tr><td align="center">git merge 分支名</td><td align="center">将指定分支合并到当前分支上</td></tr><tr><td align="center">git branch -D 分支名</td><td align="center">明确要删除指定分支</td></tr></tbody></table><h2 id="2-3-什么是分支"><a href="#2-3-什么是分支" class="headerlink" title="2.3 什么是分支"></a>2.3 什么是分支</h2><ol><li>在版本控制过程中，同时推进多个任务，为每个任务，我们就可以创建每个任务的单独分支；</li><li>使用分支意味着程序员可以把自己的工作从开发主线上分离开来，开发自己分支的时候，不会影响主线分支的运行；</li><li>对于初学者而言，分支可以简单理解为副本，一个分支就是一个单独的副本。</li></ol><h2 id="2-4-分支的好处"><a href="#2-4-分支的好处" class="headerlink" title="2.4 分支的好处"></a>2.4 分支的好处</h2><ol><li>同时并行推进多个功能开发，提高开发效率；</li><li>各个分支在开发过程中，如果某一个分支开发失败，不会对其他分支有任何影响。失败的分支删除重新开始即可。</li></ol><hr><h1 id="三-远程仓库"><a href="#三-远程仓库" class="headerlink" title="三.远程仓库"></a>三.远程仓库</h1><p>常用的远程仓库包括GitHub和Gitee。</p><h2 id="3-1-远程仓库的创建"><a href="#3-1-远程仓库的创建" class="headerlink" title="3.1 远程仓库的创建"></a>3.1 远程仓库的创建</h2><ol><li>GitHub仓库的创建</li></ol><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/GitHub%E5%88%9B%E5%BB%BA%E4%BD%A0%E6%96%B0%E4%BB%93%E5%BA%93.png" alt="GitHub创建新仓库"></p><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/GitHub%E4%BB%93%E5%BA%93%E5%88%9B%E5%BB%BA%E6%88%90%E5%8A%9F.png" alt="GitHub创建仓库成功"></p><ol start="2"><li>Gitee仓库的创建</li></ol><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Gitee%E5%88%9B%E5%BB%BA%E6%96%B0%E4%BB%93%E5%BA%93.png" alt="Gitee创建仓库"></p><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Gitee%E4%BB%93%E5%BA%93%E5%88%9B%E5%BB%BA%E6%88%90%E5%8A%9F.png" alt="Gitee创建仓库成功"></p><h2 id="3-2-远程仓库的操作常用命令"><a href="#3-2-远程仓库的操作常用命令" class="headerlink" title="3.2 远程仓库的操作常用命令"></a>3.2 远程仓库的操作常用命令</h2><table><thead><tr><th align="center">命令名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git remote -v</td><td align="center">查看当前所有远程仓库地址别名</td></tr><tr><td align="center">git remote add 别名 远程地址</td><td align="center">给远程仓库地址起别名</td></tr><tr><td align="center">git push 别名 分支</td><td align="center">推送本地仓库的分支内容到远程仓库</td></tr><tr><td align="center">git clone 远程地址</td><td align="center">从远程仓库克隆内容到本地</td></tr><tr><td align="center">git pull 远程库</td><td align="center">将远程仓库对于分支的最新内容拉下来后与当前本地分支直接合并</td></tr><tr><td align="center">git diff</td><td align="center">对比两个版本的差异</td></tr><tr><td align="center">git fetch</td><td align="center">更新远程仓库所包含分支的最新commit-id并记录到.git&#x2F;FETCH_HEAD文件</td></tr></tbody></table><blockquote><p><strong>git diff具体说明</strong>：</p><ul><li>本地工作区和暂存区的diff信息：git diff 或者 git diff file</li><li>暂存区和版本库的diff信息（使用git add 将工作区修改保存到了暂存区后）：git diff –cached</li><li>版本库中不同commit、分支的diff信息（使用git commit 将暂存区修改提交到了版本库）：git diff commit1 commit2 或 git diff branch1 branch2</li></ul></blockquote><hr><h1 id="四-Git团队协作机制"><a href="#四-Git团队协作机制" class="headerlink" title="四.Git团队协作机制"></a>四.Git团队协作机制</h1><h2 id="4-1-团队内协作"><a href="#4-1-团队内协作" class="headerlink" title="4.1 团队内协作"></a>4.1 团队内协作</h2><h2 id="4-2-团队间协作"><a href="#4-2-团队间协作" class="headerlink" title="4.2 团队间协作"></a>4.2 团队间协作</h2><h1 id="五-Git命令汇总"><a href="#五-Git命令汇总" class="headerlink" title="五.Git命令汇总"></a>五.Git命令汇总</h1><h2 id="5-1-分支内操作命令"><a href="#5-1-分支内操作命令" class="headerlink" title="5.1 分支内操作命令"></a>5.1 分支内操作命令</h2><table><thead><tr><th align="center">命令名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git config –global user.name “用户名”</td><td align="center">设置用户签名（用户名）</td></tr><tr><td align="center">git config –global user.email 邮箱号</td><td align="center">设置用户签名（邮箱名）</td></tr><tr><td align="center">git init</td><td align="center">初始化本地库</td></tr><tr><td align="center">git status</td><td align="center">查看本地库状态</td></tr><tr><td align="center">git add 文件名</td><td align="center">添加到暂存区</td></tr><tr><td align="center">git commit -m “日志信息” 文件名</td><td align="center">提交到本地库</td></tr><tr><td align="center">git reflog</td><td align="center">查看版本信息</td></tr><tr><td align="center">git log</td><td align="center">查看版本详细信息</td></tr><tr><td align="center">get reset –hard 版本号</td><td align="center">回退版本</td></tr></tbody></table><h2 id="5-2-分支间操作命令"><a href="#5-2-分支间操作命令" class="headerlink" title="5.2 分支间操作命令"></a>5.2 分支间操作命令</h2><table><thead><tr><th align="center">命令名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git branch {-v}</td><td align="center">查看本地分支</td></tr><tr><td align="center">git branch -r</td><td align="center">查看远程分支</td></tr><tr><td align="center">git branch [name]</td><td align="center">创建本地分支（新分支创建后不会自动切换为当前分支）</td></tr><tr><td align="center">git checkout [name]</td><td align="center">切换本地分支</td></tr><tr><td align="center">git checkout -b [name]</td><td align="center">创建新分支并立即切换到新分支</td></tr><tr><td align="center">git branch -d [name]</td><td align="center">删除本地分支</td></tr><tr><td align="center">git branch -D [name]</td><td align="center">删除本地分支（强制删除）</td></tr><tr><td align="center">git merge [name]</td><td align="center">将名为name的分支合并到当前分支</td></tr><tr><td align="center">git push origin [name]</td><td align="center">创建远程分支（本地分支推送到远程仓库）</td></tr><tr><td align="center">git push origin :heads&#x2F;[name]</td><td align="center">删除远程分支</td></tr><tr><td align="center">git push [remoteName] –delete [name]</td><td align="center">删除远程分支</td></tr><tr><td align="center">git branch -m [oldName] [newName]</td><td align="center">分支重命名</td></tr></tbody></table><h2 id="5-3-远程仓库操作命令"><a href="#5-3-远程仓库操作命令" class="headerlink" title="5.3 远程仓库操作命令"></a>5.3 远程仓库操作命令</h2><table><thead><tr><th align="center">命令名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git <strong>clone</strong> [address]</td><td align="center">从远程仓库克隆到本地</td></tr><tr><td align="center">git <strong>remote</strong> -v</td><td align="center">查看远程仓库</td></tr><tr><td align="center">git remote add [name] [url]</td><td align="center">添加远程仓库并给其取别名</td></tr><tr><td align="center">git remote rm [name]</td><td align="center">删除远程仓库</td></tr><tr><td align="center">git remote set-url –push[name]</td><td align="center">修改远程仓库</td></tr><tr><td align="center">git <strong>pull</strong> [remoteName] [localBranchName]</td><td align="center">拉取远程仓库</td></tr><tr><td align="center">git <strong>push</strong> [remoteName] [localBranchName]</td><td align="center">推送本地仓库的分支内容到远程仓库</td></tr></tbody></table><h2 id="5-4-版本操作命令（很少使用）"><a href="#5-4-版本操作命令（很少使用）" class="headerlink" title="5.4 版本操作命令（很少使用）"></a>5.4 版本操作命令（很少使用）</h2><table><thead><tr><th align="center">命令名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git tag</td><td align="center">查看版本</td></tr><tr><td align="center">git tag [name]</td><td align="center">创建版本</td></tr><tr><td align="center">git tag -d [name]</td><td align="center">删除版本</td></tr><tr><td align="center">git tag -r</td><td align="center">查看远程版本</td></tr><tr><td align="center">git push [remoteName] [localBranchName]</td><td align="center">创建远程版本</td></tr><tr><td align="center">git push origin :refs&#x2F;tags&#x2F;[name]</td><td align="center">删除远程版本</td></tr></tbody></table><h2 id="5-5-子模块操作命令"><a href="#5-5-子模块操作命令" class="headerlink" title="5.5 子模块操作命令"></a>5.5 子模块操作命令</h2><table><thead><tr><th align="center">命令名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git submodule add [url] [path]</td><td align="center">添加子模块</td></tr><tr><td align="center"><strong>git</strong> submodule init</td><td align="center">初始化子模块（只需首次检出仓库时运行一下）</td></tr><tr><td align="center"><strong>git</strong> submodule update</td><td align="center">更新子模块（每次更新或切换分支后都需要运行一下）</td></tr></tbody></table><p>PS:删除子模块的步骤：</p><ul><li><p>git rm –cached [path]</p></li><li><p>编辑 “.gitmodules” 文件，将子模块的相关配置节点删除掉</p></li><li><p>编辑 “. <strong>git</strong>&#x2F;config” 文件，将子模块的相关配置节点删除掉</p></li><li><p>手动删除子模块残留的目录</p></li></ul><h2 id="5-6-Git忽略文件、文件夹不提交"><a href="#5-6-Git忽略文件、文件夹不提交" class="headerlink" title="5.6 Git忽略文件、文件夹不提交"></a>5.6 Git忽略文件、文件夹不提交</h2><p>在仓库根目录下创建名称为“.gitignore”的文件，写入不需要的文件夹名或文件，每个元素占一行即可，如:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># See https://help.github.com/articles/ignoring-files/ for more about ignoring</span><br><span class="hljs-comment"># dependencies</span><br>/node_modules<br><span class="hljs-comment"># production</span><br>/dist<br><span class="hljs-comment"># misc</span><br>.DS_Store<br>npm-debug.log*<br>.idea<br></code></pre></td></tr></table></figure><h2 id="5-7-其他操作命令"><a href="#5-7-其他操作命令" class="headerlink" title="5.7 其他操作命令"></a>5.7 其他操作命令</h2><table><thead><tr><th align="center">命令名称</th><th align="center">作用</th></tr></thead><tbody><tr><td align="center">git reset –hard [version]</td><td align="center">回退到指定版本</td></tr><tr><td align="center">git clone -b [branchName] [address]</td><td align="center">拉取指定分支代码</td></tr><tr><td align="center">git push –set-upstream origin test</td><td align="center">服务上未创建分支时提交代码</td></tr></tbody></table>]]></content>
    
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WSL2 的子系统部署</title>
    <link href="/2022/01/15/Win11%20%E7%8E%AF%E5%A2%83%E4%B8%8B%20WSL2%20%E7%9A%84%E5%AD%90%E7%B3%BB%E7%BB%9F%E9%83%A8%E7%BD%B2/"/>
    <url>/2022/01/15/Win11%20%E7%8E%AF%E5%A2%83%E4%B8%8B%20WSL2%20%E7%9A%84%E5%AD%90%E7%B3%BB%E7%BB%9F%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="一-WSL2-下-Linux-系统的安装"><a href="#一-WSL2-下-Linux-系统的安装" class="headerlink" title="一.WSL2 下 Linux 系统的安装"></a>一.WSL2 下 Linux 系统的安装</h1><h2 id="1-1-先期工作"><a href="#1-1-先期工作" class="headerlink" title="1.1 先期工作"></a>1.1 先期工作</h2><ol><li>打开控制面板选择程序与功能项</li></ol><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E6%8E%A7%E5%88%B6%E9%9D%A2%E6%9D%BF.png" alt="打开控制面板选择程序与功能"></p><ol start="2"><li>打开</li></ol><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E7%A8%8B%E5%BA%8F%E4%B8%8E%E5%8A%9F%E8%83%BD.png" alt="选择启用或者关闭Windows功能"></p><ol start="3"><li>启用虚拟机服务相关配置项</li></ol><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E5%8B%BE%E9%80%89%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9B%B8%E5%85%B3%E9%85%8D%E7%BD%AE%E9%A1%B9.png" alt="启用虚拟机相关服务"></p><h2 id="1-2-检查-WSL2"><a href="#1-2-检查-WSL2" class="headerlink" title="1.2 检查 WSL2"></a>1.2 检查 WSL2</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --update<br></code></pre></td></tr></table></figure><blockquote><p>出现如下问题的解决方法：</p><p>Error: 0x80d03805</p><p>Error code: Wsl&#x2F;UpdatePackage&#x2F;0x80d03805</p><p>重启系统重新输入命令行发现此问题消失</p></blockquote><h2 id="1-3-设置-WSL-的默认版本"><a href="#1-3-设置-WSL-的默认版本" class="headerlink" title="1.3 设置 WSL 的默认版本"></a>1.3 设置 WSL 的默认版本</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --set-default-version 2<br></code></pre></td></tr></table></figure><h2 id="1-4-查看有效分发列表"><a href="#1-4-查看有效分发列表" class="headerlink" title="1.4 查看有效分发列表"></a>1.4 查看有效分发列表</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl -l -o<br></code></pre></td></tr></table></figure><h2 id="1-5-安装指定分发版本的Linux系统"><a href="#1-5-安装指定分发版本的Linux系统" class="headerlink" title="1.5 安装指定分发版本的Linux系统"></a>1.5 安装指定分发版本的Linux系统</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl.exe --install &lt;Distribution Name&gt;<br></code></pre></td></tr></table></figure><p>输入安装完毕后会要求输入<strong>用户名</strong>、设置<strong>密码</strong>及确认</p><h2 id="1-6-更换镜像源"><a href="#1-6-更换镜像源" class="headerlink" title="1.6 更换镜像源"></a>1.6 更换镜像源</h2><p>首先访问配置文件并输入ggdg并回车清空文本内容，然后访问并更换为<a href="https://mirrors.tuna.tsinghua.edu.cn/help/ubuntu/">清华源</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo vim /etc/apt/sources.list<br></code></pre></td></tr></table></figure><p>设置清华源时候进行如下设置：</p><ol><li>是否使用HTTPS勾选<strong>是</strong></li><li>是否使用sudo勾选<strong>是</strong></li><li>Ubuntu版本选择安装的版本，如：Ubuntu-22.04 LTS</li><li>启用源码源勾选<strong>是</strong></li><li>启用proposed勾选<strong>否</strong></li><li>启用源码镜像勾选<strong>是</strong></li></ol><p>然后更新源</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">sudo apt update<br></code></pre></td></tr></table></figure><h2 id="1-7-WSL下的Linux卸载"><a href="#1-7-WSL下的Linux卸载" class="headerlink" title="1.7 WSL下的Linux卸载"></a>1.7 WSL下的Linux卸载</h2><p>首先查看WSL下安装的Linux系统版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --list<br></code></pre></td></tr></table></figure><p>然后选择需要删除卸载的Linux系统版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --unregister &lt;Distribution Name&gt;<br></code></pre></td></tr></table></figure><h2 id="1-8-更改-WSL-默认登录用户"><a href="#1-8-更改-WSL-默认登录用户" class="headerlink" title="1.8 更改 WSL 默认登录用户"></a>1.8 更改 WSL 默认登录用户</h2><ol><li><p>首先关闭WSL子系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --shutdown<br></code></pre></td></tr></table></figure></li><li><p>然后设置登录默认用户</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">&lt;Distribution Name&gt; config --default-user &lt;Username&gt; <span class="hljs-comment"># 如Ubuntu2204.exe</span><br><span class="hljs-comment"># Ubuntu2004.exe config --default-user dustwind</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="1-9-更改-WSL-子系统安装盘符"><a href="#1-9-更改-WSL-子系统安装盘符" class="headerlink" title="1.9 更改 WSL 子系统安装盘符"></a>1.9 更改 WSL 子系统安装盘符</h2><p>由于WSL子系统默认安装在C盘下，然而受限于C盘本身容量过小或者是C盘安装软件过多，则有将WSL子系统安装到其他盘的需求。</p><ol><li><p>首先查看WSL分发版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl -l --all -v<br></code></pre></td></tr></table></figure></li><li><p>然后将分发版系统打包导出到指定盘</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --<span class="hljs-built_in">export</span> &lt;Distribution Name&gt; &lt;Destination Path&gt;<br><span class="hljs-comment"># 举例如下：</span><br><span class="hljs-comment"># wsl --export Ubuntu-20.04 F:\wsl-ubuntu20.04.tar</span><br></code></pre></td></tr></table></figure></li><li><p>注销当前分发版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --unregister &lt;Distribution Name&gt;  <span class="hljs-comment"># 如 Ubuntu-22.04</span><br></code></pre></td></tr></table></figure></li><li><p>在另一个盘重新导入分发版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">wsl --import &lt;Distribution Name&gt; &lt;Destination Path&gt; &lt;Unzip File&gt; --version 2<br><span class="hljs-comment"># 举例如下：</span><br><span class="hljs-comment"># wsl --import Ubuntu-20.04 F:\wsl-ubuntu20.04 F:\wsl-ubuntu20.04.tar --version 2</span><br></code></pre></td></tr></table></figure></li><li><p>设置默认登陆用户为安装时用户名可参考 <strong>1.8</strong> 小节所示</p></li><li><p>删除打包文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">del &lt;FileName&gt; <span class="hljs-comment"># 可以加入绝对路径</span><br><span class="hljs-comment"># 举例如下：</span><br><span class="hljs-comment"># del F:\wsl-ubuntu22.04.tar</span><br></code></pre></td></tr></table></figure></li></ol><blockquote><p><strong>注</strong></p><ol><li>不知道shell参数可使用 wsl –help 命令查看使用</li><li>更详细WSL常用命令汇总可参照：<a href="https://blog.csdn.net/penngo/article/details/129951281?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522170229523816800225597067%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=170229523816800225597067&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-129951281-null-null.142%5Ev96%5Econtrol&utm_term=wsl%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4&spm=1018.2226.3001.4187">WSL 的基本命令</a></li></ol></blockquote><h1 id="二-WSL2-中安装-Linux-桌面环境"><a href="#二-WSL2-中安装-Linux-桌面环境" class="headerlink" title="二.WSL2 中安装 Linux 桌面环境"></a>二.WSL2 中安装 Linux 桌面环境</h1><p>桌面安装提供如下两种方式，首选第一个安装方式</p><ol><li><a href="https://blog.csdn.net/weixin_44478077/article/details/128723158?spm=1001.2014.3001.5506">WSL2 Ubuntu+gnome图形界面的安装血泪史（亲测有效）</a></li><li><a href="https://blog.csdn.net/m0_51194302/article/details/127891929?spm=1001.2014.3001.5506">wsl安装ubuntu并设置gnome图形界面详细步骤（win11+ubuntu18）</a></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Linux</tag>
      
      <tag>WSL</tag>
      
      <tag>Windows</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySql学习</title>
    <link href="/2021/03/31/MySQL%20%E5%AD%A6%E4%B9%A0/"/>
    <url>/2021/03/31/MySQL%20%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h1><h2 id="一-通用语法及分类"><a href="#一-通用语法及分类" class="headerlink" title="一.通用语法及分类"></a>一.通用语法及分类</h2><ul><li>DDL（Data Definition Language）: 数据<strong>定义</strong>语言，用来定义数据库对象（数据库、表、字段）。常用的语句关键字主要包括 create、drop、alter等。</li><li>DML（Data Manipulation Language）: 数据<strong>操作</strong>语言，用来对数据库表中的数据进行增删改。常用的语句关键字主要包括 insert、delete、udpate等。</li><li>DQL（Data Query Language）: 数据<strong>查询</strong>语言，用来查询数据库中表的记录。常用的语句关键字主要包括 select、from、where等。</li><li>DCL（Data Control Language）: 数据<strong>控制</strong>语言，用来创建数据库用户、控制数据库的控制权限。主要的语句关键字包括 grant、revoke 等。</li></ul><h3 id="MySQL-的数据类型"><a href="#MySQL-的数据类型" class="headerlink" title="MySQL 的数据类型"></a>MySQL 的数据类型</h3><ol><li>数值类型</li></ol><table><thead><tr><th align="center">类型</th><th align="center">大小</th><th align="center">有符号范围（Signed）</th><th align="center">无符号范围（Unsigned）</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">TINYINT</td><td align="center">1 Byte</td><td align="center">(-128，127)</td><td align="center">(0 ，255)</td><td align="center">小整数值</td></tr><tr><td align="center">SMALLINT</td><td align="center">2 Bytes</td><td align="center">(-32768，32767)</td><td align="center">(0 ，65535)</td><td align="center">大整数值</td></tr><tr><td align="center">MEDIUMINT</td><td align="center">3 Bytes</td><td align="center">(-8388608，8388607)</td><td align="center">(0 ，16777215)</td><td align="center">大整数值</td></tr><tr><td align="center">INT或者INTEGER</td><td align="center">4 Bytes</td><td align="center">(-2147483648，2147483647)</td><td align="center">(0 ，4294967295)</td><td align="center">大整数值</td></tr><tr><td align="center">BIGINT</td><td align="center">8 Bytes</td><td align="center">(-2^63 ，2^63 -1)</td><td align="center">(0，2^64-1)</td><td align="center">极大整数值</td></tr><tr><td align="center">FLOAT</td><td align="center">4 Bytes</td><td align="center">(-3.402823466 E+38，3.402823466351 E+38)</td><td align="center">0 和 (1.175494351 E-38，3.402823466351 E+38)</td><td align="center">单精度浮点数值</td></tr><tr><td align="center">DOUBLE</td><td align="center">8 Bytes</td><td align="center">(-1.7976931348623157 E+308 ，1.7976931348623157 E+308)</td><td align="center">0 和 (2.2250738585072014 E-308 ，1.7976931348623157 E+308)</td><td align="center">双精度浮点数值</td></tr><tr><td align="center">DECIMAL</td><td align="center">——</td><td align="center">依赖于精度（M）和标度（D）的数值</td><td align="center">依赖于精度（M）和标度（D）的数值</td><td align="center">小数值（精确定点数）</td></tr></tbody></table><ol start="2"><li>字符串类型</li></ol><table><thead><tr><th align="center">类型</th><th align="center">大小</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">CHAR</td><td align="center">0 - 255 Bytes</td><td align="center">变长字符串</td></tr><tr><td align="center">VARCHAR</td><td align="center">0 - 65535 Bytes</td><td align="center">定长字符串</td></tr><tr><td align="center">TINYBLOB</td><td align="center">0 - 255 Bytes</td><td align="center">不超过255个字符的二进制数据</td></tr><tr><td align="center">TINYTEXT</td><td align="center">0 - 255 Bytes</td><td align="center">短文本字符串</td></tr><tr><td align="center">BLOB</td><td align="center">0 - 65535 Bytes</td><td align="center">二进制形式的长文本数据</td></tr><tr><td align="center">TEXT</td><td align="center">0 - 65535 Bytes</td><td align="center">长文本数据</td></tr><tr><td align="center">MEDIUMBLOB</td><td align="center">0 - 16777215 Bytes</td><td align="center">二进制形式的中等长度文本数据</td></tr><tr><td align="center">MEDIUMTEXT</td><td align="center">0 - 16777215 Bytes</td><td align="center">中等长度文本数据</td></tr><tr><td align="center">LONGBLOB</td><td align="center">0 - 4294967295 Bytes</td><td align="center">二进制形式的极大文本数据</td></tr><tr><td align="center">LONGTEXT</td><td align="center">0 - 4294967295 Bytes</td><td align="center">极大文本数据</td></tr></tbody></table><ol start="3"><li>日期类型</li></ol><table><thead><tr><th align="center">类型</th><th align="center">大小</th><th align="center">范围</th><th align="center">格式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">DATE</td><td align="center">3 Bytes</td><td align="center">1000-01-01 到 9999-12-31</td><td align="center">YYYY-MM-DD</td><td align="center">日期值</td></tr><tr><td align="center">TIME</td><td align="center">3 Bytes</td><td align="center">-838:59:59 到 838:59:59</td><td align="center">HH:MM:SS</td><td align="center">时间值或者持续时间</td></tr><tr><td align="center">YEAR</td><td align="center">1 Bytes</td><td align="center">1901 到 2155</td><td align="center">YYYY</td><td align="center">年份值</td></tr><tr><td align="center">DATETIME</td><td align="center">8 Bytes</td><td align="center">1000-01-01 00:00:00 到 9999-12-31 23:59:59</td><td align="center">YYYY-MM-DD HH:MM:SS</td><td align="center">混合日期和时间值</td></tr><tr><td align="center">TIMESTAMP</td><td align="center">4 Bytes</td><td align="center">1970-01-01 00:00:00 到 2038-01-19 03:14:07</td><td align="center">YYYY-MM-DD HH:MM:SS</td><td align="center">混合日期和时间值。时间戳</td></tr></tbody></table><h3 id="1-1-DDL（数据定义语言）"><a href="#1-1-DDL（数据定义语言）" class="headerlink" title="1.1 DDL（数据定义语言）"></a>1.1 DDL（数据定义语言）</h3><p>数据定义语言</p><h4 id="1-1-1-数据库操作"><a href="#1-1-1-数据库操作" class="headerlink" title="1.1.1 数据库操作"></a>1.1.1 数据库操作</h4><ul><li><p>查询所有数据库：<br><code>SHOW DATABASES;</code></p></li><li><p>查询当前数据库：<br><code>SELECT DATABASE();</code></p></li><li><p>创建数据库：<br><code>CREATE DATABASE [ IF NOT EXISTS ] 数据库名 [ DEFAULT CHARSET 字符集] [COLLATE 排序规则 ];</code></p></li><li><p>删除数据库：<br><code>DROP DATABASE [ IF EXISTS ] 数据库名;</code></p></li><li><p>使用数据库：<br><code>USE 数据库名;</code></p></li></ul><blockquote><p>注：UTF8字符集长度为3字节，有些符号占4字节，所以一般推荐用utf8mb4字符集</p></blockquote><h4 id="1-1-2-表操作"><a href="#1-1-2-表操作" class="headerlink" title="1.1.2 表操作"></a>1.1.2 表操作</h4><ul><li><p>查询当前数据库所有表：</p><p><code>SHOW TABLES;</code></p></li><li><p>查询表结构：<br><code>DESC 表名;</code></p></li><li><p>查询指定表的建表语句：<br><code>SHOW CREATE TABLE 表名;</code></p></li><li><p>创建表：</p></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名(<br>字段1 字段1类型 [COMMENT 字段1注释],<br>字段2 字段2类型 [COMMENT 字段2注释],<br>字段3 字段3类型 [COMMENT 字段3注释],<br>...<br>字段n 字段n类型 [COMMENT 字段n注释]<br>)[ COMMENT 表注释 ];<br></code></pre></td></tr></table></figure><blockquote><p>注： <strong>最后一个字段后面没有逗号</strong></p></blockquote><ul><li><p>添加字段：<br><code>ALTER TABLE 表名 ADD 字段名 类型(长度) [COMMENT 注释] [约束];</code><br>例：<code>ALTER TABLE emp ADD nickname varchar(20) COMMENT &#39;昵称&#39;;</code></p></li><li><p>修改数据类型：<br><code>ALTER TABLE 表名 MODIFY 字段名 新数据类型(长度);</code></p></li><li><p>修改字段名和字段类型：<br><code>ALTER TABLE 表名 CHANGE 旧字段名 新字段名 类型(长度) [COMMENT 注释] [约束];</code><br>例：将emp表的nickname字段修改为username，类型为varchar(30)<br><code>ALTER TABLE emp CHANGE nickname username varchar(30) COMMENT &#39;昵称&#39;;</code></p></li><li><p>删除字段：<br><code>ALTER TABLE 表名 DROP 字段名;</code></p></li><li><p>修改表名：<br><code>ALTER TABLE 表名 RENAME TO 新表名</code></p></li><li><p>删除表：<br><code>DROP TABLE [IF EXISTS] 表名;</code></p></li><li><p>删除表，并重新创建该表：<br><code>TRUNCATE TABLE 表名;</code></p></li></ul><h3 id="1-2-DML（数据操作语言）"><a href="#1-2-DML（数据操作语言）" class="headerlink" title="1.2 DML（数据操作语言）"></a>1.2 DML（数据操作语言）</h3><h4 id="1-2-1-添加数据"><a href="#1-2-1-添加数据" class="headerlink" title="1.2.1 添加数据"></a>1.2.1 添加数据</h4><ul><li><p>指定字段：<br><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...);</code></p></li><li><p>全部字段：<br><code>INSERT INTO 表名 VALUES (值1, 值2, ...);</code></p></li><li><p>批量添加数据：<br><code>INSERT INTO 表名 (字段名1, 字段名2, ...) VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</code><br><code>INSERT INTO 表名 VALUES (值1, 值2, ...), (值1, 值2, ...), (值1, 值2, ...);</code></p></li></ul><blockquote><p><strong>注意事项</strong>：</p><ul><li>插入数据时，指定字段顺序需要与值的顺序一一对应</li><li>字符串和日期类型数据应该包含在引号中</li><li>插入的数据大小应该在字段的规定范围内</li></ul></blockquote><h4 id="1-2-2-更新和删除数据"><a href="#1-2-2-更新和删除数据" class="headerlink" title="1.2.2 更新和删除数据"></a>1.2.2 更新和删除数据</h4><ul><li><p>修改数据：<br><code>UPDATE 表名 SET 字段名1 = 值1, 字段名2 = 值2, ... [ WHERE 条件 ];</code><br>例：<br><code>UPDATE emp SET name = &#39;Jack&#39; WHERE id = 1;</code></p></li><li><p>删除数据：<br><code>DELETE FROM 表名 [ WHERE 条件 ];</code></p></li></ul><h3 id="1-3-DQL（数据查询语言）"><a href="#1-3-DQL（数据查询语言）" class="headerlink" title="1.3 DQL（数据查询语言）"></a>1.3 DQL（数据查询语言）</h3><ul><li>语法：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT<br>字段列表<br>FROM<br>表名字段<br>WHERE<br>条件列表<br>GROUP BY<br>分组字段列表<br>HAVING<br>分组后的条件列表<br>ORDER BY<br>排序字段列表<br>LIMIT<br>分页参数<br></code></pre></td></tr></table></figure><h4 id="1-3-1-基础查询"><a href="#1-3-1-基础查询" class="headerlink" title="1.3.1 基础查询"></a>1.3.1 基础查询</h4><ul><li><p>查询多个字段：<br><code>SELECT 字段1, 字段2, 字段3, ... FROM 表名;</code><br><code>SELECT * FROM 表名;</code></p></li><li><p>设置别名：<br><code>SELECT 字段1 [ AS 别名1 ], 字段2 [ AS 别名2 ], 字段3 [ AS 别名3 ], ... FROM 表名;</code><br><code>SELECT 字段1 [ 别名1 ], 字段2 [ 别名2 ], 字段3 [ 别名3 ], ... FROM 表名;</code></p></li><li><p>去除重复记录：<br><code>SELECT DISTINCT 字段列表 FROM 表名;</code></p></li><li><p>转义：<br><code>SELECT * FROM 表名 WHERE name LIKE &#39;/_张三&#39; ESCAPE &#39;/&#39;</code><br>&#x2F; 之后的_不作为通配符</p></li></ul><h4 id="1-3-2-条件查询"><a href="#1-3-2-条件查询" class="headerlink" title="1.3.2 条件查询"></a>1.3.2 条件查询</h4><ul><li>语法：<br><code>SELECT 字段列表 FROM 表名 WHERE 条件列表;</code></li></ul><p>条件：</p><table><thead><tr><th align="center">比较运算符</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">&gt;</td><td align="center">大于</td></tr><tr><td align="center">&gt;&#x3D;</td><td align="center">大于等于</td></tr><tr><td align="center">&lt;</td><td align="center">小于</td></tr><tr><td align="center">&lt;&#x3D;</td><td align="center">小于等于</td></tr><tr><td align="center">&#x3D;</td><td align="center">等于</td></tr><tr><td align="center">&lt;&gt; 或 !&#x3D;</td><td align="center">不等于</td></tr><tr><td align="center">BETWEEN … AND …</td><td align="center">在某个范围内（含最小、最大值）</td></tr><tr><td align="center">IN(…)</td><td align="center">在in之后的列表中的值，多选一</td></tr><tr><td align="center">LIKE 占位符</td><td align="center">模糊匹配（_匹配单个字符，%匹配任意个字符）</td></tr><tr><td align="center">IS NULL</td><td align="center">是NULL</td></tr></tbody></table><table><thead><tr><th align="center">逻辑运算符</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">AND 或 &amp;&amp;</td><td align="center">并且（多个条件同时成立）</td></tr><tr><td align="center">OR 或 &#124;&#124;</td><td align="center">或者（多个条件任意一个成立）</td></tr><tr><td align="center">NOT 或 !</td><td align="center">非，不是</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 年龄等于30<br>select * from employee where age = 30;<br>-- 年龄小于30<br>select * from employee where age &lt; 30;<br>-- 小于等于<br>select * from employee where age &lt;= 30;<br>-- 没有身份证<br>select * from employee where idcard is null or idcard = &#x27;&#x27;;<br>-- 有身份证<br>select * from employee where idcard;<br>select * from employee where idcard is not null;<br>-- 不等于<br>select * from employee where age != 30;<br>-- 年龄在20到30之间<br>select * from employee where age between 20 and 30;<br>select * from employee where age &gt;= 20 and age &lt;= 30;<br>-- 下面语句不报错，但查不到任何信息<br>select * from employee where age between 30 and 20;<br>-- 性别为女且年龄小于30<br>select * from employee where age &lt; 30 and gender = &#x27;女&#x27;;<br>-- 年龄等于25或30或35<br>select * from employee where age = 25 or age = 30 or age = 35;<br>select * from employee where age in (25, 30, 35);<br>-- 姓名为两个字<br>select * from employee where name like &#x27;__&#x27;;<br>-- 身份证最后为X<br>select * from employee where idcard like &#x27;%X&#x27;;<br></code></pre></td></tr></table></figure><h4 id="1-3-3-聚合查询（聚合函数）"><a href="#1-3-3-聚合查询（聚合函数）" class="headerlink" title="1.3.3 聚合查询（聚合函数）"></a>1.3.3 聚合查询（聚合函数）</h4><p>常见聚合函数：</p><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">count</td><td align="center">统计数量</td></tr><tr><td align="center">max</td><td align="center">最大值</td></tr><tr><td align="center">min</td><td align="center">最小值</td></tr><tr><td align="center">avg</td><td align="center">平均值</td></tr><tr><td align="center">sum</td><td align="center">求和</td></tr></tbody></table><ul><li>语法：<br><code>SELECT 聚合函数(字段列表) FROM 表名;</code><br>例：<br><code>SELECT count(id) from employee where workaddress = &quot;广东省&quot;;</code></li></ul><h4 id="1-3-4-分组查询"><a href="#1-3-4-分组查询" class="headerlink" title="1.3.4 分组查询"></a>1.3.4 分组查询</h4><ul><li>语法：<br><code>SELECT 字段列表 FROM 表名 [ WHERE 条件 ] GROUP BY 分组字段名 [ HAVING 分组后的过滤条件 ];</code></li></ul><p>where 和 having 的区别：</p><ul><li>执行时机不同：where是分组之前进行过滤，不满足where条件不参与分组；having是分组后对结果进行过滤。</li><li>判断条件不同：where不能对聚合函数进行判断，而having可以。</li></ul><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 根据性别分组，统计男性和女性数量（只显示分组数量，不显示哪个是男哪个是女）<br>select count(*) from employee group by gender;<br>-- 根据性别分组，统计男性和女性数量<br>select gender, count(*) from employee group by gender;<br>-- 根据性别分组，统计男性和女性的平均年龄<br>select gender, avg(age) from employee group by gender;<br>-- 年龄小于45，并根据工作地址分组<br>select workaddress, count(*) from employee where age &lt; 45 group by workaddress;<br>-- 年龄小于45，并根据工作地址分组，获取员工数量大于等于3的工作地址<br>select workaddress, count(*) address_count from employee where age &lt; 45 group by workaddress having address_count &gt;= 3;<br></code></pre></td></tr></table></figure><h5 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>执行顺序：where &gt; 聚合函数 &gt; having</li><li>分组之后，查询的字段一般为聚合函数和分组字段，查询其他字段无任何意义</li></ul><h4 id="1-3-5-排序查询"><a href="#1-3-5-排序查询" class="headerlink" title="1.3.5 排序查询"></a>1.3.5 排序查询</h4><ul><li>语法：<br><code>SELECT 字段列表 FROM 表名 ORDER BY 字段1 排序方式1, 字段2 排序方式2;</code></li></ul><p>排序方式：</p><ul><li>ASC: 升序（默认）</li><li>DESC: 降序</li></ul><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 根据年龄升序排序<br>SELECT * FROM employee ORDER BY age ASC;<br>SELECT * FROM employee ORDER BY age;<br>-- 两字段排序，根据年龄升序排序，入职时间降序排序<br>SELECT * FROM employee ORDER BY age ASC, entrydate DESC;<br></code></pre></td></tr></table></figure><blockquote><p>注意：如果是多字段排序，当第一个字段值相同时，才会根据第二个字段进行排序</p></blockquote><h4 id="1-3-6-分页查询"><a href="#1-3-6-分页查询" class="headerlink" title="1.3.6 分页查询"></a>1.3.6 分页查询</h4><ul><li>语法：<br><code>SELECT 字段列表 FROM 表名 LIMIT 起始索引, 查询记录数;</code></li></ul><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询第一页数据，展示10条<br>SELECT * FROM employee LIMIT 0, 10;<br>-- 查询第二页<br>SELECT * FROM employee LIMIT 10, 10;<br></code></pre></td></tr></table></figure><blockquote><p>注意事项：</p><ul><li>起始索引从0开始，起始索引 &#x3D; （查询页码 - 1） * 每页显示记录数</li><li>分页查询是数据库的方言，不同数据库有不同实现，MySQL是LIMIT</li><li>如果查询的是第一页数据，起始索引可以省略，直接简写 LIMIT 10</li></ul></blockquote><h4 id="1-3-7-DQL执行顺序"><a href="#1-3-7-DQL执行顺序" class="headerlink" title="1.3.7 DQL执行顺序"></a>1.3.7 DQL执行顺序</h4><p>FROM -&gt; WHERE -&gt; GROUP BY -&gt; SELECT -&gt; ORDER BY -&gt; LIMIT</p><h3 id="1-4-DCL（数据控制语言）"><a href="#1-4-DCL（数据控制语言）" class="headerlink" title="1.4 DCL（数据控制语言）"></a>1.4 DCL（数据控制语言）</h3><h4 id="1-4-1-管理用户"><a href="#1-4-1-管理用户" class="headerlink" title="1.4.1 管理用户"></a>1.4.1 管理用户</h4><ul><li>查询用户：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">USE mysql;<br>SELECT * FROM user;<br></code></pre></td></tr></table></figure><ul><li><p>创建用户:<br><code>CREATE USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED BY &#39;密码&#39;;</code></p></li><li><p>修改用户密码：<br><code>ALTER USER &#39;用户名&#39;@&#39;主机名&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;;</code></p></li><li><p>删除用户：<br><code>DROP USER &#39;用户名&#39;@&#39;主机名&#39;;</code></p></li></ul><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 创建用户test，只能在当前主机localhost访问<br>create user &#x27;test&#x27;@&#x27;localhost&#x27; identified by &#x27;123456&#x27;;<br>-- 创建用户test，能在任意主机访问<br>create user &#x27;test&#x27;@&#x27;%&#x27; identified by &#x27;123456&#x27;;<br>create user &#x27;test&#x27; identified by &#x27;123456&#x27;;<br>-- 修改密码<br>alter user &#x27;test&#x27;@&#x27;localhost&#x27; identified with mysql_native_password by &#x27;1234&#x27;;<br>-- 删除用户<br>drop user &#x27;test&#x27;@&#x27;localhost&#x27;;<br></code></pre></td></tr></table></figure><blockquote><p>注意事项：主机名可以使用 % 通配</p></blockquote><h4 id="1-4-2-权限控制"><a href="#1-4-2-权限控制" class="headerlink" title="1.4.2 权限控制"></a>1.4.2 权限控制</h4><ul><li>常用权限：</li></ul><table><thead><tr><th align="center">权限</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">ALL, ALL PRIVILEGES</td><td align="center">所有权限</td></tr><tr><td align="center">SELECT</td><td align="center">查询数据</td></tr><tr><td align="center">INSERT</td><td align="center">插入数据</td></tr><tr><td align="center">UPDATE</td><td align="center">修改数据</td></tr><tr><td align="center">DELETE</td><td align="center">删除数据</td></tr><tr><td align="center">ALTER</td><td align="center">修改表</td></tr><tr><td align="center">DROP</td><td align="center">删除数据库&#x2F;表&#x2F;视图</td></tr><tr><td align="center">CREATE</td><td align="center">创建数据库&#x2F;表</td></tr></tbody></table><p>更多权限请看<a href="#%E6%9D%83%E9%99%90%E4%B8%80%E8%A7%88%E8%A1%A8" title="权限一览表">权限一览表</a></p><ul><li><p>查询权限：<br><code>SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39;;</code></p></li><li><p>授予权限：<br><code>GRANT 权限列表 ON 数据库名.表名 TO &#39;用户名&#39;@&#39;主机名&#39;;</code></p></li><li><p>撤销权限：<br><code>REVOKE 权限列表 ON 数据库名.表名 FROM &#39;用户名&#39;@&#39;主机名&#39;;</code></p></li></ul><h5 id="注意事项-1"><a href="#注意事项-1" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>多个权限用逗号分隔</li><li>授权时，数据库名和表名可以用 * 进行通配，代表所有</li></ul><h2 id="二-函数"><a href="#二-函数" class="headerlink" title="二.函数"></a>二.函数</h2><ul><li>字符串函数</li><li>数值函数</li><li>日期函数</li><li>流程函数</li></ul><h3 id="2-1-字符串函数"><a href="#2-1-字符串函数" class="headerlink" title="2.1 字符串函数"></a>2.1 字符串函数</h3><ul><li>常用函数：</li></ul><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">CONCAT(s1, s2, …, sn)</td><td align="center">字符串拼接，将s1, s2, …, sn拼接成一个字符串</td></tr><tr><td align="center">LOWER(str)</td><td align="center">将字符串全部转为小写</td></tr><tr><td align="center">UPPER(str)</td><td align="center">将字符串全部转为大写</td></tr><tr><td align="center">LPAD(str, n, pad)</td><td align="center">左填充，用字符串pad对str的左边进行填充，达到n个字符串长度</td></tr><tr><td align="center">RPAD(str, n, pad)</td><td align="center">右填充，用字符串pad对str的右边进行填充，达到n个字符串长度</td></tr><tr><td align="center">TRIM(str)</td><td align="center">去掉字符串头部和尾部的空格</td></tr><tr><td align="center">SUBSTRING(str, start, len)</td><td align="center">返回从字符串str从start位置起的len个长度的字符串</td></tr></tbody></table><p>使用示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 拼接<br>SELECT CONCAT(&#x27;Hello&#x27;, &#x27;World&#x27;);<br>-- 小写<br>SELECT LOWER(&#x27;Hello&#x27;);<br>-- 大写<br>SELECT UPPER(&#x27;Hello&#x27;);<br>-- 左填充<br>SELECT LPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);<br>-- 右填充<br>SELECT RPAD(&#x27;01&#x27;, 5, &#x27;-&#x27;);<br>-- 去除空格<br>SELECT TRIM(&#x27; Hello World &#x27;);<br>-- 切片（起始索引为1）<br>SELECT SUBSTRING(&#x27;Hello World&#x27;, 1, 5);<br></code></pre></td></tr></table></figure><h3 id="2-2-数值函数"><a href="#2-2-数值函数" class="headerlink" title="2.2 数值函数"></a>2.2 数值函数</h3><ul><li>常见函数：</li></ul><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">CEIL(x)</td><td align="center">向上取整</td></tr><tr><td align="center">FLOOR(x)</td><td align="center">向下取整</td></tr><tr><td align="center">MOD(x, y)</td><td align="center">返回x&#x2F;y的模</td></tr><tr><td align="center">RAND()</td><td align="center">返回0~1内的随机数</td></tr><tr><td align="center">ROUND(x, y)</td><td align="center">求参数x的四舍五入值，保留y位小数</td></tr></tbody></table><h3 id="2-3-日期函数"><a href="#2-3-日期函数" class="headerlink" title="2.3 日期函数"></a>2.3 日期函数</h3><ul><li>常用函数：</li></ul><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">CURDATE()</td><td align="center">返回当前日期</td></tr><tr><td align="center">CURTIME()</td><td align="center">返回当前时间</td></tr><tr><td align="center">NOW()</td><td align="center">返回当前日期和时间</td></tr><tr><td align="center">YEAR(date)</td><td align="center">获取指定date的年份</td></tr><tr><td align="center">MONTH(date)</td><td align="center">获取指定date的月份</td></tr><tr><td align="center">DAY(date)</td><td align="center">获取指定date的日期</td></tr><tr><td align="center">DATE_ADD(date, INTERVAL expr type)</td><td align="center">返回一个日期&#x2F;时间值加上一个时间间隔expr后的时间值</td></tr><tr><td align="center">DATEDIFF(date1, date2)</td><td align="center">返回起始时间date1和结束时间date2之间的天数</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- DATE_ADD<br>SELECT DATE_ADD(NOW(), INTERVAL 70 YEAR);<br></code></pre></td></tr></table></figure><h3 id="2-4-流程函数"><a href="#2-4-流程函数" class="headerlink" title="2.4 流程函数"></a>2.4 流程函数</h3><ul><li>常用函数：</li></ul><table><thead><tr><th align="center">函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">IF(value, t, f)</td><td align="center">如果value为true，则返回t，否则返回f</td></tr><tr><td align="center">IFNULL(value1, value2)</td><td align="center">如果value1不为空，返回value1，否则返回value2</td></tr><tr><td align="center">CASE WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td align="center">如果val1为true，返回res1，… 否则返回default默认值</td></tr><tr><td align="center">CASE [ expr ] WHEN [ val1 ] THEN [ res1 ] … ELSE [ default ] END</td><td align="center">如果expr的值等于val1，返回res1，… 否则返回default默认值</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select<br>name,<br>(case when age &gt; 30 then &#x27;中年&#x27; else &#x27;青年&#x27; end)<br>from employee;<br>select<br>name,<br>(case workaddress when &#x27;北京市&#x27; then &#x27;一线城市&#x27; when &#x27;上海市&#x27; then &#x27;一线城市&#x27; else &#x27;二线城市&#x27; end) as &#x27;工作地址&#x27;<br>from employee;<br></code></pre></td></tr></table></figure><h2 id="三-约束"><a href="#三-约束" class="headerlink" title="三.约束"></a>三.约束</h2><ul><li>分类：</li></ul><table><thead><tr><th align="center">约束</th><th align="center">描述</th><th align="center">关键字</th></tr></thead><tbody><tr><td align="center">非空约束</td><td align="center">限制该字段的数据不能为null</td><td align="center">NOT NULL</td></tr><tr><td align="center">唯一约束</td><td align="center">保证该字段的所有数据都是唯一、不重复的</td><td align="center">UNIQUE</td></tr><tr><td align="center">主键约束</td><td align="center">主键是一行数据的唯一标识，要求非空且唯一</td><td align="center">PRIMARY KEY</td></tr><tr><td align="center">默认约束</td><td align="center">保存数据时，如果未指定该字段的值，则采用默认值</td><td align="center">DEFAULT</td></tr><tr><td align="center">检查约束（8.0.1版本后）</td><td align="center">保证字段值满足某一个条件</td><td align="center">CHECK</td></tr><tr><td align="center">外键约束</td><td align="center">用来让两张图的数据之间建立连接，保证数据的一致性和完整性</td><td align="center">FOREIGN KEY</td></tr></tbody></table><p>约束是作用于表中字段上的，可以再创建表&#x2F;修改表的时候添加约束。</p><h3 id="3-1-常用约束"><a href="#3-1-常用约束" class="headerlink" title="3.1 常用约束"></a>3.1 常用约束</h3><table><thead><tr><th align="center">约束条件</th><th align="center">关键字</th></tr></thead><tbody><tr><td align="center">主键</td><td align="center">PRIMARY KEY</td></tr><tr><td align="center">自动增长</td><td align="center">AUTO_INCREMENT</td></tr><tr><td align="center">不为空</td><td align="center">NOT NULL</td></tr><tr><td align="center">唯一</td><td align="center">UNIQUE</td></tr><tr><td align="center">逻辑条件</td><td align="center">CHECK</td></tr><tr><td align="center">默认值</td><td align="center">DEFAULT</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql">create table user(<br>id int primary key auto_increment,<br>name varchar(10) not null unique,<br>age int check(age &gt; 0 and age &lt; 120),<br>status char(1) default &#x27;1&#x27;,<br>gender char(1)<br>);<br></code></pre></td></tr></table></figure><h3 id="3-2-外键约束"><a href="#3-2-外键约束" class="headerlink" title="3.2 外键约束"></a>3.2 外键约束</h3><ul><li>添加外键：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">CREATE TABLE 表名(<br>字段名 字段类型,<br>...<br>[CONSTRAINT] [外键名称] FOREIGN KEY(外键字段名) REFERENCES 主表(主表列名)<br>);<br>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名) REFERENCES 主表(主表列名);<br><br>-- 例子<br>alter table emp add constraint fk_emp_dept_id foreign key(dept_id) references dept(id);<br></code></pre></td></tr></table></figure><ul><li>删除外键：<br><code>ALTER TABLE 表名 DROP FOREIGN KEY 外键名;</code></li></ul><h4 id="删除-更新行为"><a href="#删除-更新行为" class="headerlink" title="删除&#x2F;更新行为"></a>删除&#x2F;更新行为</h4><table><thead><tr><th align="center">行为</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">NO ACTION</td><td align="center">当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新（与RESTRICT一致）</td></tr><tr><td align="center">RESTRICT</td><td align="center">当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则不允许删除&#x2F;更新（与NO ACTION一致）</td></tr><tr><td align="center">CASCADE</td><td align="center">当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则也删除&#x2F;更新外键在子表中的记录</td></tr><tr><td align="center">SET NULL</td><td align="center">当在父表中删除&#x2F;更新对应记录时，首先检查该记录是否有对应外键，如果有则设置子表中该外键值为null（要求该外键允许为null）</td></tr><tr><td align="center">SET DEFAULT</td><td align="center">父表有变更时，子表将外键设为一个默认值（Innodb不支持）</td></tr></tbody></table><ul><li>更改删除&#x2F;更新行为：<br><code>ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES 主表名(主表字段名) ON UPDATE 行为 ON DELETE 行为;</code></li></ul><h2 id="四-多表查询"><a href="#四-多表查询" class="headerlink" title="四.多表查询"></a>四.多表查询</h2><h3 id="4-1-多表关系"><a href="#4-1-多表关系" class="headerlink" title="4.1 多表关系"></a>4.1 多表关系</h3><ul><li>一对多（多对一）</li><li>多对多</li><li>一对一</li></ul><h4 id="一对多"><a href="#一对多" class="headerlink" title="一对多"></a>一对多</h4><p>案例：部门与员工<br>关系：一个部门对应多个员工，一个员工对应一个部门<br>实现：在多的一方建立外键，指向一的一方的主键</p><h4 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h4><p>案例：学生与课程<br>关系：一个学生可以选多门课程，一门课程也可以供多个学生选修<br>实现：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</p><h4 id="一对一"><a href="#一对一" class="headerlink" title="一对一"></a>一对一</h4><p>案例：用户与用户详情<br>关系：一对一关系，多用于单表拆分，将一张表的基础字段放在一张表中，其他详情字段放在另一张表中，以提升操作效率<br>实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的（UNIQUE）</p><h3 id="4-2-查询"><a href="#4-2-查询" class="headerlink" title="4.2 查询"></a>4.2 查询</h3><p>合并查询（笛卡尔积，会展示所有组合结果）：<br><code>select * from employee, dept;</code></p><blockquote><p>笛卡尔积：两个集合A集合和B集合的所有组合情况（在多表查询时，需要消除无效的笛卡尔积）</p></blockquote><p>消除无效笛卡尔积：<br><code>select * from employee, dept where employee.dept = dept.id;</code></p><h3 id="4-3-内连接查询"><a href="#4-3-内连接查询" class="headerlink" title="4.3 内连接查询"></a>4.3 内连接查询</h3><p>内连接查询的是两张表交集的部分</p><ul><li><p>隐式内连接：<br><code>SELECT 字段列表 FROM 表1, 表2 WHERE 条件 ...;</code></p></li><li><p>显式内连接：<br><code>SELECT 字段列表 FROM 表1 [ INNER ] JOIN 表2 ON 连接条件 ...;</code></p></li></ul><p>显式性能比隐式高</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询员工姓名，及关联的部门的名称<br>-- 隐式<br>select e.name, d.name from employee as e, dept as d where e.dept = d.id;<br>-- 显式<br>select e.name, d.name from employee as e inner join dept as d on e.dept = d.id;<br></code></pre></td></tr></table></figure><h3 id="4-4-外连接查询"><a href="#4-4-外连接查询" class="headerlink" title="4.4 外连接查询"></a>4.4 外连接查询</h3><ul><li><p>左外连接：<br>查询左表所有数据，以及两张表交集部分数据<br><code>SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ...;</code><br>相当于查询表1的所有数据，包含表1和表2交集部分数据</p></li><li><p>右外连接：<br>查询右表所有数据，以及两张表交集部分数据<br><code>SELECT 字段列表 FROM 表1 RIGHT [ OUTER ] JOIN 表2 ON 条件 ...;</code></p></li></ul><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 左<br>select e.*, d.name from employee as e left outer join dept as d on e.dept = d.id;<br>select d.name, e.* from dept d left outer join emp e on e.dept = d.id;  -- 这条语句与下面的语句效果一样<br>-- 右<br>select d.name, e.* from employee as e right outer join dept as d on e.dept = d.id;<br></code></pre></td></tr></table></figure><p>左连接可以查询到没有dept的employee，右连接可以查询到没有employee的dept</p><h3 id="4-5-自连接查询"><a href="#4-5-自连接查询" class="headerlink" title="4.5 自连接查询"></a>4.5 自连接查询</h3><p>当前表与自身的连接查询，自连接必须使用表别名</p><p>语法：<br><code>SELECT 字段列表 FROM 表A 别名A JOIN 表A 别名B ON 条件 ...;</code></p><p>自连接查询，可以是内连接查询，也可以是外连接查询</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询员工及其所属领导的名字<br>select a.name, b.name from employee a, employee b where a.manager = b.id;<br>-- 没有领导的也查询出来<br>select a.name, b.name from employee a left join employee b on a.manager = b.id;<br></code></pre></td></tr></table></figure><h3 id="4-6-联合查询-union-union-all"><a href="#4-6-联合查询-union-union-all" class="headerlink" title="4.6 联合查询 union, union all"></a>4.6 联合查询 union, union all</h3><p>把多次查询的结果合并，形成一个新的查询集</p><p>语法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT 字段列表 FROM 表A ...<br>UNION [ALL]<br>SELECT 字段列表 FROM 表B ...<br></code></pre></td></tr></table></figure><blockquote><p>注意事项：</p><ul><li>UNION ALL 会有重复结果，UNION 不会</li><li>联合查询比使用or效率高，不会使索引失效</li></ul></blockquote><h3 id="4-7-子查询"><a href="#4-7-子查询" class="headerlink" title="4.7 子查询"></a>4.7 子查询</h3><p>SQL语句中嵌套SELECT语句，称谓嵌套查询，又称子查询。<br><code>SELECT * FROM t1 WHERE column1 = ( SELECT column1 FROM t2);</code><br><strong>子查询外部的语句可以是 INSERT &#x2F; UPDATE &#x2F; DELETE &#x2F; SELECT 的任何一个</strong></p><p>根据子查询结果可以分为：</p><ul><li>标量子查询（子查询结果为单个值）</li><li>列子查询（子查询结果为一列）</li><li>行子查询（子查询结果为一行）</li><li>表子查询（子查询结果为多行多列）</li></ul><p>根据子查询位置可分为：</p><ul><li>WHERE 之后</li><li>FROM 之后</li><li>SELECT 之后</li></ul><h4 id="标量子查询"><a href="#标量子查询" class="headerlink" title="标量子查询"></a>标量子查询</h4><p>子查询返回的结果是单个值（数字、字符串、日期等）。<br>常用操作符：- &lt; &gt; &gt; &gt;&#x3D; &lt; &lt;&#x3D;</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询销售部所有员工<br>select id from dept where name = &#x27;销售部&#x27;;<br>-- 根据销售部部门ID，查询员工信息<br>select * from employee where dept = 4;<br>-- 合并（子查询）<br>select * from employee where dept = (select id from dept where name = &#x27;销售部&#x27;);<br><br>-- 查询xxx入职之后的员工信息<br>select * from employee where entrydate &gt; (select entrydate from employee where name = &#x27;xxx&#x27;);<br></code></pre></td></tr></table></figure><h4 id="列子查询"><a href="#列子查询" class="headerlink" title="列子查询"></a>列子查询</h4><p>返回的结果是一列（可以是多行）。</p><p>常用操作符：</p><table><thead><tr><th align="center">操作符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">IN</td><td align="center">在指定的集合范围内，多选一</td></tr><tr><td align="center">NOT IN</td><td align="center">不在指定的集合范围内</td></tr><tr><td align="center">ANY</td><td align="center">子查询返回列表中，有任意一个满足即可</td></tr><tr><td align="center">SOME</td><td align="center">与ANY等同，使用SOME的地方都可以使用ANY</td></tr><tr><td align="center">ALL</td><td align="center">子查询返回列表的所有值都必须满足</td></tr></tbody></table><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询销售部和市场部的所有员工信息<br>select * from employee where dept in (select id from dept where name = &#x27;销售部&#x27; or name = &#x27;市场部&#x27;);<br>-- 查询比财务部所有人工资都高的员工信息<br>select * from employee where salary &gt; all(select salary from employee where dept = (select id from dept where name = &#x27;财务部&#x27;));<br>-- 查询比研发部任意一人工资高的员工信息<br>select * from employee where salary &gt; any (select salary from employee where dept = (select id from dept where name = &#x27;研发部&#x27;));<br></code></pre></td></tr></table></figure><h4 id="行子查询"><a href="#行子查询" class="headerlink" title="行子查询"></a>行子查询</h4><p>返回的结果是一行（可以是多列）。<br>常用操作符：&#x3D;, &lt;, &gt;, IN, NOT IN</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询与xxx的薪资及直属领导相同的员工信息<br>select * from employee where (salary, manager) = (12500, 1);<br>select * from employee where (salary, manager) = (select salary, manager from employee where name = &#x27;xxx&#x27;);<br></code></pre></td></tr></table></figure><h4 id="表子查询"><a href="#表子查询" class="headerlink" title="表子查询"></a>表子查询</h4><p>返回的结果是多行多列<br>常用操作符：IN</p><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询与xxx1，xxx2的职位和薪资相同的员工<br>select * from employee where (job, salary) in (select job, salary from employee where name = &#x27;xxx1&#x27; or name = &#x27;xxx2&#x27;);<br>-- 查询入职日期是2006-01-01之后的员工，及其部门信息<br>select e.*, d.* from (select * from employee where entrydate &gt; &#x27;2006-01-01&#x27;) as e left join dept as d on e.dept = d.id;<br></code></pre></td></tr></table></figure><h2 id="五-事务"><a href="#五-事务" class="headerlink" title="五.事务"></a>五.事务</h2><p>事务是一组操作的集合，事务会把所有操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><p>基本操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 1. 查询张三账户余额<br>select * from account where name = &#x27;张三&#x27;;<br>-- 2. 将张三账户余额-1000<br>update account set money = money - 1000 where name = &#x27;张三&#x27;;<br>-- 此语句出错后张三钱减少但是李四钱没有增加<br>模拟sql语句错误<br>-- 3. 将李四账户余额+1000<br>update account set money = money + 1000 where name = &#x27;李四&#x27;;<br><br>-- 查看事务提交方式<br>SELECT @@AUTOCOMMIT;<br>-- 设置事务提交方式，1为自动提交，0为手动提交，该设置只对当前会话有效<br>SET @@AUTOCOMMIT = 0;<br>-- 提交事务<br>COMMIT;<br>-- 回滚事务<br>ROLLBACK;<br><br>-- 设置手动提交后上面代码改为：<br>select * from account where name = &#x27;张三&#x27;;<br>update account set money = money - 1000 where name = &#x27;张三&#x27;;<br>update account set money = money + 1000 where name = &#x27;李四&#x27;;<br>commit;<br></code></pre></td></tr></table></figure><p>操作方式二：</p><p>开启事务：<br><code>START TRANSACTION 或 BEGIN TRANSACTION;</code><br>提交事务：<br><code>COMMIT;</code><br>回滚事务：<br><code>ROLLBACK;</code></p><p>操作实例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs mysql">start transaction;<br>select * from account where name = &#x27;张三&#x27;;<br>update account set money = money - 1000 where name = &#x27;张三&#x27;;<br>update account set money = money + 1000 where name = &#x27;李四&#x27;;<br>commit;<br></code></pre></td></tr></table></figure><h3 id="5-1-四大特性ACID"><a href="#5-1-四大特性ACID" class="headerlink" title="5.1 四大特性ACID"></a>5.1 四大特性ACID</h3><ul><li>原子性(Atomicity)：事务是不可分割的最小操作但愿，要么全部成功，要么全部失败</li><li>一致性(Consistency)：事务完成时，必须使所有数据都保持一致状态</li><li>隔离性(Isolation)：数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行</li><li>持久性(Durability)：事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul><h3 id="5-2-并发事务"><a href="#5-2-并发事务" class="headerlink" title="5.2 并发事务"></a>5.2 并发事务</h3><table><thead><tr><th align="center">问题</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">脏读</td><td align="center">一个事务读到另一个事务还没提交的数据</td></tr><tr><td align="center">不可重复读</td><td align="center">一个事务先后读取同一条记录，但两次读取的数据不同</td></tr><tr><td align="center">幻读</td><td align="center">一个事务按照条件查询数据时，没有对应的数据行，但是再插入数据时，又发现这行数据已经存在</td></tr></tbody></table><blockquote><p>这三个问题的详细演示：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=55cd</a> </p></blockquote><p>并发事务隔离级别：</p><table><thead><tr><th align="center">隔离级别</th><th align="center">脏读</th><th align="center">不可重复读</th><th align="center">幻读</th></tr></thead><tbody><tr><td align="center">Read uncommitted</td><td align="center">√</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">Read committed</td><td align="center">×</td><td align="center">√</td><td align="center">√</td></tr><tr><td align="center">Repeatable Read(默认)</td><td align="center">×</td><td align="center">×</td><td align="center">√</td></tr><tr><td align="center">Serializable</td><td align="center">×</td><td align="center">×</td><td align="center">×</td></tr></tbody></table><ul><li>√表示在当前隔离级别下该问题会出现</li><li>Serializable 性能最低；Read uncommitted 性能最高，数据安全性最差</li></ul><p>查看事务隔离级别：<br><code>SELECT @@TRANSACTION_ISOLATION;</code><br>设置事务隔离级别：<br><code>SET [ SESSION | GLOBAL ] TRANSACTION ISOLATION LEVEL &#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE &#125;;</code><br>SESSION 是会话级别，表示只针对当前会话有效，GLOBAL 表示对所有会话有效</p><h1 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h1><h2 id="一-存储引擎"><a href="#一-存储引擎" class="headerlink" title="一.存储引擎"></a>一.存储引擎</h2><p>MySQL体系结构：</p><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/MySQL%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="结构图" title="结构图"><br><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/MySQL%E5%B1%82%E7%BA%A7%E6%8F%8F%E8%BF%B0.png" alt="层级描述" title="层级描述"></p><p>存储引擎就是存储数据、建立索引、更新&#x2F;查询数据等技术的实现方式。存储引擎是基于表而不是基于库的，所以存储引擎也可以被称为表引擎。<br>默认存储引擎是InnoDB。</p><p>相关操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 查询建表语句<br>show create table account;<br>-- 建表时指定存储引擎<br>CREATE TABLE 表名(<br>...<br>) ENGINE=INNODB;<br>-- 查看当前数据库支持的存储引擎<br>show engines;<br></code></pre></td></tr></table></figure><h3 id="1-1-InnoDB"><a href="#1-1-InnoDB" class="headerlink" title="1.1 InnoDB"></a>1.1 InnoDB</h3><p>InnoDB 是一种兼顾高可靠性和高性能的通用存储引擎，在 MySQL 5.5 之后，InnoDB 是默认的 MySQL 引擎。</p><p>特点：</p><ul><li>DML 操作遵循 ACID 模型，支持<strong>事务</strong></li><li><strong>行级锁</strong>，提高并发访问性能</li><li>支持<strong>外键</strong>约束，保证数据的完整性和正确性</li></ul><p>文件：</p><ul><li>xxx.ibd: xxx代表表名，InnoDB 引擎的每张表都会对应这样一个表空间文件，存储该表的表结构（frm、sdi）、数据和索引。</li></ul><p>参数：innodb_file_per_table，决定多张表共享一个表空间还是每张表对应一个表空间</p><p>知识点：</p><p>查看 Mysql 变量：<br><code>show variables like &#39;innodb_file_per_table&#39;;</code></p><p>从idb文件提取表结构数据：<br>（在cmd运行）<br><code>ibd2sdi xxx.ibd</code></p><p>InnoDB 逻辑存储结构：<br><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/InnoDB%E9%80%BB%E8%BE%91%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84.png" alt="InnoDB逻辑存储结构" title="InnoDB逻辑存储结构"></p><h3 id="1-2-MyISAM"><a href="#1-2-MyISAM" class="headerlink" title="1.2 MyISAM"></a>1.2 MyISAM</h3><p>MyISAM 是 MySQL 早期的默认存储引擎。</p><p>特点：</p><ul><li>不支持事务，不支持外键</li><li>支持表锁，不支持行锁</li><li>访问速度快</li></ul><p>文件：</p><ul><li>xxx.sdi: 存储表结构信息</li><li>xxx.MYD: 存储数据</li><li>xxx.MYI: 存储索引</li></ul><h3 id="1-3-Memory"><a href="#1-3-Memory" class="headerlink" title="1.3 Memory"></a>1.3 Memory</h3><p>Memory 引擎的表数据是存储在内存中的，受硬件问题、断电问题的影响，只能将这些表作为临时表或缓存使用。</p><p>特点：</p><ul><li>存放在内存中，速度快</li><li>hash索引（默认）</li></ul><p>文件：</p><ul><li>xxx.sdi: 存储表结构信息</li></ul><h3 id="1-4-存储引擎特点"><a href="#1-4-存储引擎特点" class="headerlink" title="1.4 存储引擎特点"></a>1.4 存储引擎特点</h3><table><thead><tr><th align="center">特点</th><th align="center">InnoDB</th><th align="center">MyISAM</th><th align="center">Memory</th></tr></thead><tbody><tr><td align="center">存储限制</td><td align="center">64TB</td><td align="center">有</td><td align="center">有</td></tr><tr><td align="center">事务安全</td><td align="center">支持</td><td align="center">-</td><td align="center">-</td></tr><tr><td align="center">锁机制</td><td align="center">行锁</td><td align="center">表锁</td><td align="center">表锁</td></tr><tr><td align="center">B+tree索引</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">Hash索引</td><td align="center">-</td><td align="center">-</td><td align="center">支持</td></tr><tr><td align="center">全文索引</td><td align="center">支持（5.6版本之后）</td><td align="center">支持</td><td align="center">-</td></tr><tr><td align="center">空间使用</td><td align="center">高</td><td align="center">低</td><td align="center">N&#x2F;A</td></tr><tr><td align="center">内存使用</td><td align="center">高</td><td align="center">低</td><td align="center">中等</td></tr><tr><td align="center">批量插入速度</td><td align="center">低</td><td align="center">高</td><td align="center">高</td></tr><tr><td align="center">支持外键</td><td align="center">支持</td><td align="center">-</td><td align="center">-</td></tr></tbody></table><h3 id="1-5-存储引擎的选择"><a href="#1-5-存储引擎的选择" class="headerlink" title="1.5 存储引擎的选择"></a>1.5 存储引擎的选择</h3><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p><ul><li>InnoDB: 如果应用对事物的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操作除了插入和查询之外，还包含很多的更新、删除操作，则 InnoDB 是比较合适的选择</li><li>MyISAM: 如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不高，那这个存储引擎是非常合适的。</li><li>Memory: 将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。Memory 的缺陷是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性</li></ul><p>电商中的足迹和评论适合使用 MyISAM 引擎，缓存适合使用 Memory 引擎。</p><h2 id="二-性能分析"><a href="#二-性能分析" class="headerlink" title="二.性能分析"></a>二.性能分析</h2><h3 id="2-1-查看执行频次"><a href="#2-1-查看执行频次" class="headerlink" title="2.1 查看执行频次"></a>2.1 查看执行频次</h3><p>查看当前数据库的 INSERT, UPDATE, DELETE, SELECT 访问频次：<br><code>SHOW GLOBAL STATUS LIKE &#39;Com_______&#39;;</code> 或者 <code>SHOW SESSION STATUS LIKE &#39;Com_______&#39;;</code><br>例：<code>show global status like &#39;Com_______&#39;</code></p><h3 id="2-2-慢查询日志"><a href="#2-2-慢查询日志" class="headerlink" title="2.2 慢查询日志"></a>2.2 慢查询日志</h3><p>慢查询日志记录了所有执行时间超过指定参数（long_query_time，单位：秒，默认10秒）的所有SQL语句的日志。<br>MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件（&#x2F;etc&#x2F;my.cnf）中配置如下信息：<br>    # 开启慢查询日志开关<br>    slow_query_log&#x3D;1<br>    # 设置慢查询日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志<br>    long_query_time&#x3D;2<br>更改后记得重启MySQL服务，日志文件位置：&#x2F;var&#x2F;lib&#x2F;mysql&#x2F;localhost-slow.log</p><p>查看慢查询日志开关状态：<br><code>show variables like &#39;slow_query_log&#39;;</code></p><h3 id="2-3-profile"><a href="#2-3-profile" class="headerlink" title="2.3 profile"></a>2.3 profile</h3><p>show profile 能在做SQL优化时帮我们了解时间都耗费在哪里。通过 have_profiling 参数，能看到当前 MySQL 是否支持 profile 操作：<br><code>SELECT @@have_profiling;</code><br>profiling 默认关闭，可以通过set语句在session&#x2F;global级别开启 profiling：<br><code>SET profiling = 1;</code><br>查看所有语句的耗时：<br><code>show profiles;</code><br>查看指定query_id的SQL语句各个阶段的耗时：<br><code>show profile for query query_id;</code><br>查看指定query_id的SQL语句CPU的使用情况<br><code>show profile cpu for query query_id;</code></p><h3 id="2-4-explain"><a href="#2-4-explain" class="headerlink" title="2.4 explain"></a>2.4 explain</h3><p>EXPLAIN 或者 DESC 命令获取 MySQL 如何执行 SELECT 语句的信息，包括在 SELECT 语句执行过程中表如何连接和连接的顺序。<br>语法：<br>    # 直接在select语句之前加上关键字 explain &#x2F; desc<br>​EXPLAIN SELECT 字段列表 FROM 表名 HWERE 条件;</p><p>EXPLAIN 各字段含义：</p><ul><li>id：select 查询的序列号，表示查询中执行 select 子句或者操作表的顺序（id相同，执行顺序从上到下；id不同，值越大越先执行）</li><li>select_type：表示 SELECT 的类型，常见取值有 SIMPLE（简单表，即不适用表连接或者子查询）、PRIMARY（主查询，即外层的查询）、UNION（UNION中的第二个或者后面的查询语句）、SUBQUERY（SELECT&#x2F;WHERE之后包含了子查询）等</li><li>type：表示连接类型，性能由好到差的连接类型为 NULL、system、const、eq_ref、ref、range、index、all</li><li>possible_key：可能应用在这张表上的索引，一个或多个</li><li>Key：实际使用的索引，如果为 NULL，则没有使用索引</li><li>Key_len：表示索引中使用的字节数，该值为索引字段最大可能长度，并非实际使用长度，在不损失精确性的前提下，长度越短越好</li><li>rows：MySQL认为必须要执行的行数，在InnoDB引擎的表中，是一个估计值，可能并不总是准确的</li><li>filtered：表示返回结果的行数占需读取行数的百分比，filtered的值越大越好</li></ul><h2 id="三-索引"><a href="#三-索引" class="headerlink" title="三.索引"></a>三.索引</h2><p>索引是帮助 MySQL <strong>高效获取数据</strong>的<strong>数据结构（有序）</strong>。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查询算法，这种数据结构就是索引。</p><p>优缺点：</p><p>优点：</p><ul><li>提高数据检索效率，降低数据库的IO成本</li><li>通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗</li></ul><p>缺点：</p><ul><li>索引列也是要占用空间的</li><li>索引大大提高了查询效率，但降低了更新的速度，比如 INSERT、UPDATE、DELETE</li></ul><h3 id="3-1-索引结构"><a href="#3-1-索引结构" class="headerlink" title="3.1 索引结构"></a>3.1 索引结构</h3><table><thead><tr><th align="center">索引结构</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">B+Tree</td><td align="center">最常见的索引类型，大部分引擎都支持B+树索引</td></tr><tr><td align="center">Hash</td><td align="center">底层数据结构是用哈希表实现，只有精确匹配索引列的查询才有效，不支持范围查询</td></tr><tr><td align="center">R-Tree(空间索引)</td><td align="center">空间索引是 MyISAM 引擎的一个特殊索引类型，主要用于地理空间数据类型，通常使用较少</td></tr><tr><td align="center">Full-Text(全文索引)</td><td align="center">是一种通过建立倒排索引，快速匹配文档的方式，类似于 Lucene, Solr, ES</td></tr></tbody></table><table><thead><tr><th align="center">索引</th><th align="center">InnoDB</th><th align="center">MyISAM</th><th align="center">Memory</th></tr></thead><tbody><tr><td align="center">B+Tree索引</td><td align="center">支持</td><td align="center">支持</td><td align="center">支持</td></tr><tr><td align="center">Hash索引</td><td align="center">不支持</td><td align="center">不支持</td><td align="center">支持</td></tr><tr><td align="center">R-Tree索引</td><td align="center">不支持</td><td align="center">支持</td><td align="center">不支持</td></tr><tr><td align="center">Full-text</td><td align="center">5.6版本后支持</td><td align="center">支持</td><td align="center">不支持</td></tr></tbody></table><h4 id="3-1-1-B-Tree"><a href="#3-1-1-B-Tree" class="headerlink" title="3.1.1 B-Tree"></a>3.1.1 B-Tree</h4><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="二叉树" title="二叉树"></p><p>二叉树的缺点可以用红黑树来解决：<br><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E7%BA%A2%E9%BB%91%E6%A0%91.png" alt="红黑树" title="红黑树"><br>红黑树也存在大数据量情况下，层级较深，检索速度慢的问题。</p><p>为了解决上述问题，可以使用 B-Tree 结构。<br>B-Tree (多路平衡查找树) 以一棵最大度数（max-degree，指一个节点的子节点个数）为5（5阶）的 b-tree 为例（每个节点最多存储4个key，5个指针）</p><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/B-Tree%E7%BB%93%E6%9E%84.png" alt="B-Tree结构" title="B-Tree结构"></p><blockquote><p>B-Tree 的数据插入过程动画参照：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=68</a><br>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BTree.html">https://www.cs.usfca.edu/~galles/visualization/BTree.html</a></p></blockquote><h4 id="3-1-2-B-Tree"><a href="#3-1-2-B-Tree" class="headerlink" title="3.1.2 B+Tree"></a>3.1.2 B+Tree</h4><p>结构图：</p><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/B%E5%8A%A0Tree%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="B+Tree结构图" title="B+Tree结构图"></p><blockquote><p>演示地址：<a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html</a></p></blockquote><p>与 B-Tree 的区别：</p><ul><li>所有的数据都会出现在叶子节点</li><li>叶子节点形成一个单向链表</li></ul><p>MySQL 索引数据结构对经典的 B+Tree 进行了优化。在原 B+Tree 的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的 B+Tree，提高区间访问的性能。</p><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/MySQL%20B%E5%8A%A0Tree%20%E7%BB%93%E6%9E%84%E5%9B%BE.png" alt="MySQL B+Tree 结构图" title="MySQL B+Tree 结构图"></p><h4 id="3-1-3-Hash"><a href="#3-1-3-Hash" class="headerlink" title="3.1.3 Hash"></a>3.1.3 Hash</h4><p>哈希索引就是采用一定的hash算法，将键值换算成新的hash值，映射到对应的槽位上，然后存储在hash表中。<br>如果两个（或多个）键值，映射到一个相同的槽位上，他们就产生了hash冲突（也称为hash碰撞），可以通过链表来解决。</p><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Hash%E7%B4%A2%E5%BC%95%E5%8E%9F%E7%90%86%E5%9B%BE.png" alt="Hash索引原理图" title="Hash索引原理图"></p><p>特点：</p><ul><li>Hash索引只能用于对等比较（&#x3D;、in），不支持范围查询（betwwn、&gt;、&lt;、…）</li><li>无法利用索引完成排序操作</li><li>查询效率高，通常只需要一次检索就可以了，效率通常要高于 B+Tree 索引</li></ul><p>存储引擎支持：</p><ul><li>Memory</li><li>InnoDB: 具有自适应hash功能，hash索引是存储引擎根据 B+Tree 索引在指定条件下自动构建的</li></ul><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><ol><li>为什么 InnoDB 存储引擎选择使用 B+Tree 索引结构？</li></ol><ul><li>相对于二叉树，层级更少，搜索效率高</li><li>对于 B-Tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针也跟着减少，要同样保存大量数据，只能增加树的高度，导致性能降低</li><li>相对于 Hash 索引，B+Tree 支持范围匹配及排序操作</li></ul><h3 id="3-2-索引分类"><a href="#3-2-索引分类" class="headerlink" title="3.2 索引分类"></a>3.2 索引分类</h3><table><thead><tr><th align="center">分类</th><th align="center">含义</th><th align="center">特点</th><th align="center">关键字</th></tr></thead><tbody><tr><td align="center">主键索引</td><td align="center">针对于表中主键创建的索引</td><td align="center">默认自动创建，只能有一个</td><td align="center">PRIMARY</td></tr><tr><td align="center">唯一索引</td><td align="center">避免同一个表中某数据列中的值重复</td><td align="center">可以有多个</td><td align="center">UNIQUE</td></tr><tr><td align="center">常规索引</td><td align="center">快速定位特定数据</td><td align="center">可以有多个</td><td align="center"></td></tr><tr><td align="center">全文索引</td><td align="center">全文索引查找的是文本中的关键词，而不是比较索引中的值</td><td align="center">可以有多个</td><td align="center">FULLTEXT</td></tr></tbody></table><p>在 InnoDB 存储引擎中，根据索引的存储形式，又可以分为以下两种：</p><table><thead><tr><th align="center">分类</th><th align="center">含义</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">聚集索引(Clustered Index)</td><td align="center">将数据存储与索引放一块，索引结构的叶子节点保存了行数据</td><td align="center">必须有，而且只有一个</td></tr><tr><td align="center">二级索引(Secondary Index)</td><td align="center">将数据与索引分开存储，索引结构的叶子节点关联的是对应的主键</td><td align="center">可以存在多个</td></tr></tbody></table><p>演示图：</p><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E5%A4%A7%E8%87%B4%E5%8E%9F%E7%90%86.png" alt="大致原理" title="大致原理"><br><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E6%BC%94%E7%A4%BA%E5%9B%BE.png" alt="演示图" title="演示图"></p><p>聚集索引选取规则：</p><ul><li>如果存在主键，主键索引就是聚集索引</li><li>如果不存在主键，将使用第一个唯一(UNIQUE)索引作为聚集索引</li><li>如果表没有主键或没有合适的唯一索引，则 InnoDB 会自动生成一个 rowid 作为隐藏的聚集索引</li></ul><h4 id="思考题"><a href="#思考题" class="headerlink" title="思考题"></a>思考题</h4><p>1. 以下 SQL 语句，哪个执行效率高？为什么？</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select * from user where id = 10;<br>select * from user where name = &#x27;Arm&#x27;;<br>-- 备注：id为主键，name字段创建的有索引<br></code></pre></td></tr></table></figure><p>答：第一条语句，因为第二条需要回表查询，相当于两个步骤。</p><p>2. InnoDB 主键索引的 B+Tree 高度为多少？</p><p>答：假设一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB 的指针占用6个字节的空间，主键假设为bigint，占用字节数为8.<br>可得公式：<code>n * 8 + (n + 1) * 6 = 16 * 1024</code>，其中 8 表示 bigint 占用的字节数，n 表示当前节点存储的key的数量，(n + 1) 表示指针数量（比key多一个）。算出n约为1170。</p><p>如果树的高度为2，那么他能存储的数据量大概为：<code>1171 * 16 = 18736</code>；<br>如果树的高度为3，那么他能存储的数据量大概为：<code>1171 * 1171 * 16 = 21939856</code>。</p><p>另外，如果有成千上万的数据，那么就要考虑分表，涉及运维篇知识。</p><h3 id="3-3-语法"><a href="#3-3-语法" class="headerlink" title="3.3 语法"></a>3.3 语法</h3><p>创建索引：<br><code>CREATE [ UNIQUE | FULLTEXT ] INDEX index_name ON table_name (index_col_name, ...);</code><br>如果不加 CREATE 后面不加索引类型参数，则创建的是常规索引</p><p>查看索引：<br><code>SHOW INDEX FROM table_name;</code></p><p>删除索引：<br><code>DROP INDEX index_name ON table_name;</code></p><p>案例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- name字段为姓名字段，该字段的值可能会重复，为该字段创建索引<br>create index idx_user_name on tb_user(name);<br>-- phone手机号字段的值非空，且唯一，为该字段创建唯一索引<br>create unique index idx_user_phone on tb_user (phone);<br>-- 为profession, age, status创建联合索引<br>create index idx_user_pro_age_stat on tb_user(profession, age, status);<br>-- 为email建立合适的索引来提升查询效率<br>create index idx_user_email on tb_user(email);<br><br>-- 删除索引<br>drop index idx_user_email on tb_user;<br></code></pre></td></tr></table></figure><h3 id="3-4-使用规则"><a href="#3-4-使用规则" class="headerlink" title="3.4 使用规则"></a>3.4 使用规则</h3><h4 id="3-4-1-最左前缀法则"><a href="#3-4-1-最左前缀法则" class="headerlink" title="3.4.1 最左前缀法则"></a>3.4.1 最左前缀法则</h4><p>如果索引关联了多列（联合索引），要遵守最左前缀法则，最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。<br>如果跳跃某一列，索引将部分失效（后面的字段索引失效）。</p><p>联合索引中，出现范围查询（&lt;, &gt;），范围查询右侧的列索引失效。可以用&gt;&#x3D;或者&lt;&#x3D;来规避索引失效问题。</p><h4 id="3-4-2-索引失效情况"><a href="#3-4-2-索引失效情况" class="headerlink" title="3.4.2 索引失效情况"></a>3.4.2 索引失效情况</h4><ol><li>在索引列上进行运算操作，索引将失效。如：<code>explain select * from tb_user where substring(phone, 10, 2) = &#39;15&#39;;</code></li><li>字符串类型字段使用时，不加引号，索引将失效。如：<code>explain select * from tb_user where phone = 17799990015;</code>，此处phone的值没有加引号</li><li>模糊查询中，如果仅仅是尾部模糊匹配，索引不会是失效；如果是头部模糊匹配，索引失效。如：<code>explain select * from tb_user where profession like &#39;%工程&#39;;</code>，前后都有 % 也会失效。</li><li>用 or 分割开的条件，如果 or 其中一个条件的列没有索引，那么涉及的索引都不会被用到。</li><li>如果 MySQL 评估使用索引比全表更慢，则不使用索引。</li></ol><h4 id="3-4-3-SQL-提示"><a href="#3-4-3-SQL-提示" class="headerlink" title="3.4.3 SQL 提示"></a>3.4.3 SQL 提示</h4><p>是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p><p>例如，使用索引：<br><code>explain select * from tb_user use index(idx_user_pro) where profession=&quot;软件工程&quot;;</code><br>不使用哪个索引：<br><code>explain select * from tb_user ignore index(idx_user_pro) where profession=&quot;软件工程&quot;;</code><br>必须使用哪个索引：<br><code>explain select * from tb_user force index(idx_user_pro) where profession=&quot;软件工程&quot;;</code></p><p>use 是建议，实际使用哪个索引 MySQL 还会自己权衡运行速度去更改，force就是无论如何都强制使用该索引。</p><h4 id="3-4-4-覆盖索引-回表查询"><a href="#3-4-4-覆盖索引-回表查询" class="headerlink" title="3.4.4 覆盖索引&amp;回表查询"></a>3.4.4 覆盖索引&amp;回表查询</h4><p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能找到），减少 select *。</p><p>explain 中 extra 字段含义：<br><code>using index condition</code>：查找使用了索引，但是需要回表查询数据<br><code>using where; using index;</code>：查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询</p><p>如果在聚集索引中直接能找到对应的行，则直接返回行数据，只需要一次查询，哪怕是select *；如果在辅助索引中找聚集索引，如<code>select id, name from xxx where name=&#39;xxx&#39;;</code>，也只需要通过辅助索引(name)查找到对应的id，返回name和name索引对应的id即可，只需要一次查询；如果是通过辅助索引查找其他字段，则需要回表查询，如<code>select id, name, gender from xxx where name=&#39;xxx&#39;;</code></p><p>所以尽量不要用<code>select *</code>，容易出现回表查询，降低效率，除非有联合索引包含了所有字段</p><p>面试题：一张表，有四个字段（id, username, password, status），由于数据量大，需要对以下SQL语句进行优化，该如何进行才是最优方案：<br><code>select id, username, password from tb_user where username=&#39;itcast&#39;;</code></p><p>解：给username和password字段建立联合索引，则不需要回表查询，直接覆盖索引</p><h4 id="3-4-5-前缀索引"><a href="#3-4-5-前缀索引" class="headerlink" title="3.4.5 前缀索引"></a>3.4.5 前缀索引</h4><p>当字段类型为字符串（varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率，此时可以只降字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p><p>语法：<code>create index idx_xxxx on table_name(columnn(n));</code><br>前缀长度：可以根据索引的选择性来决定，而选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。<br>求选择性公式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs mysql">select count(distinct email) / count(*) from tb_user;<br>select count(distinct substring(email, 1, 5)) / count(*) from tb_user;<br></code></pre></td></tr></table></figure><p>show index 里面的sub_part可以看到接取的长度</p><h4 id="3-4-6-单列索引-联合索引"><a href="#3-4-6-单列索引-联合索引" class="headerlink" title="3.4.6 单列索引&amp;联合索引"></a>3.4.6 单列索引&amp;联合索引</h4><p>单列索引：即一个索引只包含单个列<br>联合索引：即一个索引包含了多个列<br>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p><p>单列索引情况：<br><code>explain select id, phone, name from tb_user where phone = &#39;17799990010&#39; and name = &#39;韩信&#39;;</code><br>这句只会用到phone索引字段</p><h5 id="注意事项-2"><a href="#注意事项-2" class="headerlink" title="注意事项"></a>注意事项</h5><ul><li>多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询</li></ul><h3 id="3-5-设计原则"><a href="#3-5-设计原则" class="headerlink" title="3.5 设计原则"></a>3.5 设计原则</h3><ol><li>针对于数据量较大，且查询比较频繁的表建立索引</li><li>针对于常作为查询条件（where）、排序（order by）、分组（group by）操作的字段建立索引</li><li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高</li><li>如果是字符串类型的字段，字段长度较长，可以针对于字段的特点，建立前缀索引</li><li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率</li><li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价就越大，会影响增删改的效率</li><li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询</li></ol><h2 id="四-SQL-优化"><a href="#四-SQL-优化" class="headerlink" title="四.SQL 优化"></a>四.SQL 优化</h2><h3 id="4-1-插入数据"><a href="#4-1-插入数据" class="headerlink" title="4.1 插入数据"></a>4.1 插入数据</h3><p>普通插入：</p><ol><li>采用批量插入（一次插入的数据不建议超过1000条）</li><li>手动提交事务</li><li>主键顺序插入</li></ol><p>大批量插入：<br>如果一次性需要插入大批量数据，使用insert语句插入性能较低，此时可以使用MySQL数据库提供的load指令插入。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs mysql"># 客户端连接服务端时，加上参数 --local-infile（这一行在bash/cmd界面输入）<br>mysql --local-infile -u root -p<br># 设置全局参数local_infile为1，开启从本地加载文件导入数据的开关<br>set global local_infile = 1;<br>select @@local_infile;<br># 执行load指令将准备好的数据，加载到表结构中<br>load data local infile &#x27;/root/sql1.log&#x27; into table &#x27;tb_user&#x27; fields terminated by &#x27;,&#x27; lines terminated by &#x27;\n&#x27;;<br></code></pre></td></tr></table></figure><h3 id="4-2-主键优化"><a href="#4-2-主键优化" class="headerlink" title="4.2 主键优化"></a>4.2 主键优化</h3><p>数据组织方式：在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表（Index organized table, IOT）</p><p>页分裂：页可以为空，也可以填充一般，也可以填充100%，每个页包含了2-N行数据（如果一行数据过大，会行溢出），根据主键排列。<br>页合并：当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged）为删除并且它的空间变得允许被其他记录声明使用。当页中删除的记录到达 MERGE_THRESHOLD（默认为页的50%），InnoDB会开始寻找最靠近的页（前后）看看是否可以将这两个页合并以优化空间使用。</p><p>MERGE_THRESHOLD：合并页的阈值，可以自己设置，在创建表或创建索引时指定</p><blockquote><p>文字说明不够清晰明了，具体可以看视频里的PPT演示过程：<a href="https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90">https://www.bilibili.com/video/BV1Kr4y1i7ru?p=90</a></p></blockquote><p>主键设计原则：</p><ul><li>满足业务需求的情况下，尽量降低主键的长度</li><li>插入数据时，尽量选择顺序插入，选择使用 AUTO_INCREMENT 自增主键</li><li>尽量不要使用 UUID 做主键或者是其他的自然主键，如身份证号</li><li>业务操作时，避免对主键的修改</li></ul><h3 id="4-3-order-by优化"><a href="#4-3-order-by优化" class="headerlink" title="4.3 order by优化"></a>4.3 order by优化</h3><ol><li>Using filesort：通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区 sort buffer 中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫 FileSort 排序</li><li>Using index：通过有序索引顺序扫描直接返回有序数据，这种情况即为 using index，不需要额外排序，操作效率高</li></ol><p>如果order by字段全部使用升序排序或者降序排序，则都会走索引，但是如果一个字段升序排序，另一个字段降序排序，则不会走索引，explain的extra信息显示的是<code>Using index, Using filesort</code>，如果要优化掉Using filesort，则需要另外再创建一个索引，如：<code>create index idx_user_age_phone_ad on tb_user(age asc, phone desc);</code>，此时使用<code>select id, age, phone from tb_user order by age asc, phone desc;</code>会全部走索引</p><p>总结：</p><ul><li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则</li><li>尽量使用覆盖索引</li><li>多字段排序，一个升序一个降序，此时需要注意联合索引在创建时的规则（ASC&#x2F;DESC）</li><li>如果不可避免出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size（默认256k）</li></ul><h3 id="4-5-group-by优化"><a href="#4-5-group-by优化" class="headerlink" title="4.5 group by优化"></a>4.5 group by优化</h3><ul><li>在分组操作时，可以通过索引来提高效率</li><li>分组操作时，索引的使用也是满足最左前缀法则的</li></ul><p>如索引为<code>idx_user_pro_age_stat</code>，则句式可以是<code>select ... where profession order by age</code>，这样也符合最左前缀法则</p><h3 id="4-6-limit优化"><a href="#4-6-limit优化" class="headerlink" title="4.6 limit优化"></a>4.6 limit优化</h3><p>常见的问题如<code>limit 2000000, 10</code>，此时需要 MySQL 排序前2000000条记录，但仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。<br>优化方案：一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化</p><p>例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs mysql">-- 此语句耗时很长<br>select * from tb_sku limit 9000000, 10;<br>-- 通过覆盖索引加快速度，直接通过主键索引进行排序及查询<br>select id from tb_sku order by id limit 9000000, 10;<br>-- 下面的语句是错误的，因为 MySQL 不支持 in 里面使用 limit<br>-- select * from tb_sku where id in (select id from tb_sku order by id limit 9000000, 10);<br>-- 通过连表查询即可实现第一句的效果，并且能达到第二句的速度<br>select * from tb_sku as s, (select id from tb_sku order by id limit 9000000, 10) as a where s.id = a.id;<br></code></pre></td></tr></table></figure><h3 id="4-7-count优化"><a href="#4-7-count优化" class="headerlink" title="4.7 count优化"></a>4.7 count优化</h3><p>MyISAM 引擎把一个表的总行数存在了磁盘上，因此执行 count(*) 的时候会直接返回这个数，效率很高（前提是不适用where）；<br>InnoDB 在执行 count(*) 时，需要把数据一行一行地从引擎里面读出来，然后累计计数。<br>优化方案：自己计数，如创建key-value表存储在内存或硬盘，或者是用redis</p><p>count的几种用法：</p><ul><li>如果count函数的参数（count里面写的那个字段）不是NULL（字段值不为NULL），累计值就加一，最后返回累计值</li><li>用法：count(*)、count(主键)、count(字段)、count(1)</li><li>count(主键)跟count(*)一样，因为主键不能为空；count(字段)只计算字段值不为NULL的行；count(1)引擎会为每行添加一个1，然后就count这个1，返回结果也跟count(*)一样；count(null)返回0</li></ul><p>各种用法的性能：</p><ul><li>count(主键)：InnoDB引擎会遍历整张表，把每行的主键id值都取出来，返回给服务层，服务层拿到主键后，直接按行进行累加（主键不可能为空）</li><li>count(字段)：没有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断是否为null，不为null，计数累加；有not null约束的话，InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加</li><li>count(1)：InnoDB 引擎遍历整张表，但不取值。服务层对于返回的每一层，放一个数字 1 进去，直接按行进行累加</li><li>count(*)：InnoDB 引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加</li></ul><p>按效率排序：count(字段) &lt; count(主键) &lt; count(1) &lt; count(*)，所以尽量使用 count(*)</p><h3 id="4-8-update优化（避免行锁升级为表锁）"><a href="#4-8-update优化（避免行锁升级为表锁）" class="headerlink" title="4.8 update优化（避免行锁升级为表锁）"></a>4.8 update优化（避免行锁升级为表锁）</h3><p>InnoDB 的行锁是针对索引加的锁，不是针对记录加的锁，并且该索引不能失效，否则会从行锁升级为表锁。</p><p>如以下两条语句：<br><code>update student set no = &#39;123&#39; where id = 1;</code>，这句由于id有主键索引，所以只会锁这一行；<br><code>update student set no = &#39;123&#39; where name = &#39;test&#39;;</code>，这句由于name没有索引，所以会把整张表都锁住进行数据更新，解决方法是给name字段添加索引</p><h1 id="数据类型汇总"><a href="#数据类型汇总" class="headerlink" title="数据类型汇总"></a>数据类型汇总</h1><h2 id="一-整型"><a href="#一-整型" class="headerlink" title="一.整型"></a>一.整型</h2><table><thead><tr><th align="center">类型名称</th><th align="center">取值范围</th><th align="center">大小</th></tr></thead><tbody><tr><td align="center">TINYINT</td><td align="center">-128〜127</td><td align="center">1个字节</td></tr><tr><td align="center">SMALLINT</td><td align="center">-32768〜32767</td><td align="center">2个宇节</td></tr><tr><td align="center">MEDIUMINT</td><td align="center">-8388608〜8388607</td><td align="center">3个字节</td></tr><tr><td align="center">INT (INTEGHR)</td><td align="center">-2147483648〜2147483647</td><td align="center">4个字节</td></tr><tr><td align="center">BIGINT</td><td align="center">-9223372036854775808〜9223372036854775807</td><td align="center">8个字节</td></tr></tbody></table><p>无符号在数据类型后加 unsigned 关键字。</p><h2 id="二-浮点型"><a href="#二-浮点型" class="headerlink" title="二.浮点型"></a>二.浮点型</h2><table><thead><tr><th align="center">类型名称</th><th align="center">说明</th><th align="center">存储需求</th></tr></thead><tbody><tr><td align="center">FLOAT</td><td align="center">单精度浮点数</td><td align="center">4 个字节</td></tr><tr><td align="center">DOUBLE</td><td align="center">双精度浮点数</td><td align="center">8 个字节</td></tr><tr><td align="center">DECIMAL (M, D)，DEC</td><td align="center">压缩的“严格”定点数</td><td align="center">M+2 个字节</td></tr></tbody></table><h2 id="三-日期和时间"><a href="#三-日期和时间" class="headerlink" title="三.日期和时间"></a>三.日期和时间</h2><table><thead><tr><th align="center">类型名称</th><th align="center">日期格式</th><th align="center">日期范围</th><th align="center">存储需求</th></tr></thead><tbody><tr><td align="center">YEAR</td><td align="center">YYYY</td><td align="center">1901 ~ 2155</td><td align="center">1 个字节</td></tr><tr><td align="center">TIME</td><td align="center">HH:MM:SS</td><td align="center">-838:59:59 ~ 838:59:59</td><td align="center">3 个字节</td></tr><tr><td align="center">DATE</td><td align="center">YYYY-MM-DD</td><td align="center">1000-01-01 ~ 9999-12-3</td><td align="center">3 个字节</td></tr><tr><td align="center">DATETIME</td><td align="center">YYYY-MM-DD HH:MM:SS</td><td align="center">1000-01-01 00:00:00 ~ 9999-12-31 23:59:59</td><td align="center">8 个字节</td></tr><tr><td align="center">TIMESTAMP</td><td align="center">YYYY-MM-DD HH:MM:SS</td><td align="center">1980-01-01 00:00:01 UTC ~ 2040-01-19 03:14:07 UTC</td><td align="center">4 个字节</td></tr></tbody></table><h2 id="四-字符串"><a href="#四-字符串" class="headerlink" title="四.字符串"></a>四.字符串</h2><table><thead><tr><th align="center">类型名称</th><th align="center">说明</th><th align="center">存储需求</th></tr></thead><tbody><tr><td align="center">CHAR(M)</td><td align="center">固定长度非二进制字符串</td><td align="center">M 字节，1&lt;&#x3D;M&lt;&#x3D;255</td></tr><tr><td align="center">VARCHAR(M)</td><td align="center">变长非二进制字符串</td><td align="center">L+1字节，在此，L&lt; &#x3D; M和 1&lt;&#x3D;M&lt;&#x3D;255</td></tr><tr><td align="center">TINYTEXT</td><td align="center">非常小的非二进制字符串</td><td align="center">L+1字节，在此，L&lt;2^8</td></tr><tr><td align="center">TEXT</td><td align="center">小的非二进制字符串</td><td align="center">L+2字节，在此，L&lt;2^16</td></tr><tr><td align="center">MEDIUMTEXT</td><td align="center">中等大小的非二进制字符串</td><td align="center">L+3字节，在此，L&lt;2^24</td></tr><tr><td align="center">LONGTEXT</td><td align="center">大的非二进制字符串</td><td align="center">L+4字节，在此，L&lt;2^32</td></tr><tr><td align="center">ENUM</td><td align="center">枚举类型，只能有一个枚举字符串值</td><td align="center">1或2个字节，取决于枚举值的数目 (最大值为65535)</td></tr><tr><td align="center">SET</td><td align="center">一个设置，字符串对象可以有零个或 多个SET成员</td><td align="center">1、2、3、4或8个字节，取决于集合 成员的数量（最多64个成员）</td></tr></tbody></table><h2 id="五-二进制类型"><a href="#五-二进制类型" class="headerlink" title="五.二进制类型"></a>五.二进制类型</h2><table><thead><tr><th align="center">类型名称</th><th align="center">说明</th><th align="center">存储需求</th></tr></thead><tbody><tr><td align="center">BIT(M)</td><td align="center">位字段类型</td><td align="center">大约 (M+7)&#x2F;8 字节</td></tr><tr><td align="center">BINARY(M)</td><td align="center">固定长度二进制字符串</td><td align="center">M 字节</td></tr><tr><td align="center">VARBINARY (M)</td><td align="center">可变长度二进制字符串</td><td align="center">M+1 字节</td></tr><tr><td align="center">TINYBLOB (M)</td><td align="center">非常小的BLOB</td><td align="center">L+1 字节，在此，L&lt;2^8</td></tr><tr><td align="center">BLOB (M)</td><td align="center">小 BLOB</td><td align="center">L+2 字节，在此，L&lt;2^16</td></tr><tr><td align="center">MEDIUMBLOB (M)</td><td align="center">中等大小的BLOB</td><td align="center">L+3 字节，在此，L&lt;2^24</td></tr><tr><td align="center">LONGBLOB (M)</td><td align="center">非常大的BLOB</td><td align="center">L+4 字节，在此，L&lt;2^32</td></tr></tbody></table><h1 id="权限一览表"><a href="#权限一览表" class="headerlink" title="权限一览表"></a>权限一览表</h1><blockquote><p>具体权限的作用详见<a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html" title="官方文档">官方文档</a></p></blockquote><p>GRANT 和 REVOKE 允许的静态权限</p><table><thead><tr><th align="center">Privilege</th><th align="center">Grant Table Column</th><th align="center">Context</th></tr></thead><tbody><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_all"><code>ALL [PRIVILEGES]</code></a></td><td align="center">Synonym for “all privileges”</td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter"><code>ALTER</code></a></td><td align="center"><code>Alter_priv</code></td><td align="center">Tables</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_alter-routine"><code>ALTER ROUTINE</code></a></td><td align="center"><code>Alter_routine_priv</code></td><td align="center">Stored routines</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create"><code>CREATE</code></a></td><td align="center"><code>Create_priv</code></td><td align="center">Databases, tables, or indexes</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-role"><code>CREATE ROLE</code></a></td><td align="center"><code>Create_role_priv</code></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-routine"><code>CREATE ROUTINE</code></a></td><td align="center"><code>Create_routine_priv</code></td><td align="center">Stored routines</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-tablespace"><code>CREATE TABLESPACE</code></a></td><td align="center"><code>Create_tablespace_priv</code></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-temporary-tables"><code>CREATE TEMPORARY TABLES</code></a></td><td align="center"><code>Create_tmp_table_priv</code></td><td align="center">Tables</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-user"><code>CREATE USER</code></a></td><td align="center"><code>Create_user_priv</code></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_create-view"><code>CREATE VIEW</code></a></td><td align="center"><code>Create_view_priv</code></td><td align="center">Views</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_delete"><code>DELETE</code></a></td><td align="center"><code>Delete_priv</code></td><td align="center">Tables</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop"><code>DROP</code></a></td><td align="center"><code>Drop_priv</code></td><td align="center">Databases, tables, or views</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_drop-role"><code>DROP ROLE</code></a></td><td align="center"><code>Drop_role_priv</code></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_event"><code>EVENT</code></a></td><td align="center"><code>Event_priv</code></td><td align="center">Databases</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_execute"><code>EXECUTE</code></a></td><td align="center"><code>Execute_priv</code></td><td align="center">Stored routines</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_file"><code>FILE</code></a></td><td align="center"><code>File_priv</code></td><td align="center">File access on server host</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_grant-option"><code>GRANT OPTION</code></a></td><td align="center"><code>Grant_priv</code></td><td align="center">Databases, tables, or stored routines</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_index"><code>INDEX</code></a></td><td align="center"><code>Index_priv</code></td><td align="center">Tables</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_insert"><code>INSERT</code></a></td><td align="center"><code>Insert_priv</code></td><td align="center">Tables or columns</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_lock-tables"><code>LOCK TABLES</code></a></td><td align="center"><code>Lock_tables_priv</code></td><td align="center">Databases</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_process"><code>PROCESS</code></a></td><td align="center"><code>Process_priv</code></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_proxy"><code>PROXY</code></a></td><td align="center">See <code>proxies_priv</code> table</td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_references"><code>REFERENCES</code></a></td><td align="center"><code>References_priv</code></td><td align="center">Databases or tables</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_reload"><code>RELOAD</code></a></td><td align="center"><code>Reload_priv</code></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-client"><code>REPLICATION CLIENT</code></a></td><td align="center"><code>Repl_client_priv</code></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave"><code>REPLICATION SLAVE</code></a></td><td align="center"><code>Repl_slave_priv</code></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_select"><code>SELECT</code></a></td><td align="center"><code>Select_priv</code></td><td align="center">Tables or columns</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-databases"><code>SHOW DATABASES</code></a></td><td align="center"><code>Show_db_priv</code></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-view"><code>SHOW VIEW</code></a></td><td align="center"><code>Show_view_priv</code></td><td align="center">Views</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_shutdown"><code>SHUTDOWN</code></a></td><td align="center"><code>Shutdown_priv</code></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_super"><code>SUPER</code></a></td><td align="center"><code>Super_priv</code></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_trigger"><code>TRIGGER</code></a></td><td align="center"><code>Trigger_priv</code></td><td align="center">Tables</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_update"><code>UPDATE</code></a></td><td align="center"><code>Update_priv</code></td><td align="center">Tables or columns</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_usage"><code>USAGE</code></a></td><td align="center">Synonym for “no privileges”</td><td align="center">Server administration</td></tr></tbody></table><p>GRANT 和 REVOKE 允许的动态权限</p><table><thead><tr><th align="center">Privilege</th><th align="center">Context</th></tr></thead><tbody><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_application-password-admin"><code>APPLICATION_PASSWORD_ADMIN</code></a></td><td align="center">Dual password administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_audit-abort-exempt"><code>AUDIT_ABORT_EXEMPT</code></a></td><td align="center">Allow queries blocked by audit log filter</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_audit-admin"><code>AUDIT_ADMIN</code></a></td><td align="center">Audit log administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_authentication-policy-admin"><code>AUTHENTICATION_POLICY_ADMIN</code></a></td><td align="center">Authentication administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_backup-admin"><code>BACKUP_ADMIN</code></a></td><td align="center">Backup administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_binlog-admin"><code>BINLOG_ADMIN</code></a></td><td align="center">Backup and Replication administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_binlog-encryption-admin"><code>BINLOG_ENCRYPTION_ADMIN</code></a></td><td align="center">Backup and Replication administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_clone-admin"><code>CLONE_ADMIN</code></a></td><td align="center">Clone administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_connection-admin"><code>CONNECTION_ADMIN</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_encryption-key-admin"><code>ENCRYPTION_KEY_ADMIN</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-admin"><code>FIREWALL_ADMIN</code></a></td><td align="center">Firewall administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-exempt"><code>FIREWALL_EXEMPT</code></a></td><td align="center">Firewall administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_firewall-user"><code>FIREWALL_USER</code></a></td><td align="center">Firewall administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-optimizer-costs"><code>FLUSH_OPTIMIZER_COSTS</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-status"><code>FLUSH_STATUS</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-tables"><code>FLUSH_TABLES</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_flush-user-resources"><code>FLUSH_USER_RESOURCES</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-admin"><code>GROUP_REPLICATION_ADMIN</code></a></td><td align="center">Replication administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_group-replication-stream"><code>GROUP_REPLICATION_STREAM</code></a></td><td align="center">Replication administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_innodb-redo-log-archive"><code>INNODB_REDO_LOG_ARCHIVE</code></a></td><td align="center">Redo log archiving administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_ndb-stored-user"><code>NDB_STORED_USER</code></a></td><td align="center">NDB Cluster</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_passwordless-user-admin"><code>PASSWORDLESS_USER_ADMIN</code></a></td><td align="center">Authentication administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_persist-ro-variables-admin"><code>PERSIST_RO_VARIABLES_ADMIN</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-applier"><code>REPLICATION_APPLIER</code></a></td><td align="center"><code>PRIVILEGE_CHECKS_USER</code> for a replication channel</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_replication-slave-admin"><code>REPLICATION_SLAVE_ADMIN</code></a></td><td align="center">Replication administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_resource-group-admin"><code>RESOURCE_GROUP_ADMIN</code></a></td><td align="center">Resource group administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_resource-group-user"><code>RESOURCE_GROUP_USER</code></a></td><td align="center">Resource group administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_role-admin"><code>ROLE_ADMIN</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_session-variables-admin"><code>SESSION_VARIABLES_ADMIN</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_set-user-id"><code>SET_USER_ID</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_show-routine"><code>SHOW_ROUTINE</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-user"><code>SYSTEM_USER</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_system-variables-admin"><code>SYSTEM_VARIABLES_ADMIN</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_table-encryption-admin"><code>TABLE_ENCRYPTION_ADMIN</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_version-token-admin"><code>VERSION_TOKEN_ADMIN</code></a></td><td align="center">Server administration</td></tr><tr><td align="center"><a href="https://dev.mysql.com/doc/refman/8.0/en/privileges-provided.html#priv_xa-recover-admin"><code>XA_RECOVER_ADMIN</code></a></td><td align="center">Server administration</td></tr></tbody></table><h1 id="图形化界面工具"><a href="#图形化界面工具" class="headerlink" title="图形化界面工具"></a>图形化界面工具</h1><ul><li>Workbench(免费): <a href="http://dev.mysql.com/downloads/workbench/">http://dev.mysql.com/downloads/workbench/</a></li><li>navicat(收费，试用版30天): <a href="https://www.navicat.com/en/download/navicat-for-mysql">https://www.navicat.com/en/download/navicat-for-mysql</a></li><li>Sequel Pro(开源免费，仅支持Mac OS): <a href="http://www.sequelpro.com/">http://www.sequelpro.com/</a></li><li>HeidiSQL(免费): <a href="http://www.heidisql.com/">http://www.heidisql.com/</a></li><li>phpMyAdmin(免费): <a href="https://www.phpmyadmin.net/">https://www.phpmyadmin.net/</a></li><li>SQLyog: <a href="https://sqlyog.en.softonic.com/">https://sqlyog.en.softonic.com/</a></li></ul><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><ol><li>在SQL语句之后加上<code>\G</code>会将结果的表格形式转换成行文本形式</li><li>查看Mysql数据库占用空间：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mysql">SELECT table_schema &quot;Database Name&quot;<br>     , SUM(data_length + index_length) / (1024 * 1024) &quot;Database Size in MB&quot;<br>FROM information_schema.TABLES<br>GROUP BY table_schema;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>MySQL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Typora使用语法格式</title>
    <link href="/2020/07/13/Typora%20%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/"/>
    <url>/2020/07/13/Typora%20%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="Typora使用语法格式"><a href="#Typora使用语法格式" class="headerlink" title="Typora使用语法格式"></a>Typora使用语法格式</h1><h2 id="一-标题"><a href="#一-标题" class="headerlink" title="一.标题"></a>一.标题</h2><ul><li>一级标题<strong>格式</strong>：# + 空格 + 一级标题</li><li>二级标题<strong>格式</strong>：## + 空格 + 二级标题</li><li>三级标题<strong>格式</strong>：### + 空格 + 三级标题</li><li>四级标题<strong>格式</strong>：#### + 空格 + 四级标题</li><li>以此类推……</li></ul><h2 id="二-字体"><a href="#二-字体" class="headerlink" title="二.字体"></a>二.字体</h2><ol><li>加粗<strong>格式</strong>：* * + 内容 + * *          <strong>举例</strong>：<strong>加粗</strong></li><li>斜体<strong>格式</strong>：* + 内容 + *               <strong>举例</strong>：<em>斜体</em></li><li>斜体加粗<strong>格式</strong>：* * * + 内容 + * * *     <strong>举例</strong>：<em><strong>斜体加粗</strong></em></li><li>删除线<strong>格式</strong>：~~ 内容 ~~              <strong>举例</strong>：<del>删除线</del></li><li>高亮<strong>格式</strong>：&#x3D;&#x3D; 内容 &#x3D;&#x3D;                 <strong>举例</strong>：&#x3D;&#x3D;高亮&#x3D;&#x3D;</li></ol><h2 id="三-引用"><a href="#三-引用" class="headerlink" title="三.引用"></a>三.引用</h2><p><strong>格式</strong>：&gt; + 引用文字</p><p><strong>举例</strong>：</p><blockquote><p>一级引用</p><blockquote><p>二级引用</p><blockquote><p>三级引用</p></blockquote></blockquote></blockquote><h2 id="四-分割线"><a href="#四-分割线" class="headerlink" title="四.分割线"></a>四.分割线</h2><p><strong>格式</strong>：相连的三个—</p><p><strong>举例</strong>：</p><hr><h2 id="五-图片"><a href="#五-图片" class="headerlink" title="五.图片"></a>五.图片</h2><p><strong>格式</strong>： ![Alt] (Address “Title”)</p><ul><li>Alt：指定图片链接失效时显示的提示文字</li><li>Address：指图片的本地地址或者网络地址</li><li>Title：指图片的标题，当鼠标移到图片上时显示的内容</li></ul><p><strong>举例</strong>：</p><p><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Typora%E6%8F%92%E5%9B%BE%E4%B8%BE%E4%BE%8B.png" alt="图片已经失效" title="这是Typora插图举例"></p><p><strong>注意</strong>：如果需要更改图片的大小、宽度等属性，可以鼠标右击图片以后然后更改HTML代码以获得更好的体验</p><p><strong>举例</strong>：</p><div style="text-align: center;"><img style="border-radius: 20px;" src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Typora%E6%8F%92%E5%9B%BE%E4%B8%BE%E4%BE%8B.png" alt="图片已经失效" title="这是Typora插图举例" style="zoom: 50%;" width="720" /></div><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;text-align: center;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">img</span> //<span class="hljs-attr">设置圆角属性</span></span><br><span class="hljs-tag">         <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;border-radius: 20px;&quot;</span></span><br><span class="hljs-tag">         //<span class="hljs-attr">指定地址源--可本地</span>，<span class="hljs-attr">也可网络</span></span><br><span class="hljs-tag">         <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/Typora%E6%8F%92%E5%9B%BE%E4%B8%BE%E4%BE%8B.png&quot;</span> </span><br><span class="hljs-tag">         //<span class="hljs-attr">指定图片链接失效时显示的提示文字</span></span><br><span class="hljs-tag">         <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;图片已经失效&quot;</span> </span><br><span class="hljs-tag">         //<span class="hljs-attr">图片的标题</span>，<span class="hljs-attr">鼠标置有于上方后呈现</span></span><br><span class="hljs-tag">         <span class="hljs-attr">title</span>=<span class="hljs-string">&quot;这是Typora插图举例&quot;</span> </span><br><span class="hljs-tag">         //<span class="hljs-attr">样式</span></span><br><span class="hljs-tag">         <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;zoom: 50%;&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="六-超链接"><a href="#六-超链接" class="headerlink" title="六.超链接"></a>六.超链接</h2><p><strong>格式</strong>：[超链接名字] (超链接地址)</p><p><strong>举例</strong>：</p><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs scss">网络地址：<span class="hljs-selector-attr">[百度]</span>(http://www.baidu.com)<br>本地地址：<span class="hljs-selector-attr">[Typora插图举例]</span>(./Typora插图举例.png)<br></code></pre></td></tr></table></figure><ul><li>网络地址：<a href="http://www.baidu.com/">百度</a></li><li>本地地址：<a href="./Typora%E6%8F%92%E5%9B%BE%E4%B8%BE%E4%BE%8B.png">Typora插图举例</a></li></ul><h2 id="七-列表"><a href="#七-列表" class="headerlink" title="七.列表"></a>七.列表</h2><h3 id="1-无序列表"><a href="#1-无序列表" class="headerlink" title="1.无序列表"></a>1.无序列表</h3><p><strong>格式</strong>：- + 空格 + 内容</p><p><strong>举例</strong>：</p><ul><li>无序列表</li></ul><h3 id="2-有序列表"><a href="#2-有序列表" class="headerlink" title="2.有序列表"></a>2.有序列表</h3><p><strong>格式</strong>：数字序号 + . + 空格 + 内容</p><p><strong>举例</strong>：</p><ol><li>有序列表</li></ol><h3 id="3-子列表"><a href="#3-子列表" class="headerlink" title="3.子列表"></a>3.子列表</h3><p><strong>格式</strong>：在子列表前按下tab键即可构成子列表</p><p><strong>举例</strong>：</p><ul><li>根列表<ul><li>子列表1<ul><li>子列表2</li></ul></li></ul></li></ul><ol><li>根列表<ol><li>字列表1<ol><li>子列表2</li></ol></li></ol></li></ol><h2 id="八-表格"><a href="#八-表格" class="headerlink" title="八.表格"></a>八.表格</h2><p><strong>格式</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs 格式">|左对齐|居中对齐|右对齐|<br>|:----|:----:|---:|<br>|左|中|右|<br><br>注意：第二行分割表头和内容，并声明内容的对齐格式<br></code></pre></td></tr></table></figure><table><thead><tr><th align="left">左对齐</th><th align="center">居中对齐</th><th align="right">右对齐</th></tr></thead><tbody><tr><td align="left">左</td><td align="center">中</td><td align="right">右</td></tr></tbody></table><h2 id="九-代码"><a href="#九-代码" class="headerlink" title="九.代码"></a>九.代码</h2><h3 id="1-行内代码"><a href="#1-行内代码" class="headerlink" title="1.行内代码"></a>1.行内代码</h3><p><strong>格式</strong>： </p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-string">`代码内容`</span><br></code></pre></td></tr></table></figure><p>举例：</p><p><code>行内代码</code></p><h3 id="2-多行代码"><a href="#2-多行代码" class="headerlink" title="2.多行代码"></a>2.多行代码</h3><p><strong>格式</strong>： </p><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-string">``</span><span class="hljs-string">`编程语言</span><br><span class="hljs-string">代码内容</span><br><span class="hljs-string">`</span><span class="hljs-string">``</span><br></code></pre></td></tr></table></figure><p>举例：</p><p><code>cpp 多行代码1 多行代码2 </code></p><h2 id="十-高级技巧"><a href="#十-高级技巧" class="headerlink" title="十.高级技巧"></a>十.高级技巧</h2><h3 id="1-转义"><a href="#1-转义" class="headerlink" title="1.转义"></a>1.转义</h3><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown">\   反斜线<br>`   反引号<br><span class="hljs-bullet">*</span>   星号<br>_   下划线<br>&#123;&#125;  花括号<br>[]  方括号<br>()  小括号<br><span class="hljs-section">#   井字号</span><br><span class="hljs-bullet">+</span>   加号<br><span class="hljs-bullet">-</span>   减号<br>.   英文句点<br>!   感叹号<br></code></pre></td></tr></table></figure><h3 id="2-公式"><a href="#2-公式" class="headerlink" title="2.公式"></a>2.公式</h3><ol><li>行内</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>f(x)=x<br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>$$<br>f(x)&#x3D;x<br>$$</p><ol start="2"><li>段落</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>s=\sum_1^n&#123;n_i&#125;<br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>$$<br>s&#x3D;\sum_1^n{n_i}<br>$$</p><ol start="3"><li>上标</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>x^<span class="hljs-number">2</span><br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>$$<br>x^2<br>$$</p><ol start="4"><li>下标</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>x_2<br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>$$<br>x_2<br>$$</p><ol start="5"><li>括号</li></ol><p>大括号：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span> <br>\lbrace a+x \rbrace<br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>$$<br>\lbrace a+x \rbrace<br>$$</p><figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs llvm">$$<br>f(<span class="hljs-keyword">x</span>)<span class="hljs-operator">=</span>\<span class="hljs-keyword">begin</span>&#123;cases&#125; <br><span class="hljs-number">1</span><span class="hljs-punctuation">,</span> &amp; <span class="hljs-keyword">x</span>&gt;<span class="hljs-number">0</span>\\ <br><span class="hljs-number">0</span><span class="hljs-punctuation">,</span> &amp; <span class="hljs-keyword">x</span><span class="hljs-operator">=</span><span class="hljs-number">0</span>\\<br><span class="hljs-number">-1</span><span class="hljs-punctuation">,</span> &amp; <span class="hljs-keyword">x</span>&lt;<span class="hljs-number">0</span><br>\<span class="hljs-keyword">end</span>&#123;cases&#125;<br>$$<br></code></pre></td></tr></table></figure><p>$$<br>f(x)&#x3D;\begin{cases}<br>        1, &amp; x&gt;0\<br>        0, &amp; x&#x3D;0\<br>        -1, &amp; x&lt;0<br>\end{cases}<br>$$</p><p>尖括号：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>\langle x \rangle<br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>$$<br>\langle x \rangle<br>$$</p><ol start="6"><li>上取整</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>\lceil \<span class="hljs-built_in">frac</span>&#123;x&#125;&#123;<span class="hljs-number">2</span>&#125; \rceil<br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>$$<br>\lceil \frac{x}{2} \rceil<br>$$</p><ol start="7"><li>下取整</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>\lfloor x \rfloor<br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>$$<br>\lfloor x \rfloor<br>$$</p><ol start="8"><li>求和</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>\sum_i^n<br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>$$<br>\sum_i^n<br>$$</p><ol start="9"><li>积分</li></ol><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs dust"><span class="language-xml">$$</span><br><span class="language-xml">\int_</span><span class="hljs-template-variable">&#123;1&#125;</span><span class="language-xml">^</span><span class="hljs-template-variable">&#123;\infty&#125;</span><span class="language-xml">\\</span><br><span class="language-xml">\prod_</span><span class="hljs-template-variable">&#123;1&#125;</span><span class="language-xml">^</span><span class="hljs-template-variable">&#123;n&#125;</span><span class="language-xml"> \\</span><br><span class="language-xml">\bigcup_</span><span class="hljs-template-variable">&#123;1&#125;</span><span class="language-xml">^</span><span class="hljs-template-variable">&#123;n&#125;</span><span class="language-xml"> \\</span><br><span class="language-xml">\iint_</span><span class="hljs-template-variable">&#123;1&#125;</span><span class="language-xml">^</span><span class="hljs-template-variable">&#123;n&#125;</span><span class="language-xml"></span><br><span class="language-xml">$$</span><br></code></pre></td></tr></table></figure><p>$$<br>\int_{1}^{\infty}\<br>\prod_{1}^{n} \<br>\bigcup_{1}^{n} \<br>\iint_{1}^{n}<br>$$</p><ol start="10"><li>分式</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>\<span class="hljs-built_in">frac</span> ab \\<br>\<span class="hljs-built_in">frac</span>&#123;<span class="hljs-number">1</span>&#125;&#123;<span class="hljs-number">2</span>&#125;\\<br>&#123;a+<span class="hljs-number">1</span> \over b+<span class="hljs-number">1</span>&#125;<br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>$$<br>\frac ab \<br>\frac{1}{2}\<br>{a+1 \over b+1}<br>$$</p><ol start="11"><li>根式</li></ol><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br>\<span class="hljs-built_in">sqrt</span>[x+<span class="hljs-number">1</span>]&#123;x^<span class="hljs-number">2</span>&#125;<br><span class="hljs-symbol">$</span><span class="hljs-symbol">$</span><br></code></pre></td></tr></table></figure><p>$$<br>\sqrt[x+1]{x^2}<br>$$</p><ol start="12"><li>字体&#x2F;编号</li></ol><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livescript"><span class="hljs-string">\mathbb</span><br><span class="hljs-string">\tag&#123;3&#125;</span><br></code></pre></td></tr></table></figure><ol start="13"><li>特殊函数与符号</li></ol><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs powershell"><span class="hljs-variable">$</span><span class="hljs-variable">$</span>\sum_&#123;i=<span class="hljs-number">0</span>&#125;^&#123;n&#125;<span class="hljs-variable">$</span><span class="hljs-variable">$</span><br><span class="hljs-variable">$</span><span class="hljs-variable">$</span>\prod<span class="hljs-variable">$</span><span class="hljs-variable">$</span><br><span class="hljs-variable">$</span><span class="hljs-variable">$</span>\lim_&#123;x\to +\infty&#125;<span class="hljs-variable">$</span><span class="hljs-variable">$</span><br><span class="hljs-variable">$</span><span class="hljs-variable">$x_n</span>\stackrel&#123;p&#125;\longrightarrow0<span class="hljs-variable">$</span><span class="hljs-variable">$</span><br><span class="hljs-variable">$</span><span class="hljs-variable">$</span>\vec&#123;a&#125;<span class="hljs-variable">$</span><span class="hljs-variable">$</span><br><span class="hljs-variable">$</span><span class="hljs-variable">$</span>\overrightarrow&#123;a&#125; <span class="hljs-variable">$</span><span class="hljs-variable">$</span><br><span class="hljs-variable">$</span><span class="hljs-variable">$</span>\hat y=a\hat x+b<span class="hljs-variable">$</span><span class="hljs-variable">$</span><br><span class="hljs-variable">$</span><span class="hljs-variable">$</span>\mathtt&#123;X&#125;<span class="hljs-string">&#x27;$$</span><br><span class="hljs-string">⨁ $\bigoplus$</span><br></code></pre></td></tr></table></figure><ol start="14"><li>矩阵</li></ol><figure class="highlight tap"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs tap">$$<br> \left[<br> \begin&#123;matrix&#125;<br>  <span class="hljs-number"> 1 </span>&amp;<span class="hljs-number"> 2 </span>&amp;<span class="hljs-number"> 3 </span>\\<br>  <span class="hljs-number"> 4 </span>&amp;<span class="hljs-number"> 5 </span>&amp;<span class="hljs-number"> 6 </span>\\<br>  <span class="hljs-number"> 7 </span>&amp;<span class="hljs-number"> 8 </span>&amp; 9<br>  \end&#123;matrix&#125;<br>  \right]<br>$$<br></code></pre></td></tr></table></figure><p>$$<br>\left[<br> \begin{matrix}<br>   1 &amp; 2 &amp; 3 \<br>   4 &amp; 5 &amp; 6 \<br>   7 &amp; 8 &amp; 9<br>  \end{matrix}<br>  \right]<br>$$</p><figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs livescript">$$<br><span class="hljs-string">\left[</span><br><span class="hljs-string">\begin&#123;matrix&#125;</span><br> <span class="hljs-number">1</span>      &amp; <span class="hljs-number">2</span>      &amp; <span class="hljs-string">\cdots</span> &amp; <span class="hljs-number">4</span>      <span class="hljs-string">\\</span><br> <span class="hljs-number">7</span>      &amp; <span class="hljs-number">6</span>      &amp; <span class="hljs-string">\cdots</span> &amp; <span class="hljs-number">5</span>      <span class="hljs-string">\\</span><br> <span class="hljs-string">\vdots</span> &amp; <span class="hljs-string">\vdots</span> &amp; <span class="hljs-string">\ddots</span> &amp; <span class="hljs-string">\vdots</span> <span class="hljs-string">\\</span><br> <span class="hljs-number">8</span>      &amp; <span class="hljs-number">9</span>      &amp; <span class="hljs-string">\cdots</span> &amp; <span class="hljs-number">0</span>      <span class="hljs-string">\\</span><br><span class="hljs-string">\end&#123;matrix&#125;</span><br><span class="hljs-string">\right]</span><br>$$<br></code></pre></td></tr></table></figure><p>$$<br>\left[<br>\begin{matrix}<br> 1      &amp; 2      &amp; \cdots &amp; 4      \<br> 7      &amp; 6      &amp; \cdots &amp; 5      \<br> \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br> 8      &amp; 9      &amp; \cdots &amp; 0      \<br>\end{matrix}<br>\right]<br>$$</p><ol start="15"><li>公式对齐</li></ol><figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs crystal"><span class="hljs-variable">$$</span><br>\<span class="hljs-keyword">begin</span>&#123;aligned&#125;<br>a &amp;= b + c\\<br>  &amp;= d + e + f<br>\<span class="hljs-keyword">end</span>&#123;aligned&#125; \tag&#123;<span class="hljs-number">3</span>&#125;<br><span class="hljs-variable">$$</span><br></code></pre></td></tr></table></figure><p>$$<br>\begin{aligned}<br>a &amp;&#x3D; b + c\<br>  &amp;&#x3D; d + e + f<br>\end{aligned}<br>$$</p>]]></content>
    
    
    
    <tags>
      
      <tag>Markdown</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>STL标准模板库</title>
    <link href="/2020/06/25/STL%20%E6%A0%87%E5%87%86%E6%A8%A1%E7%89%88%E7%B1%BB/"/>
    <url>/2020/06/25/STL%20%E6%A0%87%E5%87%86%E6%A8%A1%E7%89%88%E7%B1%BB/</url>
    
    <content type="html"><![CDATA[<h1 id="一-STL的六大组件"><a href="#一-STL的六大组件" class="headerlink" title="一.STL的六大组件"></a>一.STL的六大组件</h1><p>STL（Standard Template Library，标准模板库）是为了建立数据结构和算法的一套标准，并且降低它们之间的耦合关系，以提升各自的独立性、弹性、交互操作性。STL包含容器、算法、迭代器、仿函数、适配器（配接器）、空间配置器六大组件。</p><blockquote><p>STL的优点：</p><ol><li>被内建在编译器内部，无需额外安装。</li><li>将数据和操作分离。数据由容器类别加以管理，操作则由可定制的算法定义。迭代器在两者之间充当连接的桥梁，以使算法可以和容器交互运作。</li><li>高可重用性，高性能，高移植性，跨平台的优点</li></ol></blockquote><h2 id="1-1-容器"><a href="#1-1-容器" class="headerlink" title="1.1 容器"></a>1.1 容器</h2><p>容器（Containers）存放的是各种数据结构，如vector、list、deque等；而从<strong>实现角度</strong>讲，STL容器就是一种 class template。<br>根据数据在容器中的排列特性，容器可分为序列式容器和关联式容器：</p><ul><li>序列式容器：强调值的排序，序列式容器中的每个元素均有固定位置，除非用插入或删除操作改变这个位置。</li><li>关联式容器：是非线性的树结构，更准确的说是二叉树结构。各元素之间没有严格的物理上的顺序关系，元素在容器中并没有保存元素置入容器时的逻辑顺序。关联式容器的显著特点：它是以键值的方式来保存数据。</li></ul><p>此外还有容器适配器：适配器是使一事物的行为类似于另一事物的行为的一种机制。容器适配器是让一种已存在的容器类型采用另一种不同的抽象类型的工作方式来实现的一种机制。</p><h2 id="1-2-算法"><a href="#1-2-算法" class="headerlink" title="1.2 算法"></a>1.2 算法</h2><p>算法（Algorithms）是什么，<strong>算法就是步骤</strong>。算法就是解决特定逻辑问题及数学问题的有限步骤的合集。<br>算法具有<strong>五大基本特性</strong>：输入输出、有穷性、确定性、可行性。<br>STL 收录的算法是经过了无数程序人在实践中证明极具复用价值的合集。算法大致可以分为：</p><ul><li>质变算法：运算中会更改区间内元素的内容。如拷贝，替换，删除等。</li><li>非质变算法：运算中不会更改区间内的元素内容。如查找、计数、遍历等。</li></ul><hr><h2 id="1-3-迭代器"><a href="#1-3-迭代器" class="headerlink" title="1.3 迭代器"></a>1.3 迭代器</h2><p>迭代器（Iterators）是一种抽象的设计概念，现实程序语言中并没有直接对应于这个概念的实物。<br>《Design Patterns》中 iterator 模式定义如下：提供一种方法，使之能够依序寻访某个容器所含的各个元素，而又无需暴露该容器的内部表示方式。<br>迭代器的分类：</p><table><thead><tr><th align="center">迭代器</th><th align="center">功能</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">输入迭代器</td><td align="center">提供数据的只读访问</td><td align="center">只读</td></tr><tr><td align="center">输出迭代器</td><td align="center">提供数据的只写访问</td><td align="center">只写</td></tr><tr><td align="center">前向迭代器</td><td align="center">提供数据的读写操作并能向前推进推进操作</td><td align="center">读写</td></tr><tr><td align="center">双向迭代器</td><td align="center">提供数据的读写操作并能向前和向后推进操作</td><td align="center">读写</td></tr><tr><td align="center">随机访问迭代器</td><td align="center">提供数据的读写操作并能随机跳跃访问容器任意位置数据</td><td align="center">读写</td></tr></tbody></table><h2 id="1-4-仿函数"><a href="#1-4-仿函数" class="headerlink" title="1.4 仿函数"></a>1.4 仿函数</h2><p>仿函数（Functors）是行为类似函数，可作为算法的某种策略。从实现角度来看，仿函数是一种重载了 operator() 的 class 或者class template</p><h2 id="1-5-适配器（配接器）"><a href="#1-5-适配器（配接器）" class="headerlink" title="1.5 适配器（配接器）"></a>1.5 适配器（配接器）</h2><p>适配器（Adapters）是使一事物的行为类似于另一事物的行为的一种机制。容器适配器是让一种已存在的容器类型采用另一种不同的抽象类型的工作方式来实现的一种机制。它实质还是一个容器，只是它不依赖于具体的标准容器类型，可以理解为容器的模版；或者理解为容器的接口，适配器具体采用哪种容器类型去实现，在定义适配器的时候决定。</p><h2 id="1-6-配置器"><a href="#1-6-配置器" class="headerlink" title="1.6 配置器"></a>1.6 配置器</h2><p>配置器（Allocators）是负责空间的配置与管理。从实现角度看配置器是一个实现了动态空间配置、空间管理、空间释放的class tempalte。</p><blockquote><p>STL六大组件关系交错：</p><p>容器通过空间配置器取得数据存储空间，算法通过迭代器存储容器中的内容，仿函数可以协助算法完成不同的策略的变化，而适配器可以修饰仿函数。</p></blockquote><h1 id="二-STL常用容器类"><a href="#二-STL常用容器类" class="headerlink" title="二.STL常用容器类"></a>二.STL常用容器类</h1><p>STL常用容器类包括如下：</p><p> string、vector、deque、list、forward_list、stack、queue、priority_queue、map、multimap、set、multiset、unordered_map 、unordered_multimap、unordered_set、unordered_multiset。</p><p>标准容器类的分类及其特点：</p><ol><li>顺序式容器</li></ol><table><thead><tr><th align="center">名称</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">array</td><td align="center">大小是固定的，无法动态的扩展或收缩</td></tr><tr><td align="center">vector</td><td align="center">从后面快速插入与删除元素，可直接访问任何元素</td></tr><tr><td align="center">deque</td><td align="center">从前面或者后面插入与删除元素，可直接访问任何元素</td></tr><tr><td align="center">list</td><td align="center">双向链表，可从任意地方快速插入与删除</td></tr><tr><td align="center">forward_list</td><td align="center">单链表，可从任意地方快速插入与删除</td></tr></tbody></table><ol start="2"><li>容器适配器</li></ol><table><thead><tr><th align="center">名称</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">stack</td><td align="center">后进先出（LIFO）</td></tr><tr><td align="center">queue</td><td align="center">先进先出（FIFO）</td></tr><tr><td align="center">priority_queue</td><td align="center">最高优先级总是第一个出列</td></tr></tbody></table><ol start="3"><li>关联式容器</li></ol><table><thead><tr><th align="center">名称</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">map</td><td align="center">一对多映射，基于关键字快速查找，不允许重复值</td></tr><tr><td align="center">multimap</td><td align="center">一对多映射，基于关键字快速查找，允许重复值</td></tr><tr><td align="center">set</td><td align="center">快速查找，不允许重复值</td></tr><tr><td align="center">multiset</td><td align="center">快速查找，允许重复值</td></tr></tbody></table><ol start="4"><li>无序关联式容器</li></ol><table><thead><tr><th align="center">名称</th><th align="center">特点</th></tr></thead><tbody><tr><td align="center">unordered_map</td><td align="center">无序</td></tr><tr><td align="center">unordered_multimap</td><td align="center">无序</td></tr><tr><td align="center">unordered_set</td><td align="center">无序</td></tr><tr><td align="center">unordered_multiset</td><td align="center">无序</td></tr></tbody></table><h2 id="2-1-string-类"><a href="#2-1-string-类" class="headerlink" title="2.1 string 类"></a>2.1 string 类</h2><p>string  是 C++ 标准库中一个重要的容器，实际上它是一个类，而不是一个容器模板。<br>C语言字符串（以空字符结尾的字符数组）太过复杂难于掌握，不适合大程序的开发，所以C++标准库定义了一种 string 类，定义在 <code>&lt;string&gt;</code> 头文件当中。string 类是 STL 中 对 basic_string 模板实例化得到的模板类。其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">typedef</span> basic_string string;<br></code></pre></td></tr></table></figure><h2 id="2-2-array-容器"><a href="#2-2-array-容器" class="headerlink" title="2.2 array 容器"></a>2.2 array 容器</h2><p>是 C++ 11 标准中新增的顺序容器，它就是在 C++ 普通数组的基础上，添加了成员函数和全局函数。</p><p>它使用比普通数组更安全，且效率相当。array 容器的大小是固定的，无法动态的扩展或收缩，因此它只允许访问或者替换存储的数据元素。</p><hr><h2 id="2-3-vector-容器"><a href="#2-3-vector-容器" class="headerlink" title="2.3 vector 容器"></a>2.3 vector 容器</h2><p>vector 称为向量容器，是一种线性顺序结构。相当于数组，但其大小可以不预先指定，并且自动扩展。它可以像数组一样被操作，由于它的特性我们完全可以将 vector 看作动态数组。</p><p>在创建一个vector 后，它会自动在内存中分配一块连续的内存空间进行数据存储，初始的空间大小可以预先指定也可以由vector 默认指定，这个大小由 capacity() 函数的返回值确定。当存储的数据超过分配的空间时 vector 会重新分配一块内存块，但这样的分配是很耗时的，在重新分配空间时它会做这样的动作：</p><ol><li><p>首先，vector 申请一块更大的内存块；</p></li><li><p>其次，将原来的数据拷贝到新的内存块中；</p></li><li><p>然后，销毁掉原内存块中的对象（调用对象的析构函数）；</p></li><li><p>最后，将原来的内存空间释放掉。</p></li></ol><blockquote><p>注：vector 容器更擅长在尾部插入或删除元素而不擅长在容器头部或者中部插入或删除元素。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span> <span class="hljs-comment">// 头文件引用</span></span><br>vector&lt;<span class="hljs-type">int</span>&gt; vec;  <span class="hljs-comment">// 创建</span><br>vec.<span class="hljs-built_in">push_back</span>(x); <span class="hljs-comment">// 添加 o(1)</span><br>vec.<span class="hljs-built_in">pop_back</span>();   <span class="hljs-comment">// 删除 o(1)</span><br>vec[i]            <span class="hljs-comment">// 访问 o(1)</span><br></code></pre></td></tr></table></figure><h2 id="2-4-deque-容器"><a href="#2-4-deque-容器" class="headerlink" title="2.4 deque 容器"></a>2.4 deque 容器</h2><p>deque 是 double-ended queue 的缩写，又称双端队列。</p><p>deque 容器和 vector 容器的相同点：</p><ol><li><p>deque 容器也擅长在序列尾部添加或删除元素，而不擅长在序列中间添加或删除元素；</p></li><li><p>deque 容器也可根据需要修改自身的容量和大小。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;deque&gt;</span> <span class="hljs-comment">//引用头文件</span></span><br>deque&lt;<span class="hljs-type">int</span>&gt; deq;  <span class="hljs-comment">// 创建</span><br><span class="hljs-comment">// 添加 o(1)</span><br>deq.<span class="hljs-built_in">push_front</span>();<br>deq.<span class="hljs-built_in">push_back</span>();<br><span class="hljs-comment">// 删除 o(1)</span><br>deq.<span class="hljs-built_in">pop_front</span>();<br>deq.<span class="hljs-built_in">pop_back</span>();<br><span class="hljs-comment">// 访问 o(1)</span><br>deq.<span class="hljs-built_in">front</span>();<br>deq.<span class="hljs-built_in">back</span>();<br></code></pre></td></tr></table></figure></li></ol><h2 id="2-5-list-容器"><a href="#2-5-list-容器" class="headerlink" title="2.5 list 容器"></a>2.5 list 容器</h2><p>list 容器，又称双向链表容器，即该容器的底层是以双向链表的形式实现的。这意味着，list 容器中的元素可以分散存储在内存空间里，而不是必须存储在一整块连续的内存空间中。</p><h2 id="2-6-forward-list-容器"><a href="#2-6-forward-list-容器" class="headerlink" title="2.6 forward_list 容器"></a>2.6 forward_list 容器</h2><p>forward_list 容器是 C++ 11 新加入的容器，其底层实现和 list 容器一样，采用的也是链表结构，但是 forward_list 使用的是<strong>单链表</strong>，而 list 使用的是<strong>双向链表</strong>。</p><h2 id="2-7-stack-容器"><a href="#2-7-stack-容器" class="headerlink" title="2.7 stack 容器"></a>2.7 stack 容器</h2><p>stack 是限定仅在表尾进行插入删除操作的线性表，又称为后进先出（<strong>LIFO</strong>）的线性表。它不允许遍历，任何时候外界只能访问 stack 顶部的元素，只有在移除 stack 顶部的元素后，才能访问下方的元素。默认情况下，stack 使用 deque 作为底层容器。stack 容器应用广泛，如编辑器中的 undo （撤销操作）机制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stack&gt;</span> <span class="hljs-comment">//引用头文件</span></span><br>stack&lt;<span class="hljs-type">int</span>&gt; stk;  <span class="hljs-comment">// 创建</span><br>stk.<span class="hljs-built_in">push</span>(x);     <span class="hljs-comment">// 添加 o(1)</span><br>stk.<span class="hljs-built_in">pop</span>();       <span class="hljs-comment">// 删除 o(1)</span><br>stk.<span class="hljs-built_in">top</span>();       <span class="hljs-comment">// 访问 o(1)</span><br></code></pre></td></tr></table></figure><h2 id="2-8-queue-容器"><a href="#2-8-queue-容器" class="headerlink" title="2.8 queue 容器"></a>2.8 queue 容器</h2><p>queue 是限定表的一端进行插入操作，表的另一端进行删除操作的线性表，队列又称为先进先出（<strong>FIFO</strong>）的线性表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span> <span class="hljs-comment">//引用头文件</span></span><br>queue&lt;<span class="hljs-type">int</span>&gt; que;  <span class="hljs-comment">// 创建</span><br>que.<span class="hljs-built_in">push</span>();      <span class="hljs-comment">// 添加 o(1)</span><br>que.<span class="hljs-built_in">pop</span>();       <span class="hljs-comment">// 删除 o(1)</span><br>que.<span class="hljs-built_in">front</span>();     <span class="hljs-comment">// 访问 o(1)</span><br></code></pre></td></tr></table></figure><h2 id="2-9-priority-queue-容器"><a href="#2-9-priority-queue-容器" class="headerlink" title="2.9 priority_queue 容器"></a>2.9 priority_queue 容器</h2><p>priority_queue 的本质是<strong>大顶堆</strong>。priority_queue 在内部维护一个基于二叉树的大顶堆数据结构，在这个数据结构中，最大的元素始终位于堆顶部，只有堆顶部的数据元素（max heap element）才能被访问获取。当然，也可以通过自定义模板参数中的 class Compare 实现一个<strong>小顶堆</strong>。相比于 queue（普通队列）的先进先出（FIFO），priority_queue 实现最高优先级先出。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;queue&gt;</span>       <span class="hljs-comment">//引用头文件</span></span><br>priority_queue&lt;<span class="hljs-type">int</span>&gt; q; <span class="hljs-comment">// 创建</span><br>q.<span class="hljs-built_in">push</span>(x);             <span class="hljs-comment">// 添加 o(logn)</span><br>q.<span class="hljs-built_in">pop</span>();               <span class="hljs-comment">// 删除 o(logn)</span><br>q.<span class="hljs-built_in">top</span>();               <span class="hljs-comment">// 访问 o(1)</span><br></code></pre></td></tr></table></figure><h2 id="2-10-map-容器"><a href="#2-10-map-容器" class="headerlink" title="2.10 map 容器"></a>2.10 map 容器</h2><p>map 通过底层的<strong>红黑树</strong>数据结构将所有的数据元素按照 key 的相对大小进行排序，所实现的排序效果也是严格弱序特性。map 支持在一个子集合上进行直接迭代器访问，因为 map 中的元素是被有序组织的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span>      <span class="hljs-comment">//引用头文件</span></span><br>map&lt;string, <span class="hljs-type">int</span>&gt; m; <span class="hljs-comment">// 创建</span><br>m[str] = x;         <span class="hljs-comment">// 添加 o(logn)</span><br>m.<span class="hljs-built_in">erase</span>(it);        <span class="hljs-comment">// 删除 o(logn)</span><br><span class="hljs-comment">// 访问 o(logn)</span><br>m.<span class="hljs-built_in">count</span>(str);<br>m[str];<br></code></pre></td></tr></table></figure><h2 id="2-11-multimap-容器"><a href="#2-11-multimap-容器" class="headerlink" title="2.11 multimap 容器"></a>2.11 multimap 容器</h2><p>multimap 是关联式容器，是使用红黑树对记录型的元素数据,按元素键值的比较关系，进行快速的插入、删除和检索操作，所不同的是 multimap 允许将具有重复键值的元素插入容器。</p><p>multimap 按照特定顺序来存储键值对 &lt;key、value&gt; ，其中多个键值对之间的 key 可以重复；键 key 通常用于排序及唯一标识元素，值 value 则存储与键 key 关联的内容。</p><h2 id="2-12-set-容器"><a href="#2-12-set-容器" class="headerlink" title="2.12 set 容器"></a>2.12 set 容器</h2><p>set 就是集合，是利用二叉树实现，集合中的每个元素只出现一次(参照数学中集合的互斥性)，并且是排好序的（默认按键值升序排列）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;set&gt;</span> <span class="hljs-comment">//引用头文件</span></span><br>set&lt;<span class="hljs-type">int</span>&gt; s;    <span class="hljs-comment">// 创建</span><br>s.<span class="hljs-built_in">insert</span>(x);   <span class="hljs-comment">// 添加 o(logn)</span><br>s.<span class="hljs-built_in">erase</span>(it);   <span class="hljs-comment">// 删除 o(logn)</span><br>s.<span class="hljs-built_in">count</span>(x);    <span class="hljs-comment">// 访问 o(k+logn)</span><br></code></pre></td></tr></table></figure><h2 id="2-13-multiset-容器"><a href="#2-13-multiset-容器" class="headerlink" title="2.13 multiset 容器"></a>2.13 multiset 容器</h2><ol><li>multiset 是按照特定顺序存储元素的容器，其中元素是可以重复的；</li><li>元素的 value 会识别它组成的键值对，multiset 元素的值不能在容器中进行修改，但可以插入和删除；</li><li>multiset 在内部按照特定的严格弱排序准则进行排序；</li><li>multiset 容器通过 key 访问单个元素比 unordered_multiset 容器慢，但当使用迭代器遍历的时候，会得到一个有序序列；</li><li>multiset 的底层是二叉搜索树（红黑树）。</li></ol><h2 id="2-14-unordered-map-容器"><a href="#2-14-unordered-map-容器" class="headerlink" title="2.14 unordered_map 容器"></a>2.14 unordered_map 容器</h2><ol><li>unordered_map 是一个将 key 和 value 关联起来的容器，可以根据单个 key 键高效查找对应 value 值；</li><li>key 键是唯一的，key 键和 value 值的数据类型可以不同；</li><li>unordered_map 存储是无序的，是根据 key 键的哈希值将元素存储在指定位置，并且根据 key 键查找单个value 值时非常高效；</li><li>unordered_map 查询单个 key 键效率比 map 高，但是查询某一范围内的 key 键时比 map 效率低；</li><li>可以使用 [ ] 操作符来访问 key 键对应的 value 值。</li></ol><blockquote><p>注：如果需要内部元素自动排序，使用map，不需要排序使用unordered_map。</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_map&gt;</span>      <span class="hljs-comment">//引用头文件</span></span><br>unordered_map&lt;string, <span class="hljs-type">int</span>&gt; m; <span class="hljs-comment">// 创建</span><br>m[str] = x;                   <span class="hljs-comment">// 添加 o(1) / o(n)</span><br>m.<span class="hljs-built_in">erase</span>(it);                  <span class="hljs-comment">// 删除 o(1) / o(n)</span><br><span class="hljs-comment">// 访问 o(1) / o(n)</span><br>m.<span class="hljs-built_in">count</span>(str);<br>m[str];<br></code></pre></td></tr></table></figure><h2 id="2-15-unordered-multimap-容器"><a href="#2-15-unordered-multimap-容器" class="headerlink" title="2.15 unordered_multimap 容器"></a>2.15 unordered_multimap 容器</h2><p>unordered_multimap 是一个封装哈希表的无序容器。容器中每个元素都是键值对 &lt;key、value&gt; ，每个 key 键可重复出现。</p><h2 id="2-16-unordered-set-容器"><a href="#2-16-unordered-set-容器" class="headerlink" title="2.16 unordered_set  容器"></a>2.16 unordered_set  容器</h2><p>unordered_set 是一种不按特定顺序存储唯一元素的容器，允许根据元素的值快速检索单个元素。unordered_set 容器和 set 容器很像，唯一的区别就在于 set 容器会自行对存储的数据进行排序，而unordered_set 容器不会。</p><p>几大特性：</p><ol><li>不以键值对 &lt;key、value&gt;的形式存储数据，而是直接存储数据的值；</li><li>容器内部存储的各个元素的值都互不相等，且不能被修改；</li><li>不对内部存储的数据进行排序。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unordered_set&gt;</span> <span class="hljs-comment">//引用头文件</span></span><br>unordered_set&lt;<span class="hljs-type">int</span>&gt; s;    <span class="hljs-comment">// 创建</span><br>s.<span class="hljs-built_in">insert</span>(x);             <span class="hljs-comment">// 添加 o(1) / o(n)</span><br>s.<span class="hljs-built_in">erase</span>(it);             <span class="hljs-comment">// 删除 o(1) / o(n)</span><br>s.<span class="hljs-built_in">count</span>(x);              <span class="hljs-comment">// 访问 o(1) / o(n)</span><br></code></pre></td></tr></table></figure></li></ol><h2 id="2-17-unordered-multiset-容器"><a href="#2-17-unordered-multiset-容器" class="headerlink" title="2.17 unordered_multiset  容器"></a>2.17 unordered_multiset  容器</h2><p>unordered_multiset 容器可同时存储多个相同值的元素，且这些元素会存储到哈希表中（本质就是链表）。</p><p>它有如下特性：</p><ul><li>不以键值对 &lt;key、value&gt;的形式存储数据，而是直接存储数据的值；</li><li>该类型容器底层采用的也是哈希表存储结构，它不会对内部存储的数据进行排序；</li><li>容器内部存储的元素值不能被修改。</li></ul><h1 id="三-C-的一些函数使用"><a href="#三-C-的一些函数使用" class="headerlink" title="三.C++的一些函数使用"></a>三.C++的一些函数使用</h1><h2 id="3-1-algorithm头文件"><a href="#3-1-algorithm头文件" class="headerlink" title="3.1 algorithm头文件"></a>3.1 algorithm头文件</h2><p>algorithm 头文件是C++的标准算法库，它主要应用在容器上。此头文件常用的函数有：</p><ol><li>max()、min()、abs() 函数</li><li>swap() 函数</li><li>reverse() 函数</li><li>sort() 函数</li><li>find() 函数</li><li>upper_bound()、lower_bound() 函数</li><li>fill() 函数</li><li>count() 函数</li><li>_gcd() 函数求最大公约数</li><li>set_intersection()、set_union()、set_difference() 函数</li></ol><h2 id="3-2-转换和判定函数"><a href="#3-2-转换和判定函数" class="headerlink" title="3.2 转换和判定函数"></a>3.2 转换和判定函数</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-built_in">stoi</span>(<span class="hljs-type">const</span> string *str);<span class="hljs-comment">//</span><br><span class="hljs-built_in">atoi</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *ch);<span class="hljs-comment">//</span><br><span class="hljs-built_in">atol</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *str);<span class="hljs-comment">//</span><br><br><span class="hljs-built_in">islower</span>(<span class="hljs-type">char</span> c);<span class="hljs-comment">//是否为小写字母</span><br><span class="hljs-built_in">isuppper</span>(<span class="hljs-type">char</span> c);<span class="hljs-comment">//为大写字母</span><br><span class="hljs-built_in">isdigit</span>(<span class="hljs-type">char</span> c);<span class="hljs-comment">//是否为数字</span><br><span class="hljs-built_in">isalpha</span>(<span class="hljs-type">char</span> c);<span class="hljs-comment">//是否为字母</span><br><span class="hljs-built_in">isalnum</span>(<span class="hljs-type">char</span> c); <span class="hljs-comment">//是否为字母或者数字</span><br><span class="hljs-built_in">toupper</span>(<span class="hljs-type">char</span> c); <span class="hljs-comment">//字母小转大</span><br><span class="hljs-built_in">tolower</span>(<span class="hljs-type">char</span> c); <span class="hljs-comment">//字母大转小</span><br></code></pre></td></tr></table></figure><h2 id="3-3-pair-tuple-容器"><a href="#3-3-pair-tuple-容器" class="headerlink" title="3.3 pair &amp; tuple  容器"></a>3.3 pair &amp; tuple  容器</h2><p>std::pair 和 std::tuple 不是STL容器库中的容器，由于经常用到，顺便整理。pair 相当于 tuple 的特例。</p><ul><li>pair 是将2个数据组合成一个数据，当需要这样的需求时就可以使用pair，如STL中的map就是将key和value放在一起来保存。另一个应用是，当一个函数需要返回2个数据的时候，可以选择 pair。pair 的实现是一种结构体，主要的两个成员变量是 first , second。</li><li>tuple是C++11新标准里的类型。它是一个类似 pair 类型的模板。pair 类型是每个成员变量各自可以是任意类型，但是只能有俩个成员，而 tuple 与 pair 不同的是它可以有任意数量的成员。但是每个确定的 tuple 类型的成员数目是固定的。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>STL</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>搭建自己的Hexo博客</title>
    <link href="/2020/04/10/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%20Hexo%20%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/04/10/%E6%90%AD%E5%BB%BA%E8%87%AA%E5%B7%B1%E7%9A%84%20Hexo%20%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<hr><h1 id="1-Hexo简介"><a href="#1-Hexo简介" class="headerlink" title="1 Hexo简介"></a>1 Hexo简介</h1><p>Hexo基于Node.js的博客部署框架，Hexo能使用Markdown或者其他渲染格式解析文章，安装Hexo只需几分钟时间。<br>Hexo博客部署框架有如下特点：</p><ul><li>快速性</li><li>简洁性</li><li>高效性</li></ul><hr><h1 id="2-环境准备"><a href="#2-环境准备" class="headerlink" title="2 环境准备"></a>2 环境准备</h1><h2 id="2-1-安装Node-js"><a href="#2-1-安装Node-js" class="headerlink" title="2.1 安装Node.js"></a>2.1 安装Node.js</h2><p>首先访问Node.js的官网获取最新LTS安装包：<a href="https://nodejs.org/en/">Node.js官网</a></p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/1.%E8%AE%BF%E9%97%AENode.js%E5%AE%98%E7%BD%91.jpg" alt="下载Node.js"  /></div><p>然后打开下载的Node.js安装包点击安装（安装时全程Default即可）</p><div style="text-align: center;">    <img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/2.%E5%AE%89%E8%A3%85Node.js.jpg"  /></div><p>Win+R打开“运行”并输入cmd打开命令窗口，输入如下代码验证安装完整性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">node -v<br>npm -v<br></code></pre></td></tr></table></figure><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/3.%E9%AA%8C%E8%AF%81Node.js%E5%AE%8C%E6%95%B4%E6%80%A7.jpg" alt="Node.js版本"  /></div><h2 id="2-2-安装Git"><a href="#2-2-安装Git" class="headerlink" title="2.2 安装Git"></a>2.2 安装Git</h2><p>首先访问Git的官网获取最新的Git安装包：<a href="https://git-scm.com/">Git官网</a></p><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/4.%E4%BB%8EGit%E5%AE%98%E7%BD%91%E8%8E%B7%E5%8F%96Git%E5%AE%89%E8%A3%85%E5%8C%85.jpg" alt="获取Git安装包"  /></div><p>然后打开下载的Git安装包点击安装（安装时全程Default即可）</p><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/5.%E5%AE%89%E8%A3%85Git.jpg" alt="安装Git"  /></div><p>Win+R打开“运行”并输入cmd打开命令窗口，输入如下代码验证安装完整性</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git --version<br></code></pre></td></tr></table></figure><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/6.%E9%AA%8C%E8%AF%81Git%E5%AE%8C%E6%95%B4%E6%80%A7.jpg" alt="Git版本"  /></div><hr><h1 id="3-Hexo部署"><a href="#3-Hexo部署" class="headerlink" title="3 Hexo部署"></a>3 Hexo部署</h1><h2 id="3-1-安装Hexo框架"><a href="#3-1-安装Hexo框架" class="headerlink" title="3.1 安装Hexo框架"></a>3.1 安装Hexo框架</h2><p>通过npm install -g hexo-cli命令部署hexo框架</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install -g hexo-cli<br></code></pre></td></tr></table></figure><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/7.Hexo%E6%A1%86%E6%9E%B6%E5%AE%89%E8%A3%85.jpg" alt="安装Hexo框架"  /></div><h2 id="3-2-Hexo初始化"><a href="#3-2-Hexo初始化" class="headerlink" title="3.2 Hexo初始化"></a>3.2 Hexo初始化</h2><p>通过hexo init命令初始化博客</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo init<br></code></pre></td></tr></table></figure><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/hexo%20init.jpg" alt="Init"  /></div><h2 id="3-3-Hexo生成"><a href="#3-3-Hexo生成" class="headerlink" title="3.3 Hexo生成"></a>3.3 Hexo生成</h2><p>通过hexo generate命令生成博客</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo generate<br></code></pre></td></tr></table></figure><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/hexo%20generate.jpg" alt="Generate"  /></div><h2 id="3-4-Hexo启动"><a href="#3-4-Hexo启动" class="headerlink" title="3.4 Hexo启动"></a>3.4 Hexo启动</h2><p>通过hexo server命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo server<br></code></pre></td></tr></table></figure><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/hexo%20server.jpg" alt="Server"  /></div><p>再通过 <a href="http://localhost:4000/">http://localhost:4000/</a> 即可本地访问博客主页</p><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/hexo%E5%8D%9A%E5%AE%A2%E6%9C%AC%E5%9C%B0%E8%AE%BF%E9%97%AE.jpg" alt="本地访问"  /></div><h2 id="3-5-Hexo部署"><a href="#3-5-Hexo部署" class="headerlink" title="3.5 Hexo部署"></a>3.5 Hexo部署</h2><p>通过hexo deploy命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo deploy<br></code></pre></td></tr></table></figure><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/hexo%20deploy.jpg" alt="Deploy"  /></div><h2 id="3-6-Hexo清除"><a href="#3-6-Hexo清除" class="headerlink" title="3.6 Hexo清除"></a>3.6 Hexo清除</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br></code></pre></td></tr></table></figure><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/hexo%20clean.jpg" alt="Clean"  /></div><h2 id="3-7-添加文章"><a href="#3-7-添加文章" class="headerlink" title="3.7 添加文章"></a>3.7 添加文章</h2><p>在博客文件夹下的 &#x2F;source&#x2F;_post 文件夹下面创建需更新的博客，完成后便可将其部署到GitHub服务器上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo new post &lt;新建的Markdown文件名&gt;<br></code></pre></td></tr></table></figure><hr><h1 id="4-将Hexo博客部署到GitHub上托管"><a href="#4-将Hexo博客部署到GitHub上托管" class="headerlink" title="4 将Hexo博客部署到GitHub上托管"></a>4 将Hexo博客部署到GitHub上托管</h1><h2 id="4-1-新建GitHub仓库"><a href="#4-1-新建GitHub仓库" class="headerlink" title="4.1 新建GitHub仓库"></a>4.1 新建GitHub仓库</h2><p><strong>第一步</strong>：在GitHub本人主页上点击加号（+）选择new repository创建新仓库</p><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/%E6%96%B0%E5%BB%BA%E4%BB%93%E5%BA%931.jpg" alt="新建仓库"  /></div><p><strong>第二步</strong>：在新建仓库的页面键入本人的Repository name（注意一定要以.github.io结尾）</p><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/%E6%96%B0%E5%BB%BA%E4%BB%93%E5%BA%932.jpg" alt="输入仓库名称"  /></div><p><strong>第三步</strong>：生成以后的仓库中红框部分是后面将Hexo博客部署到GitHub上所需的链接</p><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/%E6%96%B0%E5%BB%BA%E4%BB%93%E5%BA%933.jpg" alt="仓库链接"  /></div><h2 id="4-2-将Hexo博客部署到GitHub服务器上"><a href="#4-2-将Hexo博客部署到GitHub服务器上" class="headerlink" title="4.2 将Hexo博客部署到GitHub服务器上"></a>4.2 将Hexo博客部署到GitHub服务器上</h2><p>将博客根目录下的_config.yml配置文件进行如下更改：</p><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/config%E7%9A%84%E9%83%A8%E7%BD%B2%E6%A0%8F%E6%9B%B4%E6%94%B9.jpg" alt="部署博客到Git上"  /></div><p>完成操作之后重新部署生效到GitHub上</p><hr><h1 id="5-更改Hexo博客主题"><a href="#5-更改Hexo博客主题" class="headerlink" title="5 更改Hexo博客主题"></a>5 更改Hexo博客主题</h1><h2 id="5-1-获取主题"><a href="#5-1-获取主题" class="headerlink" title="5.1 获取主题"></a>5.1 获取主题</h2><p>使用如下命令克隆GitHub仓库中的主题到本地</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git <span class="hljs-built_in">clone</span> https://github.com/litten/hexo-theme-yilia.git themes/yilia<br></code></pre></td></tr></table></figure><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/%E8%8E%B7%E5%8F%96%E4%B8%BB%E9%A2%98%E5%88%B0%E6%9C%AC%E5%9C%B0.jpg" alt="获取主题"  /></div><h2 id="5-2-更改配置文件"><a href="#5-2-更改配置文件" class="headerlink" title="5.2 更改配置文件"></a>5.2 更改配置文件</h2><p>将本地博客所下载的主题根目录的_config.yml文件进行如下更改：</p><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/%E6%9B%B4%E6%94%B9%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84theme%E9%A1%B9.jpg" alt="修改主题的Config配置文件"  /></div><h2 id="5-3-重新部署到服务器"><a href="#5-3-重新部署到服务器" class="headerlink" title="5.3 重新部署到服务器"></a>5.3 重新部署到服务器</h2><p>后续执行以下操作部署到GitHub上即可完成主题更换操作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">hexo clean<br>hexo generate<br>hexo deploy<br></code></pre></td></tr></table></figure><h2 id="5-4-绑定个人域名"><a href="#5-4-绑定个人域名" class="headerlink" title="5.4 绑定个人域名"></a>5.4 绑定个人域名</h2><p>绑定个人域名参照: <a href="https://blog.csdn.net/heimu24/article/details/81159099?spm=1001.2014.3001.5506">Github个人博客：绑定域名</a></p><hr><h1 id="6-Hexo博客搭建常见问题"><a href="#6-Hexo博客搭建常见问题" class="headerlink" title="6 Hexo博客搭建常见问题"></a>6 Hexo博客搭建常见问题</h1><h2 id="6-1-无法远程访问GitHub仓库"><a href="#6-1-无法远程访问GitHub仓库" class="headerlink" title="6.1 无法远程访问GitHub仓库"></a>6.1 无法远程访问GitHub仓库</h2><p>第一次部署时候可能出现无法无法访问GitHub仓库的情况，考虑可能是SSH配置错误，只需正确配置SSH key即可，详细可参见如下链接的解决方法：<a href="https://blog.csdn.net/weixin_30940783/article/details/99581061">正确配置SSH key并远程访问GitHub</a></p><h2 id="6-2-DNS域名解析异常"><a href="#6-2-DNS域名解析异常" class="headerlink" title="6.2 DNS域名解析异常"></a>6.2 DNS域名解析异常</h2><p>在部署过程中可能遇到无法将博客部署到GitHub上的情况，通过Windows控制的ping命令无法ping通GitHub官网网址，则是出现了DNS域名解析异常。<br><strong>解决方法一</strong>：</p><ol><li>在Windows系统中，访问 C:\Windows\System32\drivers\etc\hosts 文件并在末尾添加如下命令</li><li>在Linux系统中，访问 &#x2F;etc&#x2F;hosts 文件并在末尾添加如下命令</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment">#前者为GitHub的网址IP，后者为GitHub网址的域名</span><br>140.82.112.4        github.com<br></code></pre></td></tr></table></figure><p><strong>解决方法二</strong>：更改为国内的Gitee码云，部署方法与GitHub类似</p><h2 id="6-3-部署失败"><a href="#6-3-部署失败" class="headerlink" title="6.3 部署失败"></a>6.3 部署失败</h2><ol><li>在执行hexo deploy命令时出现 ERROR Deployer not found: git 的错误<br>解决方法是执行如下代码然后再重新部署</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">npm install --save hexo-deployer-git<br></code></pre></td></tr></table></figure><div style="text-align: center;"><img src="https://dustwind-picture-upload.oss-cn-chengdu.aliyuncs.com/img/%E9%83%A8%E7%BD%B2Hexo/hexo%E5%AE%89%E8%A3%85git%E7%BB%84%E4%BB%B6.jpg" alt="Hexo安装git组件"  /></div><ol start="2"><li>出现403错误可以将 _config.yml 配置文件中 repo 字段的 https 地址更改为 SSH 地址。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Hexo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2019/03/11/hello-world/"/>
    <url>/2019/03/11/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
    <tags>
      
      <tag>Hello World</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
